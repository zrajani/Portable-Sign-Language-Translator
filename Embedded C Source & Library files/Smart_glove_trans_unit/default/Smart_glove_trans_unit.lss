
Smart_glove_trans_unit.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001c12  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000030e  00800060  00001c12  00001ca6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000003ee  0080036e  0080036e  00001fb4  2**0
                  ALLOC
  3 .debug_aranges 00000020  00000000  00000000  00001fb4  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000431  00000000  00000000  00001fd4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000287c  00000000  00000000  00002405  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000456  00000000  00000000  00004c81  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00002dbc  00000000  00000000  000050d7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000002d0  00000000  00000000  00007e94  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000423  00000000  00000000  00008164  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000013d2  00000000  00000000  00008587  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000168  00000000  00000000  00009959  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	13 e0       	ldi	r17, 0x03	; 3
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e2 e1       	ldi	r30, 0x12	; 18
      68:	fc e1       	ldi	r31, 0x1C	; 28
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	ae 36       	cpi	r26, 0x6E	; 110
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	17 e0       	ldi	r17, 0x07	; 7
      78:	ae e6       	ldi	r26, 0x6E	; 110
      7a:	b3 e0       	ldi	r27, 0x03	; 3
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	ac 35       	cpi	r26, 0x5C	; 92
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 a5 0b 	call	0x174a	; 0x174a <main>
      8a:	0c 94 07 0e 	jmp	0x1c0e	; 0x1c0e <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <init_adc>:


void init_adc()                 //initialize the ADC of the microcontroller
                                //call this function first at the beginning
{
ADMUX=(1<<REFS0);              //Aref joined to AVcc
      92:	80 e4       	ldi	r24, 0x40	; 64
      94:	87 b9       	out	0x07, r24	; 7
ADCSRA=(1<<ADEN)|(7<<ADPS0);
      96:	87 e8       	ldi	r24, 0x87	; 135
      98:	86 b9       	out	0x06, r24	; 6
}
      9a:	08 95       	ret

0000009c <disab_adc>:

void disab_adc()
{
ADCSRA=0x00;
      9c:	16 b8       	out	0x06, r1	; 6
ADMUX=0x00;
      9e:	17 b8       	out	0x07, r1	; 7
}
      a0:	08 95       	ret

000000a2 <read_adc>:
   //Select ADC Channel ch must be 0-7 (corresponds to the flex sensors...)
   //flex sensors from channel 0-4
   //acccelerometer from channel 5-7
   
   //ch=ch & 0b00000111;
   ADMUX = ch;
      a2:	87 b9       	out	0x07, r24	; 7

   //Start Single conversion
   ADCSRA|=(1<<ADSC);
      a4:	36 9a       	sbi	0x06, 6	; 6

   //Wait for conversion to complete
   while(!(ADCSRA & (1<<ADIF)));
      a6:	34 9b       	sbis	0x06, 4	; 6
      a8:	fe cf       	rjmp	.-4      	; 0xa6 <read_adc+0x4>

   //Clear ADIF by writing one to it
   ADCSRA|=(1<<ADIF);
      aa:	34 9a       	sbi	0x06, 4	; 6

   return(ADCW);
      ac:	24 b1       	in	r18, 0x04	; 4
      ae:	35 b1       	in	r19, 0x05	; 5
}
      b0:	c9 01       	movw	r24, r18
      b2:	08 95       	ret

000000b4 <read8_adc>:
   //Select ADC Channel ch must be 0-7 (corresponds to the flex sensors...)
   //flex sensors from channel 0-4
   //acccelerometer from channel 5-7
   
   //ch=ch & 0b00000111;
   ADMUX = ch;
      b4:	87 b9       	out	0x07, r24	; 7

   //Start Single conversion
   ADCSRA|=(1<<ADSC);
      b6:	36 9a       	sbi	0x06, 6	; 6

   //Wait for conversion to complete
   while(!(ADCSRA & (1<<ADIF)));
      b8:	34 9b       	sbis	0x06, 4	; 6
      ba:	fe cf       	rjmp	.-4      	; 0xb8 <read8_adc+0x4>

   //Clear ADIF by writing one to it
   ADCSRA|=(1<<ADIF);
      bc:	34 9a       	sbi	0x06, 4	; 6
   
   temp=(ADCW>>2);
      be:	84 b1       	in	r24, 0x04	; 4
      c0:	95 b1       	in	r25, 0x05	; 5
      c2:	96 95       	lsr	r25
      c4:	87 95       	ror	r24
      c6:	96 95       	lsr	r25
      c8:	87 95       	ror	r24
   return((uint8_t)temp);
   
   
}
      ca:	08 95       	ret

000000cc <e_read>:
disab_adc();
}
*/

uint8_t e_read(int address)
{   
      cc:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
      ce:	e1 99       	sbic	0x1c, 1	; 28
      d0:	fe cf       	rjmp	.-4      	; 0xce <e_read+0x2>
#if E2END <= 0xFF
    EEARL = (uint8_t)__p;
#else
    EEAR = (uint16_t)__p;
      d2:	3f bb       	out	0x1f, r19	; 31
      d4:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
      d6:	e0 9a       	sbi	0x1c, 0	; 28
      d8:	8d b3       	in	r24, 0x1d	; 29
       //returns value(0-255) from the address given
       //address value from 0-1023 for ATmega 32

	return eeprom_read_byte((unsigned char *) address);
}
      da:	08 95       	ret

000000dc <e_write>:

void e_write(int address, uint8_t value)  //value from 0-255
{   
      dc:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
      de:	e1 99       	sbic	0x1c, 1	; 28
      e0:	fe cf       	rjmp	.-4      	; 0xde <e_write+0x2>
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
      e2:	3f bb       	out	0x1f, r19	; 31
      e4:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
      e6:	6d bb       	out	0x1d, r22	; 29

    __asm__ __volatile__ (
      e8:	0f b6       	in	r0, 0x3f	; 63
      ea:	f8 94       	cli
      ec:	e2 9a       	sbi	0x1c, 2	; 28
      ee:	e1 9a       	sbi	0x1c, 1	; 28
      f0:	0f be       	out	0x3f, r0	; 63
       //writes a value(0-255) to the given address
       //address value from 0-1023 for ATmega 32
 
	eeprom_write_byte((unsigned char *) address, value);
}
      f2:	08 95       	ret

000000f4 <key_read>:
  //constant polling is required to read the keys
  //use a character variable to store the key value returned by the function

uint8_t row=0,cntr,col=0;

keypad_DDR=0x00;
      f4:	11 ba       	out	0x11, r1	; 17
keypad_PORT=0x0F;
      f6:	8f e0       	ldi	r24, 0x0F	; 15
      f8:	82 bb       	out	0x12, r24	; 18
      fa:	20 e0       	ldi	r18, 0x00	; 0
      fc:	44 e0       	ldi	r20, 0x04	; 4
      fe:	50 e0       	ldi	r21, 0x00	; 0

for(cntr=4;cntr<8;cntr++)
{
keypad_DDR=(1 << cntr);
     100:	61 e0       	ldi	r22, 0x01	; 1
     102:	70 e0       	ldi	r23, 0x00	; 0
     104:	cb 01       	movw	r24, r22
     106:	04 2e       	mov	r0, r20
     108:	02 c0       	rjmp	.+4      	; 0x10e <key_read+0x1a>
     10a:	88 0f       	add	r24, r24
     10c:	99 1f       	adc	r25, r25
     10e:	0a 94       	dec	r0
     110:	e2 f7       	brpl	.-8      	; 0x10a <key_read+0x16>
     112:	81 bb       	out	0x11, r24	; 17
row=keypad_PIN;
     114:	80 b3       	in	r24, 0x10	; 16

if(row==0b00001110) {row=1;break;}
     116:	8e 30       	cpi	r24, 0x0E	; 14
     118:	e1 f0       	breq	.+56     	; 0x152 <key_read+0x5e>
else if(row==0b00001101) {row=2;break;}
     11a:	8d 30       	cpi	r24, 0x0D	; 13
     11c:	41 f1       	breq	.+80     	; 0x16e <key_read+0x7a>
else if(row==0b00001011) {row=3;break;}
     11e:	8b 30       	cpi	r24, 0x0B	; 11
     120:	b1 f1       	breq	.+108    	; 0x18e <key_read+0x9a>
else if(row==0b00000111) {row=4;break;}
     122:	87 30       	cpi	r24, 0x07	; 7
     124:	09 f4       	brne	.+2      	; 0x128 <key_read+0x34>
     126:	43 c0       	rjmp	.+134    	; 0x1ae <key_read+0xba>
++col;
     128:	2f 5f       	subi	r18, 0xFF	; 255
     12a:	4f 5f       	subi	r20, 0xFF	; 255
     12c:	5f 4f       	sbci	r21, 0xFF	; 255
uint8_t row=0,cntr,col=0;

keypad_DDR=0x00;
keypad_PORT=0x0F;

for(cntr=4;cntr<8;cntr++)
     12e:	24 30       	cpi	r18, 0x04	; 4
     130:	49 f7       	brne	.-46     	; 0x104 <key_read+0x10>
else if(row==0b00001011) {row=3;break;}
else if(row==0b00000111) {row=4;break;}
++col;
}

switch(row)
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	09 f4       	brne	.+2      	; 0x138 <key_read+0x44>
     136:	4b c0       	rjmp	.+150    	; 0x1ce <key_read+0xda>
     138:	83 30       	cpi	r24, 0x03	; 3
     13a:	18 f4       	brcc	.+6      	; 0x142 <key_read+0x4e>
     13c:	81 30       	cpi	r24, 0x01	; 1
     13e:	39 f4       	brne	.+14     	; 0x14e <key_read+0x5a>
     140:	46 c0       	rjmp	.+140    	; 0x1ce <key_read+0xda>
     142:	83 30       	cpi	r24, 0x03	; 3
     144:	09 f4       	brne	.+2      	; 0x148 <key_read+0x54>
     146:	43 c0       	rjmp	.+134    	; 0x1ce <key_read+0xda>
     148:	84 30       	cpi	r24, 0x04	; 4
     14a:	09 f4       	brne	.+2      	; 0x14e <key_read+0x5a>
     14c:	40 c0       	rjmp	.+128    	; 0x1ce <key_read+0xda>
     14e:	8f e2       	ldi	r24, 0x2F	; 47
     150:	08 95       	ret
{
case 1: if(col==1){return'*';}
     152:	21 30       	cpi	r18, 0x01	; 1
     154:	e9 f1       	breq	.+122    	; 0x1d0 <key_read+0xdc>
        if(col==2){return'0';}
     156:	22 30       	cpi	r18, 0x02	; 2
     158:	11 f4       	brne	.+4      	; 0x15e <key_read+0x6a>
     15a:	80 e3       	ldi	r24, 0x30	; 48
     15c:	08 95       	ret
        if(col==3){return'#';}
     15e:	23 30       	cpi	r18, 0x03	; 3
     160:	11 f4       	brne	.+4      	; 0x166 <key_read+0x72>
     162:	83 e2       	ldi	r24, 0x23	; 35
     164:	08 95       	ret
	    if(col==0){return'D';}
     166:	22 23       	and	r18, r18
     168:	91 f5       	brne	.+100    	; 0x1ce <key_read+0xda>
     16a:	84 e4       	ldi	r24, 0x44	; 68
     16c:	08 95       	ret
	    break;

case 2: if(col==1){return'7';}
     16e:	21 30       	cpi	r18, 0x01	; 1
     170:	11 f4       	brne	.+4      	; 0x176 <key_read+0x82>
     172:	87 e3       	ldi	r24, 0x37	; 55
     174:	08 95       	ret
        if(col==2){return'8';}
     176:	22 30       	cpi	r18, 0x02	; 2
     178:	11 f4       	brne	.+4      	; 0x17e <key_read+0x8a>
     17a:	88 e3       	ldi	r24, 0x38	; 56
     17c:	08 95       	ret
	    if(col==3){return'9';}
     17e:	23 30       	cpi	r18, 0x03	; 3
     180:	11 f4       	brne	.+4      	; 0x186 <key_read+0x92>
     182:	89 e3       	ldi	r24, 0x39	; 57
     184:	08 95       	ret
	    if(col==0){return'C';}
     186:	22 23       	and	r18, r18
     188:	11 f5       	brne	.+68     	; 0x1ce <key_read+0xda>
     18a:	83 e4       	ldi	r24, 0x43	; 67
     18c:	08 95       	ret
	    break;

case 3: if(col==1){return'4';}
     18e:	21 30       	cpi	r18, 0x01	; 1
     190:	11 f4       	brne	.+4      	; 0x196 <key_read+0xa2>
     192:	84 e3       	ldi	r24, 0x34	; 52
     194:	08 95       	ret
        if(col==2){return'5';}
     196:	22 30       	cpi	r18, 0x02	; 2
     198:	11 f4       	brne	.+4      	; 0x19e <key_read+0xaa>
     19a:	85 e3       	ldi	r24, 0x35	; 53
     19c:	08 95       	ret
	    if(col==3){return'6';}
     19e:	23 30       	cpi	r18, 0x03	; 3
     1a0:	11 f4       	brne	.+4      	; 0x1a6 <key_read+0xb2>
     1a2:	86 e3       	ldi	r24, 0x36	; 54
     1a4:	08 95       	ret
	    if(col==0){return'B';}
     1a6:	22 23       	and	r18, r18
     1a8:	91 f4       	brne	.+36     	; 0x1ce <key_read+0xda>
     1aa:	82 e4       	ldi	r24, 0x42	; 66
     1ac:	08 95       	ret
	    break;

case 4: if(col==1){return'1';}
     1ae:	21 30       	cpi	r18, 0x01	; 1
     1b0:	11 f4       	brne	.+4      	; 0x1b6 <key_read+0xc2>
     1b2:	81 e3       	ldi	r24, 0x31	; 49
     1b4:	08 95       	ret
        if(col==2){return'2';}
     1b6:	22 30       	cpi	r18, 0x02	; 2
     1b8:	11 f4       	brne	.+4      	; 0x1be <key_read+0xca>
     1ba:	82 e3       	ldi	r24, 0x32	; 50
     1bc:	08 95       	ret
	    if(col==3){return'3';}
     1be:	23 30       	cpi	r18, 0x03	; 3
     1c0:	11 f4       	brne	.+4      	; 0x1c6 <key_read+0xd2>
     1c2:	83 e3       	ldi	r24, 0x33	; 51
     1c4:	08 95       	ret
	    if(col==0){return'A';}
     1c6:	22 23       	and	r18, r18
     1c8:	11 f4       	brne	.+4      	; 0x1ce <key_read+0xda>
     1ca:	81 e4       	ldi	r24, 0x41	; 65
     1cc:	08 95       	ret
     1ce:	08 95       	ret

default: return '/';
         break;

}
}
     1d0:	8a e2       	ldi	r24, 0x2A	; 42
     1d2:	08 95       	ret

000001d4 <write_rf_setting>:
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
     1d4:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
     1d6:	b6 99       	sbic	0x16, 6	; 22
     1d8:	fe cf       	rjmp	.-4      	; 0x1d6 <write_rf_setting+0x2>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     1da:	8b e0       	ldi	r24, 0x0B	; 11
     1dc:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     1de:	77 9b       	sbis	0x0e, 7	; 14
     1e0:	fe cf       	rjmp	.-4      	; 0x1de <write_rf_setting+0xa>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     1e2:	86 e0       	ldi	r24, 0x06	; 6
     1e4:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     1e6:	77 9b       	sbis	0x0e, 7	; 14
     1e8:	fe cf       	rjmp	.-4      	; 0x1e6 <write_rf_setting+0x12>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
     1ea:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
     1ec:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
     1ee:	b6 99       	sbic	0x16, 6	; 22
     1f0:	fe cf       	rjmp	.-4      	; 0x1ee <write_rf_setting+0x1a>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     1f2:	8c e0       	ldi	r24, 0x0C	; 12
     1f4:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     1f6:	77 9b       	sbis	0x0e, 7	; 14
     1f8:	fe cf       	rjmp	.-4      	; 0x1f6 <write_rf_setting+0x22>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     1fa:	1f b8       	out	0x0f, r1	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     1fc:	77 9b       	sbis	0x0e, 7	; 14
     1fe:	fe cf       	rjmp	.-4      	; 0x1fc <write_rf_setting+0x28>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
     200:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
     202:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
     204:	b6 99       	sbic	0x16, 6	; 22
     206:	fe cf       	rjmp	.-4      	; 0x204 <write_rf_setting+0x30>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     208:	8d e0       	ldi	r24, 0x0D	; 13
     20a:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     20c:	77 9b       	sbis	0x0e, 7	; 14
     20e:	fe cf       	rjmp	.-4      	; 0x20c <write_rf_setting+0x38>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     210:	8d e5       	ldi	r24, 0x5D	; 93
     212:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     214:	77 9b       	sbis	0x0e, 7	; 14
     216:	fe cf       	rjmp	.-4      	; 0x214 <write_rf_setting+0x40>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
     218:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
     21a:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
     21c:	b6 99       	sbic	0x16, 6	; 22
     21e:	fe cf       	rjmp	.-4      	; 0x21c <write_rf_setting+0x48>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     220:	8e e0       	ldi	r24, 0x0E	; 14
     222:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     224:	77 9b       	sbis	0x0e, 7	; 14
     226:	fe cf       	rjmp	.-4      	; 0x224 <write_rf_setting+0x50>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     228:	83 e9       	ldi	r24, 0x93	; 147
     22a:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     22c:	77 9b       	sbis	0x0e, 7	; 14
     22e:	fe cf       	rjmp	.-4      	; 0x22c <write_rf_setting+0x58>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
     230:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
     232:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
     234:	b6 99       	sbic	0x16, 6	; 22
     236:	fe cf       	rjmp	.-4      	; 0x234 <write_rf_setting+0x60>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     238:	8f e0       	ldi	r24, 0x0F	; 15
     23a:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     23c:	77 9b       	sbis	0x0e, 7	; 14
     23e:	fe cf       	rjmp	.-4      	; 0x23c <write_rf_setting+0x68>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     240:	81 eb       	ldi	r24, 0xB1	; 177
     242:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     244:	77 9b       	sbis	0x0e, 7	; 14
     246:	fe cf       	rjmp	.-4      	; 0x244 <write_rf_setting+0x70>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
     248:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
     24a:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
     24c:	b6 99       	sbic	0x16, 6	; 22
     24e:	fe cf       	rjmp	.-4      	; 0x24c <write_rf_setting+0x78>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     250:	80 e1       	ldi	r24, 0x10	; 16
     252:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     254:	77 9b       	sbis	0x0e, 7	; 14
     256:	fe cf       	rjmp	.-4      	; 0x254 <write_rf_setting+0x80>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     258:	8d e2       	ldi	r24, 0x2D	; 45
     25a:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     25c:	77 9b       	sbis	0x0e, 7	; 14
     25e:	fe cf       	rjmp	.-4      	; 0x25c <write_rf_setting+0x88>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
     260:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
     262:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
     264:	b6 99       	sbic	0x16, 6	; 22
     266:	fe cf       	rjmp	.-4      	; 0x264 <write_rf_setting+0x90>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     268:	81 e1       	ldi	r24, 0x11	; 17
     26a:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     26c:	77 9b       	sbis	0x0e, 7	; 14
     26e:	fe cf       	rjmp	.-4      	; 0x26c <write_rf_setting+0x98>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     270:	8b e3       	ldi	r24, 0x3B	; 59
     272:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     274:	77 9b       	sbis	0x0e, 7	; 14
     276:	fe cf       	rjmp	.-4      	; 0x274 <write_rf_setting+0xa0>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
     278:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
     27a:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
     27c:	b6 99       	sbic	0x16, 6	; 22
     27e:	fe cf       	rjmp	.-4      	; 0x27c <write_rf_setting+0xa8>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     280:	82 e1       	ldi	r24, 0x12	; 18
     282:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     284:	77 9b       	sbis	0x0e, 7	; 14
     286:	fe cf       	rjmp	.-4      	; 0x284 <write_rf_setting+0xb0>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     288:	83 e7       	ldi	r24, 0x73	; 115
     28a:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     28c:	77 9b       	sbis	0x0e, 7	; 14
     28e:	fe cf       	rjmp	.-4      	; 0x28c <write_rf_setting+0xb8>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
     290:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
     292:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
     294:	b6 99       	sbic	0x16, 6	; 22
     296:	fe cf       	rjmp	.-4      	; 0x294 <write_rf_setting+0xc0>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     298:	83 e1       	ldi	r24, 0x13	; 19
     29a:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     29c:	77 9b       	sbis	0x0e, 7	; 14
     29e:	fe cf       	rjmp	.-4      	; 0x29c <write_rf_setting+0xc8>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     2a0:	82 e2       	ldi	r24, 0x22	; 34
     2a2:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     2a4:	77 9b       	sbis	0x0e, 7	; 14
     2a6:	fe cf       	rjmp	.-4      	; 0x2a4 <write_rf_setting+0xd0>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
     2a8:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
     2aa:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
     2ac:	b6 99       	sbic	0x16, 6	; 22
     2ae:	fe cf       	rjmp	.-4      	; 0x2ac <write_rf_setting+0xd8>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     2b0:	84 e1       	ldi	r24, 0x14	; 20
     2b2:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     2b4:	77 9b       	sbis	0x0e, 7	; 14
     2b6:	fe cf       	rjmp	.-4      	; 0x2b4 <write_rf_setting+0xe0>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     2b8:	88 ef       	ldi	r24, 0xF8	; 248
     2ba:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     2bc:	77 9b       	sbis	0x0e, 7	; 14
     2be:	fe cf       	rjmp	.-4      	; 0x2bc <write_rf_setting+0xe8>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
     2c0:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
     2c2:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
     2c4:	b6 99       	sbic	0x16, 6	; 22
     2c6:	fe cf       	rjmp	.-4      	; 0x2c4 <write_rf_setting+0xf0>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     2c8:	8a e0       	ldi	r24, 0x0A	; 10
     2ca:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     2cc:	77 9b       	sbis	0x0e, 7	; 14
     2ce:	fe cf       	rjmp	.-4      	; 0x2cc <write_rf_setting+0xf8>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     2d0:	83 e0       	ldi	r24, 0x03	; 3
     2d2:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     2d4:	77 9b       	sbis	0x0e, 7	; 14
     2d6:	fe cf       	rjmp	.-4      	; 0x2d4 <write_rf_setting+0x100>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
     2d8:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
     2da:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
     2dc:	b6 99       	sbic	0x16, 6	; 22
     2de:	fe cf       	rjmp	.-4      	; 0x2dc <write_rf_setting+0x108>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     2e0:	85 e1       	ldi	r24, 0x15	; 21
     2e2:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     2e4:	77 9b       	sbis	0x0e, 7	; 14
     2e6:	fe cf       	rjmp	.-4      	; 0x2e4 <write_rf_setting+0x110>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     2e8:	1f b8       	out	0x0f, r1	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     2ea:	77 9b       	sbis	0x0e, 7	; 14
     2ec:	fe cf       	rjmp	.-4      	; 0x2ea <write_rf_setting+0x116>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
     2ee:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
     2f0:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
     2f2:	b6 99       	sbic	0x16, 6	; 22
     2f4:	fe cf       	rjmp	.-4      	; 0x2f2 <write_rf_setting+0x11e>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     2f6:	81 e2       	ldi	r24, 0x21	; 33
     2f8:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     2fa:	77 9b       	sbis	0x0e, 7	; 14
     2fc:	fe cf       	rjmp	.-4      	; 0x2fa <write_rf_setting+0x126>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     2fe:	86 eb       	ldi	r24, 0xB6	; 182
     300:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     302:	77 9b       	sbis	0x0e, 7	; 14
     304:	fe cf       	rjmp	.-4      	; 0x302 <write_rf_setting+0x12e>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
     306:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
     308:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
     30a:	b6 99       	sbic	0x16, 6	; 22
     30c:	fe cf       	rjmp	.-4      	; 0x30a <write_rf_setting+0x136>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     30e:	82 e2       	ldi	r24, 0x22	; 34
     310:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     312:	77 9b       	sbis	0x0e, 7	; 14
     314:	fe cf       	rjmp	.-4      	; 0x312 <write_rf_setting+0x13e>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     316:	80 e1       	ldi	r24, 0x10	; 16
     318:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     31a:	77 9b       	sbis	0x0e, 7	; 14
     31c:	fe cf       	rjmp	.-4      	; 0x31a <write_rf_setting+0x146>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
     31e:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
     320:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
     322:	b6 99       	sbic	0x16, 6	; 22
     324:	fe cf       	rjmp	.-4      	; 0x322 <write_rf_setting+0x14e>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     326:	88 e1       	ldi	r24, 0x18	; 24
     328:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     32a:	77 9b       	sbis	0x0e, 7	; 14
     32c:	fe cf       	rjmp	.-4      	; 0x32a <write_rf_setting+0x156>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     32e:	88 e1       	ldi	r24, 0x18	; 24
     330:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     332:	77 9b       	sbis	0x0e, 7	; 14
     334:	fe cf       	rjmp	.-4      	; 0x332 <write_rf_setting+0x15e>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
     336:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
     338:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
     33a:	b6 99       	sbic	0x16, 6	; 22
     33c:	fe cf       	rjmp	.-4      	; 0x33a <write_rf_setting+0x166>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     33e:	89 e1       	ldi	r24, 0x19	; 25
     340:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     342:	77 9b       	sbis	0x0e, 7	; 14
     344:	fe cf       	rjmp	.-4      	; 0x342 <write_rf_setting+0x16e>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     346:	8d e1       	ldi	r24, 0x1D	; 29
     348:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     34a:	77 9b       	sbis	0x0e, 7	; 14
     34c:	fe cf       	rjmp	.-4      	; 0x34a <write_rf_setting+0x176>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
     34e:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
     350:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
     352:	b6 99       	sbic	0x16, 6	; 22
     354:	fe cf       	rjmp	.-4      	; 0x352 <write_rf_setting+0x17e>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     356:	8a e1       	ldi	r24, 0x1A	; 26
     358:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     35a:	77 9b       	sbis	0x0e, 7	; 14
     35c:	fe cf       	rjmp	.-4      	; 0x35a <write_rf_setting+0x186>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     35e:	8c e1       	ldi	r24, 0x1C	; 28
     360:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     362:	77 9b       	sbis	0x0e, 7	; 14
     364:	fe cf       	rjmp	.-4      	; 0x362 <write_rf_setting+0x18e>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
     366:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
     368:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
     36a:	b6 99       	sbic	0x16, 6	; 22
     36c:	fe cf       	rjmp	.-4      	; 0x36a <write_rf_setting+0x196>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     36e:	8b e1       	ldi	r24, 0x1B	; 27
     370:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     372:	77 9b       	sbis	0x0e, 7	; 14
     374:	fe cf       	rjmp	.-4      	; 0x372 <write_rf_setting+0x19e>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     376:	87 ec       	ldi	r24, 0xC7	; 199
     378:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     37a:	77 9b       	sbis	0x0e, 7	; 14
     37c:	fe cf       	rjmp	.-4      	; 0x37a <write_rf_setting+0x1a6>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
     37e:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
     380:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
     382:	b6 99       	sbic	0x16, 6	; 22
     384:	fe cf       	rjmp	.-4      	; 0x382 <write_rf_setting+0x1ae>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     386:	8c e1       	ldi	r24, 0x1C	; 28
     388:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     38a:	77 9b       	sbis	0x0e, 7	; 14
     38c:	fe cf       	rjmp	.-4      	; 0x38a <write_rf_setting+0x1b6>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     38e:	1f b8       	out	0x0f, r1	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     390:	77 9b       	sbis	0x0e, 7	; 14
     392:	fe cf       	rjmp	.-4      	; 0x390 <write_rf_setting+0x1bc>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
     394:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
     396:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
     398:	b6 99       	sbic	0x16, 6	; 22
     39a:	fe cf       	rjmp	.-4      	; 0x398 <write_rf_setting+0x1c4>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     39c:	8d e1       	ldi	r24, 0x1D	; 29
     39e:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     3a0:	77 9b       	sbis	0x0e, 7	; 14
     3a2:	fe cf       	rjmp	.-4      	; 0x3a0 <write_rf_setting+0x1cc>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     3a4:	82 eb       	ldi	r24, 0xB2	; 178
     3a6:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     3a8:	77 9b       	sbis	0x0e, 7	; 14
     3aa:	fe cf       	rjmp	.-4      	; 0x3a8 <write_rf_setting+0x1d4>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
     3ac:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
     3ae:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
     3b0:	b6 99       	sbic	0x16, 6	; 22
     3b2:	fe cf       	rjmp	.-4      	; 0x3b0 <write_rf_setting+0x1dc>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     3b4:	83 e2       	ldi	r24, 0x23	; 35
     3b6:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     3b8:	77 9b       	sbis	0x0e, 7	; 14
     3ba:	fe cf       	rjmp	.-4      	; 0x3b8 <write_rf_setting+0x1e4>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     3bc:	8a ee       	ldi	r24, 0xEA	; 234
     3be:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     3c0:	77 9b       	sbis	0x0e, 7	; 14
     3c2:	fe cf       	rjmp	.-4      	; 0x3c0 <write_rf_setting+0x1ec>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
     3c4:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
     3c6:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
     3c8:	b6 99       	sbic	0x16, 6	; 22
     3ca:	fe cf       	rjmp	.-4      	; 0x3c8 <write_rf_setting+0x1f4>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     3cc:	84 e2       	ldi	r24, 0x24	; 36
     3ce:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     3d0:	77 9b       	sbis	0x0e, 7	; 14
     3d2:	fe cf       	rjmp	.-4      	; 0x3d0 <write_rf_setting+0x1fc>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     3d4:	8a e0       	ldi	r24, 0x0A	; 10
     3d6:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     3d8:	77 9b       	sbis	0x0e, 7	; 14
     3da:	fe cf       	rjmp	.-4      	; 0x3d8 <write_rf_setting+0x204>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
     3dc:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
     3de:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
     3e0:	b6 99       	sbic	0x16, 6	; 22
     3e2:	fe cf       	rjmp	.-4      	; 0x3e0 <write_rf_setting+0x20c>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     3e4:	85 e2       	ldi	r24, 0x25	; 37
     3e6:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     3e8:	77 9b       	sbis	0x0e, 7	; 14
     3ea:	fe cf       	rjmp	.-4      	; 0x3e8 <write_rf_setting+0x214>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     3ec:	1f b8       	out	0x0f, r1	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     3ee:	77 9b       	sbis	0x0e, 7	; 14
     3f0:	fe cf       	rjmp	.-4      	; 0x3ee <write_rf_setting+0x21a>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
     3f2:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
     3f4:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
     3f6:	b6 99       	sbic	0x16, 6	; 22
     3f8:	fe cf       	rjmp	.-4      	; 0x3f6 <write_rf_setting+0x222>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     3fa:	86 e2       	ldi	r24, 0x26	; 38
     3fc:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     3fe:	77 9b       	sbis	0x0e, 7	; 14
     400:	fe cf       	rjmp	.-4      	; 0x3fe <write_rf_setting+0x22a>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     402:	81 e1       	ldi	r24, 0x11	; 17
     404:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     406:	77 9b       	sbis	0x0e, 7	; 14
     408:	fe cf       	rjmp	.-4      	; 0x406 <write_rf_setting+0x232>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
     40a:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
     40c:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
     40e:	b6 99       	sbic	0x16, 6	; 22
     410:	fe cf       	rjmp	.-4      	; 0x40e <write_rf_setting+0x23a>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     412:	89 e2       	ldi	r24, 0x29	; 41
     414:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     416:	77 9b       	sbis	0x0e, 7	; 14
     418:	fe cf       	rjmp	.-4      	; 0x416 <write_rf_setting+0x242>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     41a:	89 e5       	ldi	r24, 0x59	; 89
     41c:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     41e:	77 9b       	sbis	0x0e, 7	; 14
     420:	fe cf       	rjmp	.-4      	; 0x41e <write_rf_setting+0x24a>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
     422:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
     424:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
     426:	b6 99       	sbic	0x16, 6	; 22
     428:	fe cf       	rjmp	.-4      	; 0x426 <write_rf_setting+0x252>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     42a:	8c e2       	ldi	r24, 0x2C	; 44
     42c:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     42e:	77 9b       	sbis	0x0e, 7	; 14
     430:	fe cf       	rjmp	.-4      	; 0x42e <write_rf_setting+0x25a>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     432:	88 e8       	ldi	r24, 0x88	; 136
     434:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     436:	77 9b       	sbis	0x0e, 7	; 14
     438:	fe cf       	rjmp	.-4      	; 0x436 <write_rf_setting+0x262>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
     43a:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
     43c:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
     43e:	b6 99       	sbic	0x16, 6	; 22
     440:	fe cf       	rjmp	.-4      	; 0x43e <write_rf_setting+0x26a>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     442:	8d e2       	ldi	r24, 0x2D	; 45
     444:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     446:	77 9b       	sbis	0x0e, 7	; 14
     448:	fe cf       	rjmp	.-4      	; 0x446 <write_rf_setting+0x272>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     44a:	81 e3       	ldi	r24, 0x31	; 49
     44c:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     44e:	77 9b       	sbis	0x0e, 7	; 14
     450:	fe cf       	rjmp	.-4      	; 0x44e <write_rf_setting+0x27a>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
     452:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
     454:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
     456:	b6 99       	sbic	0x16, 6	; 22
     458:	fe cf       	rjmp	.-4      	; 0x456 <write_rf_setting+0x282>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     45a:	8e e2       	ldi	r24, 0x2E	; 46
     45c:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     45e:	77 9b       	sbis	0x0e, 7	; 14
     460:	fe cf       	rjmp	.-4      	; 0x45e <write_rf_setting+0x28a>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     462:	8b e0       	ldi	r24, 0x0B	; 11
     464:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     466:	77 9b       	sbis	0x0e, 7	; 14
     468:	fe cf       	rjmp	.-4      	; 0x466 <write_rf_setting+0x292>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
     46a:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
     46c:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
     46e:	b6 99       	sbic	0x16, 6	; 22
     470:	fe cf       	rjmp	.-4      	; 0x46e <write_rf_setting+0x29a>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     472:	83 e0       	ldi	r24, 0x03	; 3
     474:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     476:	77 9b       	sbis	0x0e, 7	; 14
     478:	fe cf       	rjmp	.-4      	; 0x476 <write_rf_setting+0x2a2>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     47a:	87 e0       	ldi	r24, 0x07	; 7
     47c:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     47e:	77 9b       	sbis	0x0e, 7	; 14
     480:	fe cf       	rjmp	.-4      	; 0x47e <write_rf_setting+0x2aa>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
     482:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
     484:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
     486:	b6 99       	sbic	0x16, 6	; 22
     488:	fe cf       	rjmp	.-4      	; 0x486 <write_rf_setting+0x2b2>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     48a:	1f b8       	out	0x0f, r1	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     48c:	77 9b       	sbis	0x0e, 7	; 14
     48e:	fe cf       	rjmp	.-4      	; 0x48c <write_rf_setting+0x2b8>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     490:	86 e0       	ldi	r24, 0x06	; 6
     492:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     494:	77 9b       	sbis	0x0e, 7	; 14
     496:	fe cf       	rjmp	.-4      	; 0x494 <write_rf_setting+0x2c0>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
     498:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
     49a:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
     49c:	b6 99       	sbic	0x16, 6	; 22
     49e:	fe cf       	rjmp	.-4      	; 0x49c <write_rf_setting+0x2c8>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     4a0:	82 e0       	ldi	r24, 0x02	; 2
     4a2:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     4a4:	77 9b       	sbis	0x0e, 7	; 14
     4a6:	fe cf       	rjmp	.-4      	; 0x4a4 <write_rf_setting+0x2d0>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     4a8:	81 e0       	ldi	r24, 0x01	; 1
     4aa:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     4ac:	77 9b       	sbis	0x0e, 7	; 14
     4ae:	fe cf       	rjmp	.-4      	; 0x4ac <write_rf_setting+0x2d8>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
     4b0:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
     4b2:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
     4b4:	b6 99       	sbic	0x16, 6	; 22
     4b6:	fe cf       	rjmp	.-4      	; 0x4b4 <write_rf_setting+0x2e0>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     4b8:	87 e0       	ldi	r24, 0x07	; 7
     4ba:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     4bc:	77 9b       	sbis	0x0e, 7	; 14
     4be:	fe cf       	rjmp	.-4      	; 0x4bc <write_rf_setting+0x2e8>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     4c0:	84 e0       	ldi	r24, 0x04	; 4
     4c2:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     4c4:	77 9b       	sbis	0x0e, 7	; 14
     4c6:	fe cf       	rjmp	.-4      	; 0x4c4 <write_rf_setting+0x2f0>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
     4c8:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
     4ca:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
     4cc:	b6 99       	sbic	0x16, 6	; 22
     4ce:	fe cf       	rjmp	.-4      	; 0x4cc <write_rf_setting+0x2f8>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     4d0:	88 e0       	ldi	r24, 0x08	; 8
     4d2:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     4d4:	77 9b       	sbis	0x0e, 7	; 14
     4d6:	fe cf       	rjmp	.-4      	; 0x4d4 <write_rf_setting+0x300>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     4d8:	85 e0       	ldi	r24, 0x05	; 5
     4da:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     4dc:	77 9b       	sbis	0x0e, 7	; 14
     4de:	fe cf       	rjmp	.-4      	; 0x4dc <write_rf_setting+0x308>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
     4e0:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
     4e2:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
     4e4:	b6 99       	sbic	0x16, 6	; 22
     4e6:	fe cf       	rjmp	.-4      	; 0x4e4 <write_rf_setting+0x310>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     4e8:	89 e0       	ldi	r24, 0x09	; 9
     4ea:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     4ec:	77 9b       	sbis	0x0e, 7	; 14
     4ee:	fe cf       	rjmp	.-4      	; 0x4ec <write_rf_setting+0x318>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     4f0:	1f b8       	out	0x0f, r1	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     4f2:	77 9b       	sbis	0x0e, 7	; 14
     4f4:	fe cf       	rjmp	.-4      	; 0x4f2 <write_rf_setting+0x31e>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
     4f6:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
     4f8:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
     4fa:	b6 99       	sbic	0x16, 6	; 22
     4fc:	fe cf       	rjmp	.-4      	; 0x4fa <write_rf_setting+0x326>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     4fe:	86 e0       	ldi	r24, 0x06	; 6
     500:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     502:	77 9b       	sbis	0x0e, 7	; 14
     504:	fe cf       	rjmp	.-4      	; 0x502 <write_rf_setting+0x32e>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     506:	8f ef       	ldi	r24, 0xFF	; 255
     508:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     50a:	77 9b       	sbis	0x0e, 7	; 14
     50c:	fe cf       	rjmp	.-4      	; 0x50a <write_rf_setting+0x336>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
     50e:	c3 9a       	sbi	0x18, 3	; 24
	 halRfWriteReg(PKTCTRL0   ,0x05);
	 halRfWriteReg(ADDR       ,0x00);
	 halRfWriteReg(PKTLEN     ,0xFF);


}
     510:	08 95       	ret

00000512 <set_channel>:


void set_channel(uint8_t ch)   //transmitter/receiver channel number
{
     512:	98 2f       	mov	r25, r24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
     514:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
     516:	b6 99       	sbic	0x16, 6	; 22
     518:	fe cf       	rjmp	.-4      	; 0x516 <set_channel+0x4>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     51a:	8a e0       	ldi	r24, 0x0A	; 10
     51c:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     51e:	77 9b       	sbis	0x0e, 7	; 14
     520:	fe cf       	rjmp	.-4      	; 0x51e <set_channel+0xc>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     522:	9f b9       	out	0x0f, r25	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     524:	77 9b       	sbis	0x0e, 7	; 14
     526:	fe cf       	rjmp	.-4      	; 0x524 <set_channel+0x12>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
     528:	c3 9a       	sbi	0x18, 3	; 24


void set_channel(uint8_t ch)   //transmitter/receiver channel number
{
halRfWriteReg(CHANNR     , ch);
}
     52a:	08 95       	ret

0000052c <set_address>:


void set_address(uint8_t add)   //transmitter/receiver address
{
     52c:	98 2f       	mov	r25, r24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
     52e:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
     530:	b6 99       	sbic	0x16, 6	; 22
     532:	fe cf       	rjmp	.-4      	; 0x530 <set_address+0x4>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     534:	89 e0       	ldi	r24, 0x09	; 9
     536:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     538:	77 9b       	sbis	0x0e, 7	; 14
     53a:	fe cf       	rjmp	.-4      	; 0x538 <set_address+0xc>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     53c:	9f b9       	out	0x0f, r25	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     53e:	77 9b       	sbis	0x0e, 7	; 14
     540:	fe cf       	rjmp	.-4      	; 0x53e <set_address+0x12>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
     542:	c3 9a       	sbi	0x18, 3	; 24


void set_address(uint8_t add)   //transmitter/receiver address
{
halRfWriteReg(ADDR     , add);
}
     544:	08 95       	ret

00000546 <initTimer0>:
		
}

void initTimer0(){
	/* clkI/O/64 (From prescaler) */
	TCCR0 = (0<<CS02)|(1<<CS01)|(1<<CS00);
     546:	83 e0       	ldi	r24, 0x03	; 3
     548:	83 bf       	out	0x33, r24	; 51
	TIMSK = 0;
     54a:	19 be       	out	0x39, r1	; 57
}
     54c:	08 95       	ret

0000054e <SPI_MasterInit>:


void SPI_MasterInit(void)
{
	/* Set MOSI and SCK output, all others input */
	sbi(SPI_DDR, DD_CS);	//cs
     54e:	bb 9a       	sbi	0x17, 3	; 23
	sbi(SPI_DDR, DD_SS);	//ss
     550:	bc 9a       	sbi	0x17, 4	; 23
	sbi(SPI_DDR, DD_MOSI);	//mosi
     552:	bd 9a       	sbi	0x17, 5	; 23
	cbi(SPI_DDR, DD_MISO);	//miso
     554:	be 98       	cbi	0x17, 6	; 23
	sbi(SPI_DDR, DD_SCK);	//sck
     556:	bf 9a       	sbi	0x17, 7	; 23
	
	/*	Enable SPI, Master, set clock rate 
		10 is fck/64	*/
	SPCR = (1<<SPE)|(1<<MSTR)|(0<<SPR1)|(0<<SPR0);	
     558:	80 e5       	ldi	r24, 0x50	; 80
     55a:	8d b9       	out	0x0d, r24	; 13
	SPSR |= (0<<SPI2X);
     55c:	8e b1       	in	r24, 0x0e	; 14
     55e:	8e b9       	out	0x0e, r24	; 14

}
     560:	08 95       	ret

00000562 <SPI_MasterTransmit>:
void SPI_MasterTransmit(char cData)
{
	cbi(SPI_PORT, DD_CS);
     562:	c3 98       	cbi	0x18, 3	; 24

	/* Start transmission */
	SPDR = cData;
     564:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     566:	77 9b       	sbis	0x0e, 7	; 14
     568:	fe cf       	rjmp	.-4      	; 0x566 <SPI_MasterTransmit+0x4>

	sbi(SPI_PORT, DD_CS);
     56a:	c3 9a       	sbi	0x18, 3	; 24
}
     56c:	08 95       	ret

0000056e <SPI_SlaveInit>:

void SPI_SlaveInit(void)
{
	/* Set MISO output, all others input */
	cbi(SPI_DDR, DD_SS);	//ss
     56e:	bc 98       	cbi	0x17, 4	; 23
	cbi(SPI_DDR, DD_MOSI);	//mosi
     570:	bd 98       	cbi	0x17, 5	; 23
	sbi(SPI_DDR, DD_MISO);	//miso
     572:	be 9a       	sbi	0x17, 6	; 23
	cbi(SPI_DDR, DD_SCK);	//sck
     574:	bf 98       	cbi	0x17, 7	; 23
	
	/* Enable SPI */
	SPCR = (1<<SPE);
     576:	80 e4       	ldi	r24, 0x40	; 64
     578:	8d b9       	out	0x0d, r24	; 13
}
     57a:	08 95       	ret

0000057c <SPI_SlaveReceive>:
char SPI_SlaveReceive(void)
{
	/* Wait for reception complete */
	while(!(SPSR & (1<<SPIF)))
     57c:	77 9b       	sbis	0x0e, 7	; 14
     57e:	fe cf       	rjmp	.-4      	; 0x57c <SPI_SlaveReceive>
	;
	/* Return data register */
	return SPDR;
     580:	8f b1       	in	r24, 0x0f	; 15
}
     582:	08 95       	ret

00000584 <SPI_write>:


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     584:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     586:	77 9b       	sbis	0x0e, 7	; 14
     588:	fe cf       	rjmp	.-4      	; 0x586 <SPI_write+0x2>
}
     58a:	08 95       	ret

0000058c <SPI_transfer_byte>:

BYTE SPI_transfer_byte(BYTE addr)
{
	SPDR = addr;
     58c:	8f b9       	out	0x0f, r24	; 15

	/* Wait for reception complete */
	while(!(SPSR & (1<<SPIF)));
     58e:	77 9b       	sbis	0x0e, 7	; 14
     590:	fe cf       	rjmp	.-4      	; 0x58e <SPI_transfer_byte+0x2>
	
	/* Return data register */
	return SPDR;
     592:	8f b1       	in	r24, 0x0f	; 15
}
     594:	08 95       	ret

00000596 <SPI_read>:
//
//=======================================================================
BYTE SPI_read()
{
	//Wait for reception complete 
	while(!(SPSR & (1<<SPIF)));
     596:	77 9b       	sbis	0x0e, 7	; 14
     598:	fe cf       	rjmp	.-4      	; 0x596 <SPI_read>
	
	// Return data register 
	return SPDR;
     59a:	8f b1       	in	r24, 0x0f	; 15
}
     59c:	08 95       	ret

0000059e <read_reg>:
//          Value of the accessed CC2500 register.
//-------------------------------------------------------------------------------------------------------
BYTE read_reg(BYTE addr) 
{
	unsigned char value;
	cbi(SPI_PORT, P_CSn);
     59e:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
     5a0:	b6 99       	sbic	0x16, 6	; 22
     5a2:	fe cf       	rjmp	.-4      	; 0x5a0 <read_reg+0x2>
//	cbi(SPI_PORT, P_SCLK);
	addr|=READ_SINGLE;
     5a4:	80 68       	ori	r24, 0x80	; 128


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     5a6:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     5a8:	77 9b       	sbis	0x0e, 7	; 14
     5aa:	fe cf       	rjmp	.-4      	; 0x5a8 <read_reg+0xa>
}

BYTE SPI_transfer_byte(BYTE addr)
{
	SPDR = addr;
     5ac:	8f b9       	out	0x0f, r24	; 15

	/* Wait for reception complete */
	while(!(SPSR & (1<<SPIF)));
     5ae:	77 9b       	sbis	0x0e, 7	; 14
     5b0:	fe cf       	rjmp	.-4      	; 0x5ae <read_reg+0x10>
	
	/* Return data register */
	return SPDR;
     5b2:	8f b1       	in	r24, 0x0f	; 15
//	cbi(SPI_PORT, P_SCLK);
	addr|=READ_SINGLE;
	SPI_write(addr);
	
	value = SPI_transfer_byte(addr);
	sbi(SPI_PORT, P_CSn);
     5b4:	c3 9a       	sbi	0x18, 3	; 24
//	cbi(SPI_PORT, P_SCLK);
//	cbi(SPI_PORT, P_SI);
	return value;
}
     5b6:	08 95       	ret

000005b8 <read_status>:
//          Value of the accessed CC2500 status register.
//-------------------------------------------------------------------------------------------------------
BYTE read_status(BYTE addr) 
{
	unsigned char value;
	cbi(SPI_PORT, P_CSn);
     5b8:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
     5ba:	b6 99       	sbic	0x16, 6	; 22
     5bc:	fe cf       	rjmp	.-4      	; 0x5ba <read_status+0x2>
//	cbi(SPI_PORT, P_SCLK);
	addr|=READ_BURST;
     5be:	80 6c       	ori	r24, 0xC0	; 192


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     5c0:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     5c2:	77 9b       	sbis	0x0e, 7	; 14
     5c4:	fe cf       	rjmp	.-4      	; 0x5c2 <read_status+0xa>
}

BYTE SPI_transfer_byte(BYTE addr)
{
	SPDR = addr;
     5c6:	8f b9       	out	0x0f, r24	; 15

	/* Wait for reception complete */
	while(!(SPSR & (1<<SPIF)));
     5c8:	77 9b       	sbis	0x0e, 7	; 14
     5ca:	fe cf       	rjmp	.-4      	; 0x5c8 <read_status+0x10>
	
	/* Return data register */
	return SPDR;
     5cc:	8f b1       	in	r24, 0x0f	; 15
	addr|=READ_BURST;
	SPI_write(addr);

	value = SPI_transfer_byte(addr);

	sbi(SPI_PORT, P_CSn);
     5ce:	c3 9a       	sbi	0x18, 3	; 24
//	cbi(SPI_PORT, P_SCLK);
//	cbi(SPI_PORT, P_SI);
	return value;
}// read_status
     5d0:	08 95       	ret

000005d2 <halRfWriteReg>:
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
     5d2:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
     5d4:	b6 99       	sbic	0x16, 6	; 22
     5d6:	fe cf       	rjmp	.-4      	; 0x5d4 <halRfWriteReg+0x2>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
     5d8:	8f 77       	andi	r24, 0x7F	; 127


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     5da:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     5dc:	77 9b       	sbis	0x0e, 7	; 14
     5de:	fe cf       	rjmp	.-4      	; 0x5dc <halRfWriteReg+0xa>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     5e0:	6f b9       	out	0x0f, r22	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     5e2:	77 9b       	sbis	0x0e, 7	; 14
     5e4:	fe cf       	rjmp	.-4      	; 0x5e2 <halRfWriteReg+0x10>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
     5e6:	c3 9a       	sbi	0x18, 3	; 24

}// halRfWriteReg
     5e8:	08 95       	ret

000005ea <read_burst_reg>:
//          Number of bytes to be written to the subsequent CC2500 registers.
//-------------------------------------------------------------------------------------------------------
void read_burst_reg(BYTE addr, BYTE *buffer, BYTE count) 
{
	unsigned char j,value;
	cbi(SPI_PORT, P_CSn);
     5ea:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
     5ec:	b6 99       	sbic	0x16, 6	; 22
     5ee:	fe cf       	rjmp	.-4      	; 0x5ec <read_burst_reg+0x2>
 //	cbi(SPI_PORT, P_SCLK);
	addr|=READ_BURST;
     5f0:	58 2f       	mov	r21, r24
     5f2:	50 6c       	ori	r21, 0xC0	; 192


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     5f4:	5f b9       	out	0x0f, r21	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     5f6:	77 9b       	sbis	0x0e, 7	; 14
     5f8:	fe cf       	rjmp	.-4      	; 0x5f6 <read_burst_reg+0xc>
     5fa:	fb 01       	movw	r30, r22
     5fc:	90 e0       	ldi	r25, 0x00	; 0
     5fe:	06 c0       	rjmp	.+12     	; 0x60c <read_burst_reg+0x22>
}

BYTE SPI_transfer_byte(BYTE addr)
{
	SPDR = addr;
     600:	5f b9       	out	0x0f, r21	; 15

	/* Wait for reception complete */
	while(!(SPSR & (1<<SPIF)));
     602:	77 9b       	sbis	0x0e, 7	; 14
     604:	fe cf       	rjmp	.-4      	; 0x602 <read_burst_reg+0x18>
	
	/* Return data register */
	return SPDR;
     606:	8f b1       	in	r24, 0x0f	; 15
	addr|=READ_BURST;
	SPI_write(addr);
	for(j=0;j<count;j++) 
	{
	  value = SPI_transfer_byte(addr);
	  buffer[j]=value;
     608:	81 93       	st	Z+, r24
	cbi(SPI_PORT, P_CSn);
	while(bit_is_set(PINB, P_SO));
 //	cbi(SPI_PORT, P_SCLK);
	addr|=READ_BURST;
	SPI_write(addr);
	for(j=0;j<count;j++) 
     60a:	9f 5f       	subi	r25, 0xFF	; 255
     60c:	94 17       	cp	r25, r20
     60e:	c0 f3       	brcs	.-16     	; 0x600 <read_burst_reg+0x16>
	{
	  value = SPI_transfer_byte(addr);
	  buffer[j]=value;
	}
	sbi(SPI_PORT, P_CSn);
     610:	c3 9a       	sbi	0x18, 3	; 24
}// read_burst_reg
     612:	08 95       	ret

00000614 <write_burst_reg>:
//          Number of bytes to be written to the subsequent CC2500 registers.   
//-------------------------------------------------------------------------------------------------------
void write_burst_reg(BYTE addr, BYTE *buffer, BYTE count)
{
	unsigned char i,j,value;
	cbi(SPI_PORT, P_CSn);
     614:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
     616:	b6 99       	sbic	0x16, 6	; 22
     618:	fe cf       	rjmp	.-4      	; 0x616 <write_burst_reg+0x2>
	addr|=WRITE_BURST;
     61a:	80 64       	ori	r24, 0x40	; 64


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     61c:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     61e:	77 9b       	sbis	0x0e, 7	; 14
     620:	fe cf       	rjmp	.-4      	; 0x61e <write_burst_reg+0xa>
     622:	fb 01       	movw	r30, r22
     624:	90 e0       	ldi	r25, 0x00	; 0
     626:	06 c0       	rjmp	.+12     	; 0x634 <write_burst_reg+0x20>
	cbi(SPI_PORT, P_CSn);
	while(bit_is_set(PINB, P_SO));
	addr|=WRITE_BURST;
	SPI_write(addr);
	for(j=0;j<count;j++) {
	  value=buffer[j];
     628:	80 81       	ld	r24, Z


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     62a:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     62c:	77 9b       	sbis	0x0e, 7	; 14
     62e:	fe cf       	rjmp	.-4      	; 0x62c <write_burst_reg+0x18>
	unsigned char i,j,value;
	cbi(SPI_PORT, P_CSn);
	while(bit_is_set(PINB, P_SO));
	addr|=WRITE_BURST;
	SPI_write(addr);
	for(j=0;j<count;j++) {
     630:	9f 5f       	subi	r25, 0xFF	; 255
     632:	31 96       	adiw	r30, 0x01	; 1
     634:	94 17       	cp	r25, r20
     636:	c0 f3       	brcs	.-16     	; 0x628 <write_burst_reg+0x14>
	  value=buffer[j];
	  SPI_write(value);
	  for(i=0;i<10;i++);
	}
	sbi(SPI_PORT, P_CSn);
     638:	c3 9a       	sbi	0x18, 3	; 24
}// write_burst_reg
     63a:	08 95       	ret

0000063c <strobe>:
//      BYTE strobe
//          Strobe command
//-------------------------------------------------------------------------------------------------------
void strobe(BYTE strobe) 
{
	cbi(SPI_PORT, P_CSn);
     63c:	c3 98       	cbi	0x18, 3	; 24
	
	while(bit_is_set(PINB, P_SO));
     63e:	b6 99       	sbic	0x16, 6	; 22
     640:	fe cf       	rjmp	.-4      	; 0x63e <strobe+0x2>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     642:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     644:	77 9b       	sbis	0x0e, 7	; 14
     646:	fe cf       	rjmp	.-4      	; 0x644 <strobe+0x8>
{
	cbi(SPI_PORT, P_CSn);
	
	while(bit_is_set(PINB, P_SO));
	SPI_write(strobe);
	sbi(SPI_PORT, P_CSn);
     648:	c3 9a       	sbi	0x18, 3	; 24

}// strobe
     64a:	08 95       	ret

0000064c <send_pkt>:
//      UINT8 size
//          The size of the txBuffer
//-------------------------------------------------------------------------------------------------------

void send_pkt(BYTE *txBuffer, UINT8 size) 
{
     64c:	0f 93       	push	r16
     64e:	1f 93       	push	r17
     650:	9c 01       	movw	r18, r24
     652:	46 2f       	mov	r20, r22
//      BYTE strobe
//          Strobe command
//-------------------------------------------------------------------------------------------------------
void strobe(BYTE strobe) 
{
	cbi(SPI_PORT, P_CSn);
     654:	c3 98       	cbi	0x18, 3	; 24
	
	while(bit_is_set(PINB, P_SO));
     656:	b6 99       	sbic	0x16, 6	; 22
     658:	fe cf       	rjmp	.-4      	; 0x656 <send_pkt+0xa>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     65a:	8b e3       	ldi	r24, 0x3B	; 59
     65c:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     65e:	77 9b       	sbis	0x0e, 7	; 14
     660:	fe cf       	rjmp	.-4      	; 0x65e <send_pkt+0x12>
{
	cbi(SPI_PORT, P_CSn);
	
	while(bit_is_set(PINB, P_SO));
	SPI_write(strobe);
	sbi(SPI_PORT, P_CSn);
     662:	c3 9a       	sbi	0x18, 3	; 24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     664:	00 e4       	ldi	r16, 0x40	; 64
     666:	1c e9       	ldi	r17, 0x9C	; 156
     668:	f8 01       	movw	r30, r16
     66a:	31 97       	sbiw	r30, 0x01	; 1
     66c:	f1 f7       	brne	.-4      	; 0x66a <send_pkt+0x1e>

void send_pkt(BYTE *txBuffer, UINT8 size) 
{
	strobe(SFTX);
	_delay_ms(10);
	write_burst_reg(TXFIFO, txBuffer, size);
     66e:	8f e3       	ldi	r24, 0x3F	; 63
     670:	b9 01       	movw	r22, r18
     672:	0e 94 0a 03 	call	0x614	; 0x614 <write_burst_reg>
     676:	c8 01       	movw	r24, r16
     678:	01 97       	sbiw	r24, 0x01	; 1
     67a:	f1 f7       	brne	.-4      	; 0x678 <send_pkt+0x2c>
//      BYTE strobe
//          Strobe command
//-------------------------------------------------------------------------------------------------------
void strobe(BYTE strobe) 
{
	cbi(SPI_PORT, P_CSn);
     67c:	c3 98       	cbi	0x18, 3	; 24
	
	while(bit_is_set(PINB, P_SO));
     67e:	b6 99       	sbic	0x16, 6	; 22
     680:	fe cf       	rjmp	.-4      	; 0x67e <send_pkt+0x32>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     682:	85 e3       	ldi	r24, 0x35	; 53
     684:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     686:	77 9b       	sbis	0x0e, 7	; 14
     688:	fe cf       	rjmp	.-4      	; 0x686 <send_pkt+0x3a>
{
	cbi(SPI_PORT, P_CSn);
	
	while(bit_is_set(PINB, P_SO));
	SPI_write(strobe);
	sbi(SPI_PORT, P_CSn);
     68a:	c3 9a       	sbi	0x18, 3	; 24
     68c:	80 e4       	ldi	r24, 0x40	; 64
     68e:	9c e9       	ldi	r25, 0x9C	; 156
     690:	01 97       	sbiw	r24, 0x01	; 1
     692:	f1 f7       	brne	.-4      	; 0x690 <send_pkt+0x44>
	write_burst_reg(TXFIFO, txBuffer, size);
	_delay_ms(10);
	strobe(STX);
	_delay_ms(10);

	TCNT0=0;
     694:	12 be       	out	0x32, r1	; 50
     696:	03 c0       	rjmp	.+6      	; 0x69e <send_pkt+0x52>
	while((read_status(TXBYTES)&0x7F)!=0x00)	
	{
		
		if(TCNT0 == 255){ return; }
     698:	82 b7       	in	r24, 0x32	; 50
     69a:	8f 3f       	cpi	r24, 0xFF	; 255
     69c:	41 f0       	breq	.+16     	; 0x6ae <send_pkt+0x62>
	_delay_ms(10);
	strobe(STX);
	_delay_ms(10);

	TCNT0=0;
	while((read_status(TXBYTES)&0x7F)!=0x00)	
     69e:	8a e3       	ldi	r24, 0x3A	; 58
     6a0:	0e 94 dc 02 	call	0x5b8	; 0x5b8 <read_status>
     6a4:	90 e0       	ldi	r25, 0x00	; 0
     6a6:	8f 77       	andi	r24, 0x7F	; 127
     6a8:	90 70       	andi	r25, 0x00	; 0
     6aa:	89 2b       	or	r24, r25
     6ac:	a9 f7       	brne	.-22     	; 0x698 <send_pkt+0x4c>
		if(TCNT0 == 255){ return; }
			
	}

	return ;
}// send_pkt*/
     6ae:	1f 91       	pop	r17
     6b0:	0f 91       	pop	r16
     6b2:	08 95       	ret

000006b4 <data_tx>:
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
     6b4:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
     6b6:	b6 99       	sbic	0x16, 6	; 22
     6b8:	fe cf       	rjmp	.-4      	; 0x6b6 <data_tx+0x2>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     6ba:	8e e3       	ldi	r24, 0x3E	; 62
     6bc:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     6be:	77 9b       	sbis	0x0e, 7	; 14
     6c0:	fe cf       	rjmp	.-4      	; 0x6be <data_tx+0xa>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     6c2:	8f ef       	ldi	r24, 0xFF	; 255
     6c4:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     6c6:	77 9b       	sbis	0x0e, 7	; 14
     6c8:	fe cf       	rjmp	.-4      	; 0x6c6 <data_tx+0x12>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
     6ca:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
     6cc:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
     6ce:	b6 99       	sbic	0x16, 6	; 22
     6d0:	fe cf       	rjmp	.-4      	; 0x6ce <data_tx+0x1a>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     6d2:	82 e2       	ldi	r24, 0x22	; 34
     6d4:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     6d6:	77 9b       	sbis	0x0e, 7	; 14
     6d8:	fe cf       	rjmp	.-4      	; 0x6d6 <data_tx+0x22>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     6da:	80 e1       	ldi	r24, 0x10	; 16
     6dc:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     6de:	77 9b       	sbis	0x0e, 7	; 14
     6e0:	fe cf       	rjmp	.-4      	; 0x6de <data_tx+0x2a>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
     6e2:	c3 9a       	sbi	0x18, 3	; 24
     6e4:	8a ef       	ldi	r24, 0xFA	; 250
     6e6:	90 e0       	ldi	r25, 0x00	; 0
     6e8:	20 e9       	ldi	r18, 0x90	; 144
     6ea:	31 e0       	ldi	r19, 0x01	; 1
     6ec:	f9 01       	movw	r30, r18
     6ee:	31 97       	sbiw	r30, 0x01	; 1
     6f0:	f1 f7       	brne	.-4      	; 0x6ee <data_tx+0x3a>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     6f2:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     6f4:	d9 f7       	brne	.-10     	; 0x6ec <data_tx+0x38>
{   
        halRfWriteReg(PATABLE,0xFF);
	halRfWriteReg(FREND0, 0x10);
	_delay_ms(25);	

    txBuffer[0]= pkt_len; //packet length
     6f6:	85 e0       	ldi	r24, 0x05	; 5
     6f8:	80 93 51 07 	sts	0x0751, r24

   	send_pkt(txBuffer, sizeof(txBuffer));
     6fc:	81 e5       	ldi	r24, 0x51	; 81
     6fe:	97 e0       	ldi	r25, 0x07	; 7
     700:	66 e0       	ldi	r22, 0x06	; 6
     702:	0e 94 26 03 	call	0x64c	; 0x64c <send_pkt>
//	_delay_ms(25);	
}
     706:	08 95       	ret

00000708 <receive_pkt>:
//      BOOL
//          TRUE:   CRC OK
//          FALSE:  CRC NOT OK
//-------------------------------------------------------------------------------------------------------
BYTE receive_pkt(BYTE *rxBuffer, UINT8 length) 
{
     708:	1f 93       	push	r17
     70a:	cf 93       	push	r28
     70c:	df 93       	push	r29
     70e:	ec 01       	movw	r28, r24
     710:	16 2f       	mov	r17, r22
    BYTE status=0;
    UINT8 packetLength;
	status = read_status(RXBYTES);
     712:	8b e3       	ldi	r24, 0x3B	; 59
     714:	0e 94 dc 02 	call	0x5b8	; 0x5b8 <read_status>
	
	if((status & 0x7F)==0x00) 
     718:	90 e0       	ldi	r25, 0x00	; 0
     71a:	8f 77       	andi	r24, 0x7F	; 127
     71c:	90 70       	andi	r25, 0x00	; 0
     71e:	89 2b       	or	r24, r25
     720:	69 f4       	brne	.+26     	; 0x73c <receive_pkt+0x34>
	{
		
		if(read_status(MARCSTATE)!=0x0D) strobe(SRX);
     722:	85 e3       	ldi	r24, 0x35	; 53
     724:	0e 94 dc 02 	call	0x5b8	; 0x5b8 <read_status>
     728:	8d 30       	cpi	r24, 0x0D	; 13
     72a:	b9 f1       	breq	.+110    	; 0x79a <receive_pkt+0x92>
//      BYTE strobe
//          Strobe command
//-------------------------------------------------------------------------------------------------------
void strobe(BYTE strobe) 
{
	cbi(SPI_PORT, P_CSn);
     72c:	c3 98       	cbi	0x18, 3	; 24
	
	while(bit_is_set(PINB, P_SO));
     72e:	b6 99       	sbic	0x16, 6	; 22
     730:	fe cf       	rjmp	.-4      	; 0x72e <receive_pkt+0x26>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     732:	84 e3       	ldi	r24, 0x34	; 52
     734:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     736:	77 9b       	sbis	0x0e, 7	; 14
     738:	fe cf       	rjmp	.-4      	; 0x736 <receive_pkt+0x2e>
     73a:	2e c0       	rjmp	.+92     	; 0x798 <receive_pkt+0x90>
		
		if(read_status(MARCSTATE)!=0x0D) strobe(SRX);
		return 0;
	}
	
	TCNT0=0;
     73c:	12 be       	out	0x32, r1	; 50
     73e:	0b c0       	rjmp	.+22     	; 0x756 <receive_pkt+0x4e>
	while((read_status(MARCSTATE)&0x1f)!=0x01) 
	{
		
		if(TCNT0 == 255)
     740:	82 b7       	in	r24, 0x32	; 50
     742:	8f 3f       	cpi	r24, 0xFF	; 255
     744:	41 f4       	brne	.+16     	; 0x756 <receive_pkt+0x4e>
//      BYTE strobe
//          Strobe command
//-------------------------------------------------------------------------------------------------------
void strobe(BYTE strobe) 
{
	cbi(SPI_PORT, P_CSn);
     746:	c3 98       	cbi	0x18, 3	; 24
	
	while(bit_is_set(PINB, P_SO));
     748:	b6 99       	sbic	0x16, 6	; 22
     74a:	fe cf       	rjmp	.-4      	; 0x748 <receive_pkt+0x40>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     74c:	8a e3       	ldi	r24, 0x3A	; 58
     74e:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     750:	77 9b       	sbis	0x0e, 7	; 14
     752:	fe cf       	rjmp	.-4      	; 0x750 <receive_pkt+0x48>
     754:	21 c0       	rjmp	.+66     	; 0x798 <receive_pkt+0x90>
		if(read_status(MARCSTATE)!=0x0D) strobe(SRX);
		return 0;
	}
	
	TCNT0=0;
	while((read_status(MARCSTATE)&0x1f)!=0x01) 
     756:	85 e3       	ldi	r24, 0x35	; 53
     758:	0e 94 dc 02 	call	0x5b8	; 0x5b8 <read_status>
     75c:	8f 71       	andi	r24, 0x1F	; 31
     75e:	81 30       	cpi	r24, 0x01	; 1
     760:	79 f7       	brne	.-34     	; 0x740 <receive_pkt+0x38>
			strobe(SFRX);
			return 0;
		}

	}
   packetLength = read_reg(RXFIFO);
     762:	8f e3       	ldi	r24, 0x3F	; 63
     764:	0e 94 cf 02 	call	0x59e	; 0x59e <read_reg>
    
    if (packetLength == length) {
     768:	81 17       	cp	r24, r17
     76a:	79 f4       	brne	.+30     	; 0x78a <receive_pkt+0x82>
		read_burst_reg(RXFIFO, rxBuffer, packetLength); 
     76c:	8f e3       	ldi	r24, 0x3F	; 63
     76e:	be 01       	movw	r22, r28
     770:	41 2f       	mov	r20, r17
     772:	0e 94 f5 02 	call	0x5ea	; 0x5ea <read_burst_reg>
//      BYTE strobe
//          Strobe command
//-------------------------------------------------------------------------------------------------------
void strobe(BYTE strobe) 
{
	cbi(SPI_PORT, P_CSn);
     776:	c3 98       	cbi	0x18, 3	; 24
	
	while(bit_is_set(PINB, P_SO));
     778:	b6 99       	sbic	0x16, 6	; 22
     77a:	fe cf       	rjmp	.-4      	; 0x778 <receive_pkt+0x70>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     77c:	8a e3       	ldi	r24, 0x3A	; 58
     77e:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     780:	77 9b       	sbis	0x0e, 7	; 14
     782:	fe cf       	rjmp	.-4      	; 0x780 <receive_pkt+0x78>
{
	cbi(SPI_PORT, P_CSn);
	
	while(bit_is_set(PINB, P_SO));
	SPI_write(strobe);
	sbi(SPI_PORT, P_CSn);
     784:	c3 9a       	sbi	0x18, 3	; 24
     786:	81 e0       	ldi	r24, 0x01	; 1
     788:	09 c0       	rjmp	.+18     	; 0x79c <receive_pkt+0x94>
//      BYTE strobe
//          Strobe command
//-------------------------------------------------------------------------------------------------------
void strobe(BYTE strobe) 
{
	cbi(SPI_PORT, P_CSn);
     78a:	c3 98       	cbi	0x18, 3	; 24
	
	while(bit_is_set(PINB, P_SO));
     78c:	b6 99       	sbic	0x16, 6	; 22
     78e:	fe cf       	rjmp	.-4      	; 0x78c <receive_pkt+0x84>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     790:	8a e3       	ldi	r24, 0x3A	; 58
     792:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     794:	77 9b       	sbis	0x0e, 7	; 14
     796:	fe cf       	rjmp	.-4      	; 0x794 <receive_pkt+0x8c>
{
	cbi(SPI_PORT, P_CSn);
	
	while(bit_is_set(PINB, P_SO));
	SPI_write(strobe);
	sbi(SPI_PORT, P_CSn);
     798:	c3 9a       	sbi	0x18, 3	; 24
     79a:	80 e0       	ldi	r24, 0x00	; 0
        return 1;//(status & CRC_OK);
    } else {
		strobe(SFRX);
       return 0;
    }  
}// receive_pkt
     79c:	df 91       	pop	r29
     79e:	cf 91       	pop	r28
     7a0:	1f 91       	pop	r17
     7a2:	08 95       	ret

000007a4 <data_rx>:

unsigned char data_rx(void)
{	
	//unsigned char	length;
	//length = sizeof(rxBuffer);
    if (receive_pkt(rxBuffer, pkt_len))	
     7a4:	81 e3       	ldi	r24, 0x31	; 49
     7a6:	97 e0       	ldi	r25, 0x07	; 7
     7a8:	65 e0       	ldi	r22, 0x05	; 5
     7aa:	0e 94 84 03 	call	0x708	; 0x708 <receive_pkt>
     7ae:	81 11       	cpse	r24, r1
     7b0:	81 e0       	ldi	r24, 0x01	; 1
		return 1;
	else
		return 0;
		
}
     7b2:	08 95       	ret

000007b4 <POWER_UP_RESET_CC2500>:
//      BYTE strobe
//          Strobe command
//-------------------------------------------------------------------------------------------------------
void strobe(BYTE strobe) 
{
	cbi(SPI_PORT, P_CSn);
     7b4:	c3 98       	cbi	0x18, 3	; 24
	
	while(bit_is_set(PINB, P_SO));
     7b6:	b6 99       	sbic	0x16, 6	; 22
     7b8:	fe cf       	rjmp	.-4      	; 0x7b6 <POWER_UP_RESET_CC2500+0x2>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     7ba:	86 e3       	ldi	r24, 0x36	; 54
     7bc:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     7be:	77 9b       	sbis	0x0e, 7	; 14
     7c0:	fe cf       	rjmp	.-4      	; 0x7be <POWER_UP_RESET_CC2500+0xa>
{
	cbi(SPI_PORT, P_CSn);
	
	while(bit_is_set(PINB, P_SO));
	SPI_write(strobe);
	sbi(SPI_PORT, P_CSn);
     7c2:	c3 9a       	sbi	0x18, 3	; 24
//
//------------------------------------------------------------
void POWER_UP_RESET_CC2500() {
	
	strobe(SIDLE);
	sbi(SPI_PORT, P_CSn);
     7c4:	c3 9a       	sbi	0x18, 3	; 24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     7c6:	8a e1       	ldi	r24, 0x1A	; 26
     7c8:	8a 95       	dec	r24
     7ca:	f1 f7       	brne	.-4      	; 0x7c8 <POWER_UP_RESET_CC2500+0x14>
	_delay_us(5);
	cbi(SPI_PORT, P_CSn);
     7cc:	c3 98       	cbi	0x18, 3	; 24
     7ce:	85 e3       	ldi	r24, 0x35	; 53
     7d0:	8a 95       	dec	r24
     7d2:	f1 f7       	brne	.-4      	; 0x7d0 <POWER_UP_RESET_CC2500+0x1c>
	_delay_us(10);  	 
	sbi(SPI_PORT, P_CSn);
     7d4:	c3 9a       	sbi	0x18, 3	; 24
     7d6:	85 ed       	ldi	r24, 0xD5	; 213
     7d8:	8a 95       	dec	r24
     7da:	f1 f7       	brne	.-4      	; 0x7d8 <POWER_UP_RESET_CC2500+0x24>
	_delay_us(40);
	cbi(SPI_PORT, P_CSn);
     7dc:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
     7de:	b6 99       	sbic	0x16, 6	; 22
     7e0:	fe cf       	rjmp	.-4      	; 0x7de <POWER_UP_RESET_CC2500+0x2a>
//      BYTE strobe
//          Strobe command
//-------------------------------------------------------------------------------------------------------
void strobe(BYTE strobe) 
{
	cbi(SPI_PORT, P_CSn);
     7e2:	c3 98       	cbi	0x18, 3	; 24
	
	while(bit_is_set(PINB, P_SO));
     7e4:	b6 99       	sbic	0x16, 6	; 22
     7e6:	fe cf       	rjmp	.-4      	; 0x7e4 <POWER_UP_RESET_CC2500+0x30>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     7e8:	80 e3       	ldi	r24, 0x30	; 48
     7ea:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     7ec:	77 9b       	sbis	0x0e, 7	; 14
     7ee:	fe cf       	rjmp	.-4      	; 0x7ec <POWER_UP_RESET_CC2500+0x38>
{
	cbi(SPI_PORT, P_CSn);
	
	while(bit_is_set(PINB, P_SO));
	SPI_write(strobe);
	sbi(SPI_PORT, P_CSn);
     7f0:	c3 9a       	sbi	0x18, 3	; 24
	sbi(SPI_PORT, P_CSn);
	_delay_us(40);
	cbi(SPI_PORT, P_CSn);
	while(bit_is_set(PINB, P_SO));
	strobe(SRES);
	sbi(SPI_PORT, P_CSn);
     7f2:	c3 9a       	sbi	0x18, 3	; 24
//	cbi(SPI_PORT, P_SCLK);
//	cbi(SPI_PORT, P_SI);
}
     7f4:	08 95       	ret

000007f6 <cc2500_init>:
		
}

void initTimer0(){
	/* clkI/O/64 (From prescaler) */
	TCCR0 = (0<<CS02)|(1<<CS01)|(1<<CS00);
     7f6:	83 e0       	ldi	r24, 0x03	; 3
     7f8:	83 bf       	out	0x33, r24	; 51
	TIMSK = 0;
     7fa:	19 be       	out	0x39, r1	; 57


void SPI_MasterInit(void)
{
	/* Set MOSI and SCK output, all others input */
	sbi(SPI_DDR, DD_CS);	//cs
     7fc:	bb 9a       	sbi	0x17, 3	; 23
	sbi(SPI_DDR, DD_SS);	//ss
     7fe:	bc 9a       	sbi	0x17, 4	; 23
	sbi(SPI_DDR, DD_MOSI);	//mosi
     800:	bd 9a       	sbi	0x17, 5	; 23
	cbi(SPI_DDR, DD_MISO);	//miso
     802:	be 98       	cbi	0x17, 6	; 23
	sbi(SPI_DDR, DD_SCK);	//sck
     804:	bf 9a       	sbi	0x17, 7	; 23
	
	/*	Enable SPI, Master, set clock rate 
		10 is fck/64	*/
	SPCR = (1<<SPE)|(1<<MSTR)|(0<<SPR1)|(0<<SPR0);	
     806:	80 e5       	ldi	r24, 0x50	; 80
     808:	8d b9       	out	0x0d, r24	; 13
	SPSR |= (0<<SPI2X);
     80a:	8e b1       	in	r24, 0x0e	; 14
     80c:	8e b9       	out	0x0e, r24	; 14

void cc2500_init()   // initialize the CC2500 chip and SPI
{
        initTimer0();
        SPI_MasterInit();	
	POWER_UP_RESET_CC2500();
     80e:	0e 94 da 03 	call	0x7b4	; 0x7b4 <POWER_UP_RESET_CC2500>
	write_rf_setting();
     812:	0e 94 ea 00 	call	0x1d4	; 0x1d4 <write_rf_setting>
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
     816:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
     818:	b6 99       	sbic	0x16, 6	; 22
     81a:	fe cf       	rjmp	.-4      	; 0x818 <cc2500_init+0x22>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     81c:	8e e3       	ldi	r24, 0x3E	; 62
     81e:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     820:	77 9b       	sbis	0x0e, 7	; 14
     822:	fe cf       	rjmp	.-4      	; 0x820 <cc2500_init+0x2a>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
     824:	8f ef       	ldi	r24, 0xFF	; 255
     826:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
     828:	77 9b       	sbis	0x0e, 7	; 14
     82a:	fe cf       	rjmp	.-4      	; 0x828 <cc2500_init+0x32>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
     82c:	c3 9a       	sbi	0x18, 3	; 24
        SPI_MasterInit();	
	POWER_UP_RESET_CC2500();
	write_rf_setting();
	//write_burst_reg(PATABLE, paTable, sizeof(paTable));
	halRfWriteReg(PATABLE,0xFF);// 1 dbm output power
}
     82e:	08 95       	ret

00000830 <wake>:



void wake()
{
        rfstate=read_status(MARCSTATE);	//check sleep state and other
     830:	85 e3       	ldi	r24, 0x35	; 53
     832:	0e 94 dc 02 	call	0x5b8	; 0x5b8 <read_status>
     836:	80 93 95 06 	sts	0x0695, r24
		if((rfstate& 0x1f)==0x00)
     83a:	90 e0       	ldi	r25, 0x00	; 0
     83c:	8f 71       	andi	r24, 0x1F	; 31
     83e:	90 70       	andi	r25, 0x00	; 0
     840:	89 2b       	or	r24, r25
     842:	21 f4       	brne	.+8      	; 0x84c <wake+0x1c>
		{
	
			POWER_UP_RESET_CC2500();
     844:	0e 94 da 03 	call	0x7b4	; 0x7b4 <POWER_UP_RESET_CC2500>
			write_rf_setting();
     848:	0e 94 ea 00 	call	0x1d4	; 0x1d4 <write_rf_setting>
     84c:	08 95       	ret

0000084e <read_xyz>:
   //Select ADC Channel ch must be 0-7 (corresponds to the flex sensors...)
   //flex sensors from channel 0-4
   //acccelerometer from channel 5-7
   
   //ch=ch & 0b00000111;
   ADMUX = ch;
     84e:	85 e0       	ldi	r24, 0x05	; 5
     850:	87 b9       	out	0x07, r24	; 7

   //Start Single conversion
   ADCSRA|=(1<<ADSC);
     852:	36 9a       	sbi	0x06, 6	; 6

   //Wait for conversion to complete
   while(!(ADCSRA & (1<<ADIF)));
     854:	34 9b       	sbis	0x06, 4	; 6
     856:	fe cf       	rjmp	.-4      	; 0x854 <read_xyz+0x6>

   //Clear ADIF by writing one to it
   ADCSRA|=(1<<ADIF);
     858:	34 9a       	sbi	0x06, 4	; 6

   return(ADCW);
     85a:	84 b1       	in	r24, 0x04	; 4
     85c:	95 b1       	in	r25, 0x05	; 5
}
*/

void read_xyz()
{
xa=read_adc(5);
     85e:	90 93 59 07 	sts	0x0759, r25
     862:	80 93 58 07 	sts	0x0758, r24
   //Select ADC Channel ch must be 0-7 (corresponds to the flex sensors...)
   //flex sensors from channel 0-4
   //acccelerometer from channel 5-7
   
   //ch=ch & 0b00000111;
   ADMUX = ch;
     866:	86 e0       	ldi	r24, 0x06	; 6
     868:	87 b9       	out	0x07, r24	; 7

   //Start Single conversion
   ADCSRA|=(1<<ADSC);
     86a:	36 9a       	sbi	0x06, 6	; 6

   //Wait for conversion to complete
   while(!(ADCSRA & (1<<ADIF)));
     86c:	34 9b       	sbis	0x06, 4	; 6
     86e:	fe cf       	rjmp	.-4      	; 0x86c <__stack+0xd>

   //Clear ADIF by writing one to it
   ADCSRA|=(1<<ADIF);
     870:	34 9a       	sbi	0x06, 4	; 6

   return(ADCW);
     872:	84 b1       	in	r24, 0x04	; 4
     874:	95 b1       	in	r25, 0x05	; 5
ya=read_adc(6);
     876:	90 93 5b 07 	sts	0x075B, r25
     87a:	80 93 5a 07 	sts	0x075A, r24
   //Select ADC Channel ch must be 0-7 (corresponds to the flex sensors...)
   //flex sensors from channel 0-4
   //acccelerometer from channel 5-7
   
   //ch=ch & 0b00000111;
   ADMUX = ch;
     87e:	87 e0       	ldi	r24, 0x07	; 7
     880:	87 b9       	out	0x07, r24	; 7

   //Start Single conversion
   ADCSRA|=(1<<ADSC);
     882:	36 9a       	sbi	0x06, 6	; 6

   //Wait for conversion to complete
   while(!(ADCSRA & (1<<ADIF)));
     884:	34 9b       	sbis	0x06, 4	; 6
     886:	fe cf       	rjmp	.-4      	; 0x884 <__stack+0x25>

   //Clear ADIF by writing one to it
   ADCSRA|=(1<<ADIF);
     888:	34 9a       	sbi	0x06, 4	; 6

   return(ADCW);
     88a:	84 b1       	in	r24, 0x04	; 4
     88c:	95 b1       	in	r25, 0x05	; 5
za=read_adc(7);
     88e:	90 93 8c 04 	sts	0x048C, r25
     892:	80 93 8b 04 	sts	0x048B, r24
}
     896:	08 95       	ret

00000898 <num_disp>:

void num_disp()
{

key=key_read();
while(key=='/'){key=key_read();}
     898:	0e 94 7a 00 	call	0xf4	; 0xf4 <key_read>
     89c:	80 93 50 07 	sts	0x0750, r24
     8a0:	90 91 50 07 	lds	r25, 0x0750
     8a4:	9f 32       	cpi	r25, 0x2F	; 47
     8a6:	c1 f3       	breq	.-16     	; 0x898 <num_disp>


if(key=='#'){submenu_select=0;}
     8a8:	93 32       	cpi	r25, 0x23	; 35
     8aa:	19 f4       	brne	.+6      	; 0x8b2 <num_disp+0x1a>
     8ac:	10 92 74 03 	sts	0x0374, r1
     8b0:	08 95       	ret

else{
txBuffer[1]=0x1C;
     8b2:	8c e1       	ldi	r24, 0x1C	; 28
     8b4:	80 93 52 07 	sts	0x0752, r24
txBuffer[2]=key; 
     8b8:	90 93 53 07 	sts	0x0753, r25
txBuffer[3]=0x00;
     8bc:	10 92 54 07 	sts	0x0754, r1
txBuffer[4]=0x00;
     8c0:	10 92 55 07 	sts	0x0755, r1
txBuffer[5]=0x00;
     8c4:	10 92 56 07 	sts	0x0756, r1
data_tx();
     8c8:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <data_tx>
     8cc:	88 eb       	ldi	r24, 0xB8	; 184
     8ce:	9b e0       	ldi	r25, 0x0B	; 11
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     8d0:	20 e9       	ldi	r18, 0x90	; 144
     8d2:	31 e0       	ldi	r19, 0x01	; 1
     8d4:	f9 01       	movw	r30, r18
     8d6:	31 97       	sbiw	r30, 0x01	; 1
     8d8:	f1 f7       	brne	.-4      	; 0x8d6 <num_disp+0x3e>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     8da:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     8dc:	d9 f7       	brne	.-10     	; 0x8d4 <num_disp+0x3c>
     8de:	08 95       	ret

000008e0 <sp_char_disp>:

}


void sp_char_disp()
{
     8e0:	cf 93       	push	r28
     8e2:	df 93       	push	r29

key=key_read();
while(key=='/'){key=key_read();}
     8e4:	0e 94 7a 00 	call	0xf4	; 0xf4 <key_read>
     8e8:	80 93 50 07 	sts	0x0750, r24
     8ec:	80 91 50 07 	lds	r24, 0x0750
     8f0:	8f 32       	cpi	r24, 0x2F	; 47
     8f2:	c1 f3       	breq	.-16     	; 0x8e4 <sp_char_disp+0x4>


if(key=='0')
     8f4:	80 33       	cpi	r24, 0x30	; 48
     8f6:	b9 f4       	brne	.+46     	; 0x926 <sp_char_disp+0x46>
{
txBuffer[1]=0x0C;
     8f8:	8c e0       	ldi	r24, 0x0C	; 12
     8fa:	80 93 52 07 	sts	0x0752, r24
txBuffer[2]=32;//space
     8fe:	80 e2       	ldi	r24, 0x20	; 32
     900:	80 93 53 07 	sts	0x0753, r24
txBuffer[3]=0x00;
     904:	10 92 54 07 	sts	0x0754, r1
txBuffer[4]=0x00;
     908:	10 92 55 07 	sts	0x0755, r1
txBuffer[5]=0x00;
     90c:	10 92 56 07 	sts	0x0756, r1
data_tx();
     910:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <data_tx>
     914:	88 eb       	ldi	r24, 0xB8	; 184
     916:	9b e0       	ldi	r25, 0x0B	; 11
     918:	20 e9       	ldi	r18, 0x90	; 144
     91a:	31 e0       	ldi	r19, 0x01	; 1
     91c:	f9 01       	movw	r30, r18
     91e:	31 97       	sbiw	r30, 0x01	; 1
     920:	f1 f7       	brne	.-4      	; 0x91e <sp_char_disp+0x3e>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     922:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     924:	d9 f7       	brne	.-10     	; 0x91c <sp_char_disp+0x3c>
_delay_ms(keypress);
}

if(key=='1') //backspace and clear screen
     926:	80 91 50 07 	lds	r24, 0x0750
     92a:	81 33       	cpi	r24, 0x31	; 49
     92c:	09 f0       	breq	.+2      	; 0x930 <sp_char_disp+0x50>
     92e:	45 c0       	rjmp	.+138    	; 0x9ba <sp_char_disp+0xda>
{
bksp_cnt=0;
     930:	10 92 75 03 	sts	0x0375, r1
txBuffer[1]=0x0B;
     934:	8b e0       	ldi	r24, 0x0B	; 11
     936:	80 93 52 07 	sts	0x0752, r24
txBuffer[2]=0x00; 
     93a:	10 92 53 07 	sts	0x0753, r1
txBuffer[3]=0x00;
     93e:	10 92 54 07 	sts	0x0754, r1
txBuffer[4]=0x00;
     942:	10 92 55 07 	sts	0x0755, r1
txBuffer[5]=0x00;
     946:	10 92 56 07 	sts	0x0756, r1
data_tx();
     94a:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <data_tx>
     94e:	88 eb       	ldi	r24, 0xB8	; 184
     950:	9b e0       	ldi	r25, 0x0B	; 11
     952:	20 e9       	ldi	r18, 0x90	; 144
     954:	31 e0       	ldi	r19, 0x01	; 1
     956:	f9 01       	movw	r30, r18
     958:	31 97       	sbiw	r30, 0x01	; 1
     95a:	f1 f7       	brne	.-4      	; 0x958 <sp_char_disp+0x78>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     95c:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     95e:	d9 f7       	brne	.-10     	; 0x956 <sp_char_disp+0x76>
_delay_ms(keypress);

//clear screen if key 1 is pressed for more than 1 second
key=key_read();
     960:	0e 94 7a 00 	call	0xf4	; 0xf4 <key_read>
     964:	80 93 50 07 	sts	0x0750, r24
     968:	c0 e9       	ldi	r28, 0x90	; 144
     96a:	d1 e0       	ldi	r29, 0x01	; 1
     96c:	22 c0       	rjmp	.+68     	; 0x9b2 <sp_char_disp+0xd2>
while(key=='1')
{
bksp_cnt++;
     96e:	80 91 75 03 	lds	r24, 0x0375
     972:	8f 5f       	subi	r24, 0xFF	; 255
     974:	80 93 75 03 	sts	0x0375, r24
key=key_read();
     978:	0e 94 7a 00 	call	0xf4	; 0xf4 <key_read>
     97c:	80 93 50 07 	sts	0x0750, r24
     980:	88 ee       	ldi	r24, 0xE8	; 232
     982:	93 e0       	ldi	r25, 0x03	; 3
     984:	fe 01       	movw	r30, r28
     986:	31 97       	sbiw	r30, 0x01	; 1
     988:	f1 f7       	brne	.-4      	; 0x986 <sp_char_disp+0xa6>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     98a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     98c:	d9 f7       	brne	.-10     	; 0x984 <sp_char_disp+0xa4>
_delay_ms(100);
if(bksp_cnt>10)
     98e:	80 91 75 03 	lds	r24, 0x0375
     992:	8b 30       	cpi	r24, 0x0B	; 11
     994:	70 f0       	brcs	.+28     	; 0x9b2 <sp_char_disp+0xd2>
{
txBuffer[1]=0xAC;
     996:	8c ea       	ldi	r24, 0xAC	; 172
     998:	80 93 52 07 	sts	0x0752, r24
txBuffer[2]=0x00; 
     99c:	10 92 53 07 	sts	0x0753, r1
txBuffer[3]=0x00;
     9a0:	10 92 54 07 	sts	0x0754, r1
txBuffer[4]=0x00;
     9a4:	10 92 55 07 	sts	0x0755, r1
txBuffer[5]=0x00;
     9a8:	10 92 56 07 	sts	0x0756, r1
data_tx();
     9ac:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <data_tx>
     9b0:	04 c0       	rjmp	.+8      	; 0x9ba <sp_char_disp+0xda>
data_tx();
_delay_ms(keypress);

//clear screen if key 1 is pressed for more than 1 second
key=key_read();
while(key=='1')
     9b2:	80 91 50 07 	lds	r24, 0x0750
     9b6:	81 33       	cpi	r24, 0x31	; 49
     9b8:	d1 f2       	breq	.-76     	; 0x96e <sp_char_disp+0x8e>
break;
}
}
}

if(key=='2')
     9ba:	80 91 50 07 	lds	r24, 0x0750
     9be:	82 33       	cpi	r24, 0x32	; 50
     9c0:	b9 f4       	brne	.+46     	; 0x9f0 <sp_char_disp+0x110>
{
txBuffer[1]=0x2C;
     9c2:	8c e2       	ldi	r24, 0x2C	; 44
     9c4:	80 93 52 07 	sts	0x0752, r24
txBuffer[2]='!'; //exclamation mark
     9c8:	81 e2       	ldi	r24, 0x21	; 33
     9ca:	80 93 53 07 	sts	0x0753, r24
txBuffer[3]=0x00;
     9ce:	10 92 54 07 	sts	0x0754, r1
txBuffer[4]=0x00;
     9d2:	10 92 55 07 	sts	0x0755, r1
txBuffer[5]=0x00;
     9d6:	10 92 56 07 	sts	0x0756, r1
data_tx();
     9da:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <data_tx>
     9de:	88 eb       	ldi	r24, 0xB8	; 184
     9e0:	9b e0       	ldi	r25, 0x0B	; 11
     9e2:	20 e9       	ldi	r18, 0x90	; 144
     9e4:	31 e0       	ldi	r19, 0x01	; 1
     9e6:	f9 01       	movw	r30, r18
     9e8:	31 97       	sbiw	r30, 0x01	; 1
     9ea:	f1 f7       	brne	.-4      	; 0x9e8 <sp_char_disp+0x108>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     9ec:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     9ee:	d9 f7       	brne	.-10     	; 0x9e6 <sp_char_disp+0x106>
_delay_ms(keypress);
}

if(key=='3')
     9f0:	80 91 50 07 	lds	r24, 0x0750
     9f4:	83 33       	cpi	r24, 0x33	; 51
     9f6:	b9 f4       	brne	.+46     	; 0xa26 <sp_char_disp+0x146>
{
txBuffer[1]=0x2C;
     9f8:	8c e2       	ldi	r24, 0x2C	; 44
     9fa:	80 93 52 07 	sts	0x0752, r24
txBuffer[2]='%';//percent symbol
     9fe:	85 e2       	ldi	r24, 0x25	; 37
     a00:	80 93 53 07 	sts	0x0753, r24
txBuffer[3]=0x00;
     a04:	10 92 54 07 	sts	0x0754, r1
txBuffer[4]=0x00;
     a08:	10 92 55 07 	sts	0x0755, r1
txBuffer[5]=0x00;
     a0c:	10 92 56 07 	sts	0x0756, r1
data_tx();
     a10:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <data_tx>
     a14:	88 eb       	ldi	r24, 0xB8	; 184
     a16:	9b e0       	ldi	r25, 0x0B	; 11
     a18:	20 e9       	ldi	r18, 0x90	; 144
     a1a:	31 e0       	ldi	r19, 0x01	; 1
     a1c:	f9 01       	movw	r30, r18
     a1e:	31 97       	sbiw	r30, 0x01	; 1
     a20:	f1 f7       	brne	.-4      	; 0xa1e <sp_char_disp+0x13e>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     a22:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     a24:	d9 f7       	brne	.-10     	; 0xa1c <sp_char_disp+0x13c>
_delay_ms(keypress);
}

if(key=='4')
     a26:	80 91 50 07 	lds	r24, 0x0750
     a2a:	84 33       	cpi	r24, 0x34	; 52
     a2c:	b9 f4       	brne	.+46     	; 0xa5c <sp_char_disp+0x17c>
{
txBuffer[1]=0x2C;
     a2e:	8c e2       	ldi	r24, 0x2C	; 44
     a30:	80 93 52 07 	sts	0x0752, r24
txBuffer[2]='.';//full stop
     a34:	8e e2       	ldi	r24, 0x2E	; 46
     a36:	80 93 53 07 	sts	0x0753, r24
txBuffer[3]=0x00;
     a3a:	10 92 54 07 	sts	0x0754, r1
txBuffer[4]=0x00;
     a3e:	10 92 55 07 	sts	0x0755, r1
txBuffer[5]=0x00;
     a42:	10 92 56 07 	sts	0x0756, r1
data_tx();
     a46:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <data_tx>
     a4a:	88 eb       	ldi	r24, 0xB8	; 184
     a4c:	9b e0       	ldi	r25, 0x0B	; 11
     a4e:	20 e9       	ldi	r18, 0x90	; 144
     a50:	31 e0       	ldi	r19, 0x01	; 1
     a52:	f9 01       	movw	r30, r18
     a54:	31 97       	sbiw	r30, 0x01	; 1
     a56:	f1 f7       	brne	.-4      	; 0xa54 <sp_char_disp+0x174>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     a58:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     a5a:	d9 f7       	brne	.-10     	; 0xa52 <sp_char_disp+0x172>
_delay_ms(keypress);
}

if(key=='5')
     a5c:	80 91 50 07 	lds	r24, 0x0750
     a60:	85 33       	cpi	r24, 0x35	; 53
     a62:	b1 f4       	brne	.+44     	; 0xa90 <sp_char_disp+0x1b0>
{
txBuffer[1]=0x2C;
     a64:	8c e2       	ldi	r24, 0x2C	; 44
     a66:	80 93 52 07 	sts	0x0752, r24
txBuffer[2]=',';//comma
     a6a:	80 93 53 07 	sts	0x0753, r24
txBuffer[3]=0x00;
     a6e:	10 92 54 07 	sts	0x0754, r1
txBuffer[4]=0x00;
     a72:	10 92 55 07 	sts	0x0755, r1
txBuffer[5]=0x00;
     a76:	10 92 56 07 	sts	0x0756, r1
data_tx();
     a7a:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <data_tx>
     a7e:	88 eb       	ldi	r24, 0xB8	; 184
     a80:	9b e0       	ldi	r25, 0x0B	; 11
     a82:	20 e9       	ldi	r18, 0x90	; 144
     a84:	31 e0       	ldi	r19, 0x01	; 1
     a86:	f9 01       	movw	r30, r18
     a88:	31 97       	sbiw	r30, 0x01	; 1
     a8a:	f1 f7       	brne	.-4      	; 0xa88 <sp_char_disp+0x1a8>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     a8c:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     a8e:	d9 f7       	brne	.-10     	; 0xa86 <sp_char_disp+0x1a6>
_delay_ms(keypress);
}

if(key=='6')
     a90:	80 91 50 07 	lds	r24, 0x0750
     a94:	86 33       	cpi	r24, 0x36	; 54
     a96:	b9 f4       	brne	.+46     	; 0xac6 <sp_char_disp+0x1e6>
{
txBuffer[1]=0x2C;
     a98:	8c e2       	ldi	r24, 0x2C	; 44
     a9a:	80 93 52 07 	sts	0x0752, r24
txBuffer[2]='?';//question mark
     a9e:	8f e3       	ldi	r24, 0x3F	; 63
     aa0:	80 93 53 07 	sts	0x0753, r24
txBuffer[3]=0x00;
     aa4:	10 92 54 07 	sts	0x0754, r1
txBuffer[4]=0x00;
     aa8:	10 92 55 07 	sts	0x0755, r1
txBuffer[5]=0x00;
     aac:	10 92 56 07 	sts	0x0756, r1
data_tx();
     ab0:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <data_tx>
     ab4:	88 eb       	ldi	r24, 0xB8	; 184
     ab6:	9b e0       	ldi	r25, 0x0B	; 11
     ab8:	20 e9       	ldi	r18, 0x90	; 144
     aba:	31 e0       	ldi	r19, 0x01	; 1
     abc:	f9 01       	movw	r30, r18
     abe:	31 97       	sbiw	r30, 0x01	; 1
     ac0:	f1 f7       	brne	.-4      	; 0xabe <sp_char_disp+0x1de>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     ac2:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     ac4:	d9 f7       	brne	.-10     	; 0xabc <sp_char_disp+0x1dc>
_delay_ms(keypress);
}

if(key=='7')
     ac6:	80 91 50 07 	lds	r24, 0x0750
     aca:	87 33       	cpi	r24, 0x37	; 55
     acc:	b9 f4       	brne	.+46     	; 0xafc <sp_char_disp+0x21c>
{
txBuffer[1]=0x2C;
     ace:	8c e2       	ldi	r24, 0x2C	; 44
     ad0:	80 93 52 07 	sts	0x0752, r24
txBuffer[2]='&'; //amphacent
     ad4:	86 e2       	ldi	r24, 0x26	; 38
     ad6:	80 93 53 07 	sts	0x0753, r24
txBuffer[3]=0x00;
     ada:	10 92 54 07 	sts	0x0754, r1
txBuffer[4]=0x00;
     ade:	10 92 55 07 	sts	0x0755, r1
txBuffer[5]=0x00;
     ae2:	10 92 56 07 	sts	0x0756, r1
data_tx();
     ae6:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <data_tx>
     aea:	88 eb       	ldi	r24, 0xB8	; 184
     aec:	9b e0       	ldi	r25, 0x0B	; 11
     aee:	20 e9       	ldi	r18, 0x90	; 144
     af0:	31 e0       	ldi	r19, 0x01	; 1
     af2:	f9 01       	movw	r30, r18
     af4:	31 97       	sbiw	r30, 0x01	; 1
     af6:	f1 f7       	brne	.-4      	; 0xaf4 <sp_char_disp+0x214>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     af8:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     afa:	d9 f7       	brne	.-10     	; 0xaf2 <sp_char_disp+0x212>
_delay_ms(keypress);
}

if(key=='8')
     afc:	80 91 50 07 	lds	r24, 0x0750
     b00:	88 33       	cpi	r24, 0x38	; 56
     b02:	b9 f4       	brne	.+46     	; 0xb32 <sp_char_disp+0x252>
{
txBuffer[1]=0x2C;
     b04:	8c e2       	ldi	r24, 0x2C	; 44
     b06:	80 93 52 07 	sts	0x0752, r24
txBuffer[2]='-'; //dash
     b0a:	8d e2       	ldi	r24, 0x2D	; 45
     b0c:	80 93 53 07 	sts	0x0753, r24
txBuffer[3]=0x00;
     b10:	10 92 54 07 	sts	0x0754, r1
txBuffer[4]=0x00;
     b14:	10 92 55 07 	sts	0x0755, r1
txBuffer[5]=0x00;
     b18:	10 92 56 07 	sts	0x0756, r1
data_tx();
     b1c:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <data_tx>
     b20:	88 eb       	ldi	r24, 0xB8	; 184
     b22:	9b e0       	ldi	r25, 0x0B	; 11
     b24:	20 e9       	ldi	r18, 0x90	; 144
     b26:	31 e0       	ldi	r19, 0x01	; 1
     b28:	f9 01       	movw	r30, r18
     b2a:	31 97       	sbiw	r30, 0x01	; 1
     b2c:	f1 f7       	brne	.-4      	; 0xb2a <sp_char_disp+0x24a>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     b2e:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     b30:	d9 f7       	brne	.-10     	; 0xb28 <sp_char_disp+0x248>
_delay_ms(keypress);
}

if(key=='9')//EXIT.... go out of sub menu to main menu
     b32:	80 91 50 07 	lds	r24, 0x0750
     b36:	89 33       	cpi	r24, 0x39	; 57
     b38:	19 f4       	brne	.+6      	; 0xb40 <sp_char_disp+0x260>
{
menu_select=0;
     b3a:	10 92 73 03 	sts	0x0373, r1
     b3e:	04 c0       	rjmp	.+8      	; 0xb48 <sp_char_disp+0x268>
}      

if(key=='#'){submenu_select=0;}
     b40:	83 32       	cpi	r24, 0x23	; 35
     b42:	11 f4       	brne	.+4      	; 0xb48 <sp_char_disp+0x268>
     b44:	10 92 74 03 	sts	0x0374, r1

}
     b48:	df 91       	pop	r29
     b4a:	cf 91       	pop	r28
     b4c:	08 95       	ret

00000b4e <patt_match>:

}
*/

char patt_match()
{
     b4e:	6f 92       	push	r6
     b50:	7f 92       	push	r7
     b52:	8f 92       	push	r8
     b54:	9f 92       	push	r9
     b56:	af 92       	push	r10
     b58:	bf 92       	push	r11
     b5a:	cf 92       	push	r12
     b5c:	df 92       	push	r13
     b5e:	ef 92       	push	r14
     b60:	ff 92       	push	r15
     b62:	0f 93       	push	r16
     b64:	1f 93       	push	r17
     b66:	cf 93       	push	r28
     b68:	df 93       	push	r29
     b6a:	a4 e8       	ldi	r26, 0x84	; 132
     b6c:	b3 e0       	ldi	r27, 0x03	; 3
     b6e:	60 e0       	ldi	r22, 0x00	; 0
     b70:	40 e0       	ldi	r20, 0x00	; 0
     b72:	50 e0       	ldi	r21, 0x00	; 0
     b74:	4a c0       	rjmp	.+148    	; 0xc0a <patt_match+0xbc>
for(al_cnt=0;al_cnt<26;al_cnt++)//find distance for all characters
{

for(samp_cnt=0;samp_cnt<total_samples;samp_cnt++)
{
temp_val+=abs(alph[al_cnt][0]-samp[samp_cnt][0]);
     b76:	82 81       	ldd	r24, Z+2	; 0x02
     b78:	93 81       	ldd	r25, Z+3	; 0x03
     b7a:	95 01       	movw	r18, r10
     b7c:	28 1b       	sub	r18, r24
     b7e:	39 0b       	sbc	r19, r25
     b80:	37 ff       	sbrs	r19, 7
     b82:	03 c0       	rjmp	.+6      	; 0xb8a <patt_match+0x3c>
     b84:	30 95       	com	r19
     b86:	21 95       	neg	r18
     b88:	3f 4f       	sbci	r19, 0xFF	; 255
     b8a:	80 81       	ld	r24, Z
     b8c:	91 81       	ldd	r25, Z+1	; 0x01
     b8e:	34 01       	movw	r6, r8
     b90:	68 1a       	sub	r6, r24
     b92:	79 0a       	sbc	r7, r25
     b94:	c3 01       	movw	r24, r6
     b96:	77 fe       	sbrs	r7, 7
     b98:	03 c0       	rjmp	.+6      	; 0xba0 <patt_match+0x52>
     b9a:	90 95       	com	r25
     b9c:	81 95       	neg	r24
     b9e:	9f 4f       	sbci	r25, 0xFF	; 255
     ba0:	28 0f       	add	r18, r24
temp_val+=abs(alph[al_cnt][1]-samp[samp_cnt][1]);
     ba2:	84 81       	ldd	r24, Z+4	; 0x04
     ba4:	95 81       	ldd	r25, Z+5	; 0x05
     ba6:	36 01       	movw	r6, r12
     ba8:	68 1a       	sub	r6, r24
     baa:	79 0a       	sbc	r7, r25
     bac:	c3 01       	movw	r24, r6
     bae:	77 fe       	sbrs	r7, 7
     bb0:	03 c0       	rjmp	.+6      	; 0xbb8 <patt_match+0x6a>
     bb2:	90 95       	com	r25
     bb4:	81 95       	neg	r24
     bb6:	9f 4f       	sbci	r25, 0xFF	; 255
     bb8:	28 0f       	add	r18, r24
temp_val+=abs(alph[al_cnt][2]-samp[samp_cnt][2]);
     bba:	86 81       	ldd	r24, Z+6	; 0x06
     bbc:	97 81       	ldd	r25, Z+7	; 0x07
     bbe:	37 01       	movw	r6, r14
     bc0:	68 1a       	sub	r6, r24
     bc2:	79 0a       	sbc	r7, r25
     bc4:	c3 01       	movw	r24, r6
     bc6:	77 fe       	sbrs	r7, 7
     bc8:	03 c0       	rjmp	.+6      	; 0xbd0 <patt_match+0x82>
     bca:	90 95       	com	r25
     bcc:	81 95       	neg	r24
     bce:	9f 4f       	sbci	r25, 0xFF	; 255
     bd0:	28 0f       	add	r18, r24
temp_val+=abs(alph[al_cnt][3]-samp[samp_cnt][3]);
     bd2:	80 85       	ldd	r24, Z+8	; 0x08
     bd4:	91 85       	ldd	r25, Z+9	; 0x09
     bd6:	38 01       	movw	r6, r16
     bd8:	68 1a       	sub	r6, r24
     bda:	79 0a       	sbc	r7, r25
     bdc:	c3 01       	movw	r24, r6
     bde:	77 fe       	sbrs	r7, 7
     be0:	03 c0       	rjmp	.+6      	; 0xbe8 <patt_match+0x9a>
     be2:	90 95       	com	r25
     be4:	81 95       	neg	r24
     be6:	9f 4f       	sbci	r25, 0xFF	; 255
     be8:	28 0f       	add	r18, r24
temp_val+=abs(alph[al_cnt][4]-samp[samp_cnt][4]);
     bea:	62 0f       	add	r22, r18

dist[samp_cnt][al_cnt]=temp_val;
     bec:	68 83       	st	Y, r22
     bee:	19 82       	std	Y+1, r1	; 0x01
     bf0:	3a 96       	adiw	r30, 0x0a	; 10
     bf2:	e4 96       	adiw	r28, 0x34	; 52
char fnd_char='*';

for(al_cnt=0;al_cnt<26;al_cnt++)//find distance for all characters
{

for(samp_cnt=0;samp_cnt<total_samples;samp_cnt++)
     bf4:	26 e0       	ldi	r18, 0x06	; 6
     bf6:	eb 3f       	cpi	r30, 0xFB	; 251
     bf8:	f2 07       	cpc	r31, r18
     bfa:	09 f0       	breq	.+2      	; 0xbfe <patt_match+0xb0>
     bfc:	bc cf       	rjmp	.-136    	; 0xb76 <patt_match+0x28>
     bfe:	4f 5f       	subi	r20, 0xFF	; 255
     c00:	5f 4f       	sbci	r21, 0xFF	; 255
     c02:	1a 96       	adiw	r26, 0x0a	; 10
char patt_match()
{
uint8_t  al_cnt=0,samp_cnt=0,match_fnd=0,tie=0,temp_val=0,min_val;
char fnd_char='*';

for(al_cnt=0;al_cnt<26;al_cnt++)//find distance for all characters
     c04:	4a 31       	cpi	r20, 0x1A	; 26
     c06:	51 05       	cpc	r21, r1
     c08:	d9 f0       	breq	.+54     	; 0xc40 <patt_match+0xf2>
{

for(samp_cnt=0;samp_cnt<total_samples;samp_cnt++)
{
temp_val+=abs(alph[al_cnt][0]-samp[samp_cnt][0]);
     c0a:	8d 90       	ld	r8, X+
     c0c:	9c 90       	ld	r9, X
     c0e:	11 97       	sbiw	r26, 0x01	; 1
temp_val+=abs(alph[al_cnt][1]-samp[samp_cnt][1]);
     c10:	12 96       	adiw	r26, 0x02	; 2
     c12:	ad 90       	ld	r10, X+
     c14:	bc 90       	ld	r11, X
     c16:	13 97       	sbiw	r26, 0x03	; 3
temp_val+=abs(alph[al_cnt][2]-samp[samp_cnt][2]);
     c18:	14 96       	adiw	r26, 0x04	; 4
     c1a:	cd 90       	ld	r12, X+
     c1c:	dc 90       	ld	r13, X
     c1e:	15 97       	sbiw	r26, 0x05	; 5
temp_val+=abs(alph[al_cnt][3]-samp[samp_cnt][3]);
     c20:	16 96       	adiw	r26, 0x06	; 6
     c22:	ed 90       	ld	r14, X+
     c24:	fc 90       	ld	r15, X
     c26:	17 97       	sbiw	r26, 0x07	; 7
temp_val+=abs(alph[al_cnt][4]-samp[samp_cnt][4]);
     c28:	18 96       	adiw	r26, 0x08	; 8
     c2a:	0d 91       	ld	r16, X+
     c2c:	1c 91       	ld	r17, X
     c2e:	19 97       	sbiw	r26, 0x09	; 9
     c30:	e7 e9       	ldi	r30, 0x97	; 151
     c32:	f6 e0       	ldi	r31, 0x06	; 6
     c34:	ea 01       	movw	r28, r20
     c36:	cc 0f       	add	r28, r28
     c38:	dd 1f       	adc	r29, r29
     c3a:	c3 57       	subi	r28, 0x73	; 115
     c3c:	db 4f       	sbci	r29, 0xFB	; 251
     c3e:	9b cf       	rjmp	.-202    	; 0xb76 <patt_match+0x28>

dist[samp_cnt][al_cnt]=temp_val;
}
}

min_val=dist[(total_samples/2)][0];
     c40:	00 91 91 05 	lds	r16, 0x0591
     c44:	60 91 70 03 	lds	r22, 0x0370
     c48:	70 91 71 03 	lds	r23, 0x0371
     c4c:	a3 e9       	ldi	r26, 0x93	; 147
     c4e:	b5 e0       	ldi	r27, 0x05	; 5
     c50:	e0 e0       	ldi	r30, 0x00	; 0
     c52:	41 e0       	ldi	r20, 0x01	; 1
     c54:	50 e0       	ldi	r21, 0x00	; 0

for(al_cnt=1;al_cnt<26;al_cnt++)//find minimum distance and also check for tie
{
if(dist[(total_samples/2)][al_cnt]<min_val)
     c56:	2d 91       	ld	r18, X+
     c58:	3c 91       	ld	r19, X
     c5a:	11 97       	sbiw	r26, 0x01	; 1
     c5c:	80 2f       	mov	r24, r16
     c5e:	90 e0       	ldi	r25, 0x00	; 0
     c60:	28 17       	cp	r18, r24
     c62:	39 07       	cpc	r19, r25
     c64:	40 f4       	brcc	.+16     	; 0xc76 <patt_match+0x128>
{
min_val=dist[(total_samples/2)][al_cnt];
     c66:	02 2f       	mov	r16, r18
tie=0;
min_cnt=0;
min_dist_index[min_cnt]=al_cnt;
     c68:	50 93 fe 06 	sts	0x06FE, r21
     c6c:	40 93 fd 06 	sts	0x06FD, r20
     c70:	e0 e0       	ldi	r30, 0x00	; 0
     c72:	60 e0       	ldi	r22, 0x00	; 0
     c74:	70 e0       	ldi	r23, 0x00	; 0
}

if(dist[(total_samples/2)][al_cnt]==min_val)
     c76:	80 2f       	mov	r24, r16
     c78:	90 e0       	ldi	r25, 0x00	; 0
     c7a:	28 17       	cp	r18, r24
     c7c:	39 07       	cpc	r19, r25
     c7e:	51 f4       	brne	.+20     	; 0xc94 <patt_match+0x146>
{min_dist_index[min_cnt]=al_cnt;tie=1;min_cnt++;}
     c80:	fb 01       	movw	r30, r22
     c82:	ee 0f       	add	r30, r30
     c84:	ff 1f       	adc	r31, r31
     c86:	e3 50       	subi	r30, 0x03	; 3
     c88:	f9 4f       	sbci	r31, 0xF9	; 249
     c8a:	51 83       	std	Z+1, r21	; 0x01
     c8c:	40 83       	st	Z, r20
     c8e:	6f 5f       	subi	r22, 0xFF	; 255
     c90:	7f 4f       	sbci	r23, 0xFF	; 255
     c92:	e1 e0       	ldi	r30, 0x01	; 1
     c94:	12 96       	adiw	r26, 0x02	; 2
     c96:	4f 5f       	subi	r20, 0xFF	; 255
     c98:	5f 4f       	sbci	r21, 0xFF	; 255
}
}

min_val=dist[(total_samples/2)][0];

for(al_cnt=1;al_cnt<26;al_cnt++)//find minimum distance and also check for tie
     c9a:	4a 31       	cpi	r20, 0x1A	; 26
     c9c:	51 05       	cpc	r21, r1
     c9e:	d9 f6       	brne	.-74     	; 0xc56 <patt_match+0x108>
     ca0:	60 93 70 03 	sts	0x0370, r22
     ca4:	70 93 71 03 	sts	0x0371, r23
if(dist[(total_samples/2)][al_cnt]==min_val)
{min_dist_index[min_cnt]=al_cnt;tie=1;min_cnt++;}
}

//calculate probability of certain match
if(tie==0)
     ca8:	ee 23       	and	r30, r30
     caa:	31 f0       	breq	.+12     	; 0xcb8 <patt_match+0x16a>
     cac:	a0 e0       	ldi	r26, 0x00	; 0
     cae:	30 e0       	ldi	r19, 0x00	; 0
     cb0:	1a e2       	ldi	r17, 0x2A	; 42
al_cnt=0;
while(al_cnt<=min_cnt)
{
for(samp_cnt=0;samp_cnt<total_samples;samp_cnt++)
{
if(dist[samp_cnt][min_dist_index[al_cnt]]<=min_val)
     cb2:	c0 2f       	mov	r28, r16
     cb4:	d0 e0       	ldi	r29, 0x00	; 0
     cb6:	2b c0       	rjmp	.+86     	; 0xd0e <patt_match+0x1c0>
//calculate probability of certain match
if(tie==0)
{
for(samp_cnt=0;samp_cnt<total_samples;samp_cnt++)
{
if(dist[samp_cnt][min_dist_index[0]]<=min_val)
     cb8:	60 91 fd 06 	lds	r22, 0x06FD
     cbc:	70 91 fe 06 	lds	r23, 0x06FE
     cc0:	fb 01       	movw	r30, r22
     cc2:	ee 0f       	add	r30, r30
     cc4:	ff 1f       	adc	r31, r31
     cc6:	e3 57       	subi	r30, 0x73	; 115
     cc8:	fb 4f       	sbci	r31, 0xFB	; 251
     cca:	30 e0       	ldi	r19, 0x00	; 0
     ccc:	20 e0       	ldi	r18, 0x00	; 0
     cce:	40 2f       	mov	r20, r16
     cd0:	50 e0       	ldi	r21, 0x00	; 0
     cd2:	80 81       	ld	r24, Z
     cd4:	91 81       	ldd	r25, Z+1	; 0x01
     cd6:	48 17       	cp	r20, r24
     cd8:	59 07       	cpc	r21, r25
     cda:	08 f0       	brcs	.+2      	; 0xcde <patt_match+0x190>
{match_fnd++;}
     cdc:	2f 5f       	subi	r18, 0xFF	; 255
}

//calculate probability of certain match
if(tie==0)
{
for(samp_cnt=0;samp_cnt<total_samples;samp_cnt++)
     cde:	3f 5f       	subi	r19, 0xFF	; 255
     ce0:	f4 96       	adiw	r30, 0x34	; 52
     ce2:	3a 30       	cpi	r19, 0x0A	; 10
     ce4:	b1 f7       	brne	.-20     	; 0xcd2 <patt_match+0x184>
{
if(dist[samp_cnt][min_dist_index[0]]<=min_val)
{match_fnd++;}
}
if(match_fnd>=8){fnd_char=(min_dist_index[0]+97);}
     ce6:	28 30       	cpi	r18, 0x08	; 8
     ce8:	20 f1       	brcs	.+72     	; 0xd32 <patt_match+0x1e4>
     cea:	16 2f       	mov	r17, r22
     cec:	1f 59       	subi	r17, 0x9F	; 159
     cee:	22 c0       	rjmp	.+68     	; 0xd34 <patt_match+0x1e6>
al_cnt=0;
while(al_cnt<=min_cnt)
{
for(samp_cnt=0;samp_cnt<total_samples;samp_cnt++)
{
if(dist[samp_cnt][min_dist_index[al_cnt]]<=min_val)
     cf0:	80 81       	ld	r24, Z
     cf2:	91 81       	ldd	r25, Z+1	; 0x01
     cf4:	c8 17       	cp	r28, r24
     cf6:	d9 07       	cpc	r29, r25
     cf8:	08 f0       	brcs	.+2      	; 0xcfc <patt_match+0x1ae>
{match_fnd++;}
     cfa:	3f 5f       	subi	r19, 0xFF	; 255
{

al_cnt=0;
while(al_cnt<=min_cnt)
{
for(samp_cnt=0;samp_cnt<total_samples;samp_cnt++)
     cfc:	2f 5f       	subi	r18, 0xFF	; 255
     cfe:	f4 96       	adiw	r30, 0x34	; 52
     d00:	2a 30       	cpi	r18, 0x0A	; 10
     d02:	b1 f7       	brne	.-20     	; 0xcf0 <patt_match+0x1a2>
{
if(dist[samp_cnt][min_dist_index[al_cnt]]<=min_val)
{match_fnd++;}
}

if(match_fnd>=8){fnd_char=(min_dist_index[al_cnt]+97);}
     d04:	38 30       	cpi	r19, 0x08	; 8
     d06:	10 f0       	brcs	.+4      	; 0xd0c <patt_match+0x1be>
     d08:	14 2f       	mov	r17, r20
     d0a:	1f 59       	subi	r17, 0x9F	; 159
al_cnt++;
     d0c:	af 5f       	subi	r26, 0xFF	; 255

else
{

al_cnt=0;
while(al_cnt<=min_cnt)
     d0e:	ea 2f       	mov	r30, r26
     d10:	f0 e0       	ldi	r31, 0x00	; 0
     d12:	6e 17       	cp	r22, r30
     d14:	7f 07       	cpc	r23, r31
     d16:	70 f0       	brcs	.+28     	; 0xd34 <patt_match+0x1e6>
{
for(samp_cnt=0;samp_cnt<total_samples;samp_cnt++)
{
if(dist[samp_cnt][min_dist_index[al_cnt]]<=min_val)
     d18:	ee 0f       	add	r30, r30
     d1a:	ff 1f       	adc	r31, r31
     d1c:	e3 50       	subi	r30, 0x03	; 3
     d1e:	f9 4f       	sbci	r31, 0xF9	; 249
     d20:	40 81       	ld	r20, Z
     d22:	51 81       	ldd	r21, Z+1	; 0x01
     d24:	fa 01       	movw	r30, r20
     d26:	ee 0f       	add	r30, r30
     d28:	ff 1f       	adc	r31, r31
     d2a:	e3 57       	subi	r30, 0x73	; 115
     d2c:	fb 4f       	sbci	r31, 0xFB	; 251
     d2e:	20 e0       	ldi	r18, 0x00	; 0
     d30:	df cf       	rjmp	.-66     	; 0xcf0 <patt_match+0x1a2>
     d32:	1a e2       	ldi	r17, 0x2A	; 42
}

//check for similar character signs whose real match gets confusing...
//use acclerometer reading to get out of this problem...!

if((fnd_char=='p')||(fnd_char=='q')||(fnd_char=='h')||(fnd_char=='k')||(fnd_char=='u'))
     d34:	81 2f       	mov	r24, r17
     d36:	80 57       	subi	r24, 0x70	; 112
     d38:	82 30       	cpi	r24, 0x02	; 2
     d3a:	30 f0       	brcs	.+12     	; 0xd48 <patt_match+0x1fa>
     d3c:	18 36       	cpi	r17, 0x68	; 104
     d3e:	21 f0       	breq	.+8      	; 0xd48 <patt_match+0x1fa>
     d40:	1b 36       	cpi	r17, 0x6B	; 107
     d42:	11 f0       	breq	.+4      	; 0xd48 <patt_match+0x1fa>
     d44:	15 37       	cpi	r17, 0x75	; 117
     d46:	f9 f4       	brne	.+62     	; 0xd86 <patt_match+0x238>
{
read_xyz();
     d48:	0e 94 27 04 	call	0x84e	; 0x84e <read_xyz>
if((xa>320)&&(ya<280)){return 'h';}
     d4c:	20 91 58 07 	lds	r18, 0x0758
     d50:	30 91 59 07 	lds	r19, 0x0759
     d54:	41 e0       	ldi	r20, 0x01	; 1
     d56:	21 34       	cpi	r18, 0x41	; 65
     d58:	34 07       	cpc	r19, r20
     d5a:	48 f0       	brcs	.+18     	; 0xd6e <patt_match+0x220>
     d5c:	80 91 5a 07 	lds	r24, 0x075A
     d60:	90 91 5b 07 	lds	r25, 0x075B
     d64:	88 51       	subi	r24, 0x18	; 24
     d66:	91 40       	sbci	r25, 0x01	; 1
     d68:	10 f4       	brcc	.+4      	; 0xd6e <patt_match+0x220>
     d6a:	18 e6       	ldi	r17, 0x68	; 104
     d6c:	39 c0       	rjmp	.+114    	; 0xde0 <patt_match+0x292>
else if((xa<280)&&(ya>315)) {return 'k';}
     d6e:	28 51       	subi	r18, 0x18	; 24
     d70:	31 40       	sbci	r19, 0x01	; 1
     d72:	b0 f5       	brcc	.+108    	; 0xde0 <patt_match+0x292>
     d74:	80 91 5a 07 	lds	r24, 0x075A
     d78:	90 91 5b 07 	lds	r25, 0x075B
     d7c:	8c 53       	subi	r24, 0x3C	; 60
     d7e:	91 40       	sbci	r25, 0x01	; 1
     d80:	78 f1       	brcs	.+94     	; 0xde0 <patt_match+0x292>
     d82:	1b e6       	ldi	r17, 0x6B	; 107
     d84:	2d c0       	rjmp	.+90     	; 0xde0 <patt_match+0x292>
else if((xa>310)&&(ya>310)) {return fnd_char;}
}

else if((fnd_char=='i')||(fnd_char=='j'))
     d86:	81 2f       	mov	r24, r17
     d88:	89 56       	subi	r24, 0x69	; 105
     d8a:	82 30       	cpi	r24, 0x02	; 2
     d8c:	90 f4       	brcc	.+36     	; 0xdb2 <patt_match+0x264>
{
read_xyz();
     d8e:	0e 94 27 04 	call	0x84e	; 0x84e <read_xyz>
if((xa>320)&&(ya<280)){return 'j';}
     d92:	80 91 58 07 	lds	r24, 0x0758
     d96:	90 91 59 07 	lds	r25, 0x0759
     d9a:	81 54       	subi	r24, 0x41	; 65
     d9c:	91 40       	sbci	r25, 0x01	; 1
     d9e:	f8 f0       	brcs	.+62     	; 0xdde <patt_match+0x290>
     da0:	80 91 5a 07 	lds	r24, 0x075A
     da4:	90 91 5b 07 	lds	r25, 0x075B
     da8:	88 51       	subi	r24, 0x18	; 24
     daa:	91 40       	sbci	r25, 0x01	; 1
     dac:	c0 f4       	brcc	.+48     	; 0xdde <patt_match+0x290>
     dae:	1a e6       	ldi	r17, 0x6A	; 106
     db0:	17 c0       	rjmp	.+46     	; 0xde0 <patt_match+0x292>
else return 'i';
}

else if((fnd_char=='d')||(fnd_char=='z'))
     db2:	14 36       	cpi	r17, 0x64	; 100
     db4:	11 f0       	breq	.+4      	; 0xdba <patt_match+0x26c>
     db6:	1a 37       	cpi	r17, 0x7A	; 122
     db8:	99 f4       	brne	.+38     	; 0xde0 <patt_match+0x292>
{
read_xyz();
     dba:	0e 94 27 04 	call	0x84e	; 0x84e <read_xyz>
if((xa>310)&&(ya>310)){return 'z';}
     dbe:	80 91 58 07 	lds	r24, 0x0758
     dc2:	90 91 59 07 	lds	r25, 0x0759
     dc6:	87 53       	subi	r24, 0x37	; 55
     dc8:	91 40       	sbci	r25, 0x01	; 1
     dca:	50 f0       	brcs	.+20     	; 0xde0 <patt_match+0x292>
     dcc:	80 91 5a 07 	lds	r24, 0x075A
     dd0:	90 91 5b 07 	lds	r25, 0x075B
     dd4:	87 53       	subi	r24, 0x37	; 55
     dd6:	91 40       	sbci	r25, 0x01	; 1
     dd8:	18 f0       	brcs	.+6      	; 0xde0 <patt_match+0x292>
     dda:	1a e7       	ldi	r17, 0x7A	; 122
     ddc:	01 c0       	rjmp	.+2      	; 0xde0 <patt_match+0x292>
     dde:	19 e6       	ldi	r17, 0x69	; 105
}

return fnd_char;

}
     de0:	81 2f       	mov	r24, r17
     de2:	df 91       	pop	r29
     de4:	cf 91       	pop	r28
     de6:	1f 91       	pop	r17
     de8:	0f 91       	pop	r16
     dea:	ff 90       	pop	r15
     dec:	ef 90       	pop	r14
     dee:	df 90       	pop	r13
     df0:	cf 90       	pop	r12
     df2:	bf 90       	pop	r11
     df4:	af 90       	pop	r10
     df6:	9f 90       	pop	r9
     df8:	8f 90       	pop	r8
     dfa:	7f 90       	pop	r7
     dfc:	6f 90       	pop	r6
     dfe:	08 95       	ret

00000e00 <take_samples>:

void take_samples()//take multiple samples and average
{
     e00:	8f 92       	push	r8
     e02:	9f 92       	push	r9
     e04:	af 92       	push	r10
     e06:	bf 92       	push	r11
     e08:	cf 92       	push	r12
     e0a:	df 92       	push	r13
     e0c:	ef 92       	push	r14
     e0e:	ff 92       	push	r15
     e10:	0f 93       	push	r16
     e12:	1f 93       	push	r17
     e14:	cf 93       	push	r28
     e16:	df 93       	push	r29
     e18:	e7 e9       	ldi	r30, 0x97	; 151
     e1a:	f6 e0       	ldi	r31, 0x06	; 6
     e1c:	cc 24       	eor	r12, r12
     e1e:	dd 24       	eor	r13, r13
     e20:	ee 24       	eor	r14, r14
     e22:	ff 24       	eor	r15, r15
     e24:	00 e0       	ldi	r16, 0x00	; 0
     e26:	10 e0       	ldi	r17, 0x00	; 0
     e28:	c0 e0       	ldi	r28, 0x00	; 0
     e2a:	d0 e0       	ldi	r29, 0x00	; 0
     e2c:	20 e0       	ldi	r18, 0x00	; 0
     e2e:	30 e0       	ldi	r19, 0x00	; 0
   //Select ADC Channel ch must be 0-7 (corresponds to the flex sensors...)
   //flex sensors from channel 0-4
   //acccelerometer from channel 5-7
   
   //ch=ch & 0b00000111;
   ADMUX = ch;
     e30:	88 24       	eor	r8, r8
     e32:	83 94       	inc	r8

   //Start Single conversion
   ADCSRA|=(1<<ADSC);
     e34:	62 e0       	ldi	r22, 0x02	; 2
     e36:	96 2e       	mov	r9, r22
     e38:	53 e0       	ldi	r21, 0x03	; 3
     e3a:	a5 2e       	mov	r10, r21
     e3c:	44 e0       	ldi	r20, 0x04	; 4
     e3e:	b4 2e       	mov	r11, r20
     e40:	58 c0       	rjmp	.+176    	; 0xef2 <take_samples+0xf2>
     e42:	17 b8       	out	0x07, r1	; 7
     e44:	36 9a       	sbi	0x06, 6	; 6

   //Wait for conversion to complete
   while(!(ADCSRA & (1<<ADIF)));
     e46:	34 9b       	sbis	0x06, 4	; 6
     e48:	fe cf       	rjmp	.-4      	; 0xe46 <take_samples+0x46>

   //Clear ADIF by writing one to it
   ADCSRA|=(1<<ADIF);
     e4a:	34 9a       	sbi	0x06, 4	; 6

   return(ADCW);
     e4c:	84 b1       	in	r24, 0x04	; 4
     e4e:	95 b1       	in	r25, 0x05	; 5

for(samp_cnt=0;samp_cnt<total_samples;samp_cnt++)
{
for(avg=0;avg<avg_total;avg++)
{
v0 +=read_adc(0);
     e50:	e8 0e       	add	r14, r24
     e52:	f9 1e       	adc	r15, r25
   //Select ADC Channel ch must be 0-7 (corresponds to the flex sensors...)
   //flex sensors from channel 0-4
   //acccelerometer from channel 5-7
   
   //ch=ch & 0b00000111;
   ADMUX = ch;
     e54:	87 b8       	out	0x07, r8	; 7

   //Start Single conversion
   ADCSRA|=(1<<ADSC);
     e56:	36 9a       	sbi	0x06, 6	; 6

   //Wait for conversion to complete
   while(!(ADCSRA & (1<<ADIF)));
     e58:	34 9b       	sbis	0x06, 4	; 6
     e5a:	fe cf       	rjmp	.-4      	; 0xe58 <take_samples+0x58>

   //Clear ADIF by writing one to it
   ADCSRA|=(1<<ADIF);
     e5c:	34 9a       	sbi	0x06, 4	; 6

   return(ADCW);
     e5e:	84 b1       	in	r24, 0x04	; 4
     e60:	95 b1       	in	r25, 0x05	; 5
v1 +=read_adc(1);
     e62:	08 0f       	add	r16, r24
     e64:	19 1f       	adc	r17, r25
   //Select ADC Channel ch must be 0-7 (corresponds to the flex sensors...)
   //flex sensors from channel 0-4
   //acccelerometer from channel 5-7
   
   //ch=ch & 0b00000111;
   ADMUX = ch;
     e66:	97 b8       	out	0x07, r9	; 7

   //Start Single conversion
   ADCSRA|=(1<<ADSC);
     e68:	36 9a       	sbi	0x06, 6	; 6

   //Wait for conversion to complete
   while(!(ADCSRA & (1<<ADIF)));
     e6a:	34 9b       	sbis	0x06, 4	; 6
     e6c:	fe cf       	rjmp	.-4      	; 0xe6a <take_samples+0x6a>

   //Clear ADIF by writing one to it
   ADCSRA|=(1<<ADIF);
     e6e:	34 9a       	sbi	0x06, 4	; 6

   return(ADCW);
     e70:	84 b1       	in	r24, 0x04	; 4
     e72:	95 b1       	in	r25, 0x05	; 5
v2 +=read_adc(2);
     e74:	c8 0f       	add	r28, r24
     e76:	d9 1f       	adc	r29, r25
   //Select ADC Channel ch must be 0-7 (corresponds to the flex sensors...)
   //flex sensors from channel 0-4
   //acccelerometer from channel 5-7
   
   //ch=ch & 0b00000111;
   ADMUX = ch;
     e78:	a7 b8       	out	0x07, r10	; 7

   //Start Single conversion
   ADCSRA|=(1<<ADSC);
     e7a:	36 9a       	sbi	0x06, 6	; 6

   //Wait for conversion to complete
   while(!(ADCSRA & (1<<ADIF)));
     e7c:	34 9b       	sbis	0x06, 4	; 6
     e7e:	fe cf       	rjmp	.-4      	; 0xe7c <take_samples+0x7c>

   //Clear ADIF by writing one to it
   ADCSRA|=(1<<ADIF);
     e80:	34 9a       	sbi	0x06, 4	; 6

   return(ADCW);
     e82:	84 b1       	in	r24, 0x04	; 4
     e84:	95 b1       	in	r25, 0x05	; 5
v3 +=read_adc(3);
     e86:	28 0f       	add	r18, r24
     e88:	39 1f       	adc	r19, r25
   //Select ADC Channel ch must be 0-7 (corresponds to the flex sensors...)
   //flex sensors from channel 0-4
   //acccelerometer from channel 5-7
   
   //ch=ch & 0b00000111;
   ADMUX = ch;
     e8a:	b7 b8       	out	0x07, r11	; 7

   //Start Single conversion
   ADCSRA|=(1<<ADSC);
     e8c:	36 9a       	sbi	0x06, 6	; 6

   //Wait for conversion to complete
   while(!(ADCSRA & (1<<ADIF)));
     e8e:	34 9b       	sbis	0x06, 4	; 6
     e90:	fe cf       	rjmp	.-4      	; 0xe8e <take_samples+0x8e>

   //Clear ADIF by writing one to it
   ADCSRA|=(1<<ADIF);
     e92:	34 9a       	sbi	0x06, 4	; 6

   return(ADCW);
     e94:	84 b1       	in	r24, 0x04	; 4
     e96:	95 b1       	in	r25, 0x05	; 5
v4 +=read_adc(4);
     e98:	c8 0e       	add	r12, r24
     e9a:	d9 1e       	adc	r13, r25
uint8_t samp_cnt,avg;
uint16_t v0=0,v1=0,v2=0,v3=0,v4=0;

for(samp_cnt=0;samp_cnt<total_samples;samp_cnt++)
{
for(avg=0;avg<avg_total;avg++)
     e9c:	4f 5f       	subi	r20, 0xFF	; 255
     e9e:	4a 30       	cpi	r20, 0x0A	; 10
     ea0:	81 f6       	brne	.-96     	; 0xe42 <take_samples+0x42>
v2 +=read_adc(2);
v3 +=read_adc(3);
v4 +=read_adc(4);
}

samp[samp_cnt][0]=(uint16_t)(v0/avg_total);
     ea2:	c7 01       	movw	r24, r14
     ea4:	6a e0       	ldi	r22, 0x0A	; 10
     ea6:	70 e0       	ldi	r23, 0x00	; 0
     ea8:	0e 94 f3 0d 	call	0x1be6	; 0x1be6 <__udivmodhi4>
     eac:	71 83       	std	Z+1, r23	; 0x01
     eae:	60 83       	st	Z, r22
samp[samp_cnt][1]=(uint16_t)(v1/avg_total);
     eb0:	c8 01       	movw	r24, r16
     eb2:	6a e0       	ldi	r22, 0x0A	; 10
     eb4:	70 e0       	ldi	r23, 0x00	; 0
     eb6:	0e 94 f3 0d 	call	0x1be6	; 0x1be6 <__udivmodhi4>
     eba:	73 83       	std	Z+3, r23	; 0x03
     ebc:	62 83       	std	Z+2, r22	; 0x02
samp[samp_cnt][2]=(uint16_t)(v2/avg_total);
     ebe:	ce 01       	movw	r24, r28
     ec0:	6a e0       	ldi	r22, 0x0A	; 10
     ec2:	70 e0       	ldi	r23, 0x00	; 0
     ec4:	0e 94 f3 0d 	call	0x1be6	; 0x1be6 <__udivmodhi4>
     ec8:	75 83       	std	Z+5, r23	; 0x05
     eca:	64 83       	std	Z+4, r22	; 0x04
samp[samp_cnt][3]=(uint16_t)(v3/avg_total);
     ecc:	c9 01       	movw	r24, r18
     ece:	6a e0       	ldi	r22, 0x0A	; 10
     ed0:	70 e0       	ldi	r23, 0x00	; 0
     ed2:	0e 94 f3 0d 	call	0x1be6	; 0x1be6 <__udivmodhi4>
     ed6:	77 83       	std	Z+7, r23	; 0x07
     ed8:	66 83       	std	Z+6, r22	; 0x06
samp[samp_cnt][4]=(uint16_t)(v4/avg_total);
     eda:	c6 01       	movw	r24, r12
     edc:	6a e0       	ldi	r22, 0x0A	; 10
     ede:	70 e0       	ldi	r23, 0x00	; 0
     ee0:	0e 94 f3 0d 	call	0x1be6	; 0x1be6 <__udivmodhi4>
     ee4:	71 87       	std	Z+9, r23	; 0x09
     ee6:	60 87       	std	Z+8, r22	; 0x08
     ee8:	3a 96       	adiw	r30, 0x0a	; 10
void take_samples()//take multiple samples and average
{
uint8_t samp_cnt,avg;
uint16_t v0=0,v1=0,v2=0,v3=0,v4=0;

for(samp_cnt=0;samp_cnt<total_samples;samp_cnt++)
     eea:	86 e0       	ldi	r24, 0x06	; 6
     eec:	eb 3f       	cpi	r30, 0xFB	; 251
     eee:	f8 07       	cpc	r31, r24
     ef0:	11 f0       	breq	.+4      	; 0xef6 <take_samples+0xf6>
     ef2:	40 e0       	ldi	r20, 0x00	; 0
     ef4:	a6 cf       	rjmp	.-180    	; 0xe42 <take_samples+0x42>
samp[samp_cnt][1]=(uint16_t)(v1/avg_total);
samp[samp_cnt][2]=(uint16_t)(v2/avg_total);
samp[samp_cnt][3]=(uint16_t)(v3/avg_total);
samp[samp_cnt][4]=(uint16_t)(v4/avg_total);
}
}
     ef6:	df 91       	pop	r29
     ef8:	cf 91       	pop	r28
     efa:	1f 91       	pop	r17
     efc:	0f 91       	pop	r16
     efe:	ff 90       	pop	r15
     f00:	ef 90       	pop	r14
     f02:	df 90       	pop	r13
     f04:	cf 90       	pop	r12
     f06:	bf 90       	pop	r11
     f08:	af 90       	pop	r10
     f0a:	9f 90       	pop	r9
     f0c:	8f 90       	pop	r8
     f0e:	08 95       	ret

00000f10 <char_disp>:
ya=read_adc(6);
za=read_adc(7);
}

void char_disp()//function for only normal character display
{
     f10:	1f 93       	push	r17
     f12:	cf 93       	push	r28
     f14:	df 93       	push	r29

key=key_read();
     f16:	0e 94 7a 00 	call	0xf4	; 0xf4 <key_read>
     f1a:	80 93 50 07 	sts	0x0750, r24
   //Select ADC Channel ch must be 0-7 (corresponds to the flex sensors...)
   //flex sensors from channel 0-4
   //acccelerometer from channel 5-7
   
   //ch=ch & 0b00000111;
   ADMUX = ch;
     f1e:	17 e0       	ldi	r17, 0x07	; 7
     f20:	12 c0       	rjmp	.+36     	; 0xf46 <char_disp+0x36>
while(key=='/'){key=key_read();if(read_adc(7)>alp_puts){key='*';break;}}
     f22:	0e 94 7a 00 	call	0xf4	; 0xf4 <key_read>
     f26:	80 93 50 07 	sts	0x0750, r24
     f2a:	17 b9       	out	0x07, r17	; 7

   //Start Single conversion
   ADCSRA|=(1<<ADSC);
     f2c:	36 9a       	sbi	0x06, 6	; 6

   //Wait for conversion to complete
   while(!(ADCSRA & (1<<ADIF)));
     f2e:	34 9b       	sbis	0x06, 4	; 6
     f30:	fe cf       	rjmp	.-4      	; 0xf2e <char_disp+0x1e>

   //Clear ADIF by writing one to it
   ADCSRA|=(1<<ADIF);
     f32:	34 9a       	sbi	0x06, 4	; 6

   return(ADCW);
     f34:	84 b1       	in	r24, 0x04	; 4
     f36:	95 b1       	in	r25, 0x05	; 5
     f38:	87 5d       	subi	r24, 0xD7	; 215
     f3a:	91 40       	sbci	r25, 0x01	; 1
     f3c:	20 f0       	brcs	.+8      	; 0xf46 <char_disp+0x36>
     f3e:	8a e2       	ldi	r24, 0x2A	; 42
     f40:	80 93 50 07 	sts	0x0750, r24
     f44:	04 c0       	rjmp	.+8      	; 0xf4e <char_disp+0x3e>
     f46:	80 91 50 07 	lds	r24, 0x0750
     f4a:	8f 32       	cpi	r24, 0x2F	; 47
     f4c:	51 f3       	breq	.-44     	; 0xf22 <char_disp+0x12>

if(key=='*')    //normal small characters
     f4e:	80 91 50 07 	lds	r24, 0x0750
     f52:	8a 32       	cpi	r24, 0x2A	; 42
     f54:	71 f5       	brne	.+92     	; 0xfb2 <char_disp+0xa2>
     f56:	e7 e9       	ldi	r30, 0x97	; 151
     f58:	f6 e0       	ldi	r31, 0x06	; 6

uint8_t cnt;

for(cnt=0;cnt<total_samples;cnt++)
{
samp[cnt][0]=0;
     f5a:	11 82       	std	Z+1, r1	; 0x01
     f5c:	10 82       	st	Z, r1
samp[cnt][1]=0;
     f5e:	13 82       	std	Z+3, r1	; 0x03
     f60:	12 82       	std	Z+2, r1	; 0x02
samp[cnt][2]=0;
     f62:	15 82       	std	Z+5, r1	; 0x05
     f64:	14 82       	std	Z+4, r1	; 0x04
samp[cnt][3]=0;
     f66:	17 82       	std	Z+7, r1	; 0x07
     f68:	16 82       	std	Z+6, r1	; 0x06
samp[cnt][4]=0;
     f6a:	11 86       	std	Z+9, r1	; 0x09
     f6c:	10 86       	std	Z+8, r1	; 0x08
     f6e:	3a 96       	adiw	r30, 0x0a	; 10
void init_array()
{

uint8_t cnt;

for(cnt=0;cnt<total_samples;cnt++)
     f70:	86 e0       	ldi	r24, 0x06	; 6
     f72:	eb 3f       	cpi	r30, 0xFB	; 251
     f74:	f8 07       	cpc	r31, r24
     f76:	89 f7       	brne	.-30     	; 0xf5a <char_disp+0x4a>
     f78:	e6 e3       	ldi	r30, 0x36	; 54
     f7a:	f7 e0       	ldi	r31, 0x07	; 7
alph[cnt][3]=0;
alph[cnt][4]=0;
}
*/

for(cnt=0;cnt<26;cnt++){prob[cnt]=0;}
     f7c:	11 92       	st	Z+, r1
     f7e:	27 e0       	ldi	r18, 0x07	; 7
     f80:	e0 35       	cpi	r30, 0x50	; 80
     f82:	f2 07       	cpc	r31, r18
     f84:	d9 f7       	brne	.-10     	; 0xf7c <char_disp+0x6c>

if(key=='*')    //normal small characters
{
init_array();
//load_val();
take_samples();
     f86:	0e 94 00 07 	call	0xe00	; 0xe00 <take_samples>
matched_char = patt_match();
     f8a:	0e 94 a7 05 	call	0xb4e	; 0xb4e <patt_match>
     f8e:	98 2f       	mov	r25, r24
     f90:	80 93 8a 04 	sts	0x048A, r24
if(matched_char!='*')
     f94:	8a 32       	cpi	r24, 0x2A	; 42
     f96:	69 f0       	breq	.+26     	; 0xfb2 <char_disp+0xa2>
{
txBuffer[1]=0x0C;
     f98:	8c e0       	ldi	r24, 0x0C	; 12
     f9a:	80 93 52 07 	sts	0x0752, r24
txBuffer[2]=matched_char;
     f9e:	90 93 53 07 	sts	0x0753, r25
txBuffer[3]=0x00;
     fa2:	10 92 54 07 	sts	0x0754, r1
txBuffer[4]=0x00;
     fa6:	10 92 55 07 	sts	0x0755, r1
txBuffer[5]=0x00;
     faa:	10 92 56 07 	sts	0x0756, r1
data_tx();
     fae:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <data_tx>
//_delay_ms(keypress-50);
}
}

if(key=='7') //for capital characters
     fb2:	80 91 50 07 	lds	r24, 0x0750
     fb6:	87 33       	cpi	r24, 0x37	; 55
     fb8:	79 f5       	brne	.+94     	; 0x1018 <char_disp+0x108>
     fba:	e7 e9       	ldi	r30, 0x97	; 151
     fbc:	f6 e0       	ldi	r31, 0x06	; 6

uint8_t cnt;

for(cnt=0;cnt<total_samples;cnt++)
{
samp[cnt][0]=0;
     fbe:	11 82       	std	Z+1, r1	; 0x01
     fc0:	10 82       	st	Z, r1
samp[cnt][1]=0;
     fc2:	13 82       	std	Z+3, r1	; 0x03
     fc4:	12 82       	std	Z+2, r1	; 0x02
samp[cnt][2]=0;
     fc6:	15 82       	std	Z+5, r1	; 0x05
     fc8:	14 82       	std	Z+4, r1	; 0x04
samp[cnt][3]=0;
     fca:	17 82       	std	Z+7, r1	; 0x07
     fcc:	16 82       	std	Z+6, r1	; 0x06
samp[cnt][4]=0;
     fce:	11 86       	std	Z+9, r1	; 0x09
     fd0:	10 86       	std	Z+8, r1	; 0x08
     fd2:	3a 96       	adiw	r30, 0x0a	; 10
void init_array()
{

uint8_t cnt;

for(cnt=0;cnt<total_samples;cnt++)
     fd4:	86 e0       	ldi	r24, 0x06	; 6
     fd6:	eb 3f       	cpi	r30, 0xFB	; 251
     fd8:	f8 07       	cpc	r31, r24
     fda:	89 f7       	brne	.-30     	; 0xfbe <char_disp+0xae>
     fdc:	e6 e3       	ldi	r30, 0x36	; 54
     fde:	f7 e0       	ldi	r31, 0x07	; 7
alph[cnt][3]=0;
alph[cnt][4]=0;
}
*/

for(cnt=0;cnt<26;cnt++){prob[cnt]=0;}
     fe0:	11 92       	st	Z+, r1
     fe2:	27 e0       	ldi	r18, 0x07	; 7
     fe4:	e0 35       	cpi	r30, 0x50	; 80
     fe6:	f2 07       	cpc	r31, r18
     fe8:	d9 f7       	brne	.-10     	; 0xfe0 <char_disp+0xd0>
}

if(key=='7') //for capital characters
{
init_array();
take_samples();
     fea:	0e 94 00 07 	call	0xe00	; 0xe00 <take_samples>
matched_char = patt_match();
     fee:	0e 94 a7 05 	call	0xb4e	; 0xb4e <patt_match>
     ff2:	98 2f       	mov	r25, r24
     ff4:	80 93 8a 04 	sts	0x048A, r24
if(matched_char!='*')
     ff8:	8a 32       	cpi	r24, 0x2A	; 42
     ffa:	71 f0       	breq	.+28     	; 0x1018 <char_disp+0x108>
{
txBuffer[1]=0x0C;
     ffc:	8c e0       	ldi	r24, 0x0C	; 12
     ffe:	80 93 52 07 	sts	0x0752, r24
txBuffer[2]=(matched_char-32);
    1002:	90 52       	subi	r25, 0x20	; 32
    1004:	90 93 53 07 	sts	0x0753, r25
txBuffer[3]=0x00;
    1008:	10 92 54 07 	sts	0x0754, r1
txBuffer[4]=0x00;
    100c:	10 92 55 07 	sts	0x0755, r1
txBuffer[5]=0x00;
    1010:	10 92 56 07 	sts	0x0756, r1
data_tx();
    1014:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <data_tx>
//_delay_ms(keypress-50);
}
}

if(key=='0')
    1018:	80 91 50 07 	lds	r24, 0x0750
    101c:	80 33       	cpi	r24, 0x30	; 48
    101e:	b9 f4       	brne	.+46     	; 0x104e <char_disp+0x13e>
{
txBuffer[1]=0x0C;
    1020:	8c e0       	ldi	r24, 0x0C	; 12
    1022:	80 93 52 07 	sts	0x0752, r24
txBuffer[2]=32;//space
    1026:	80 e2       	ldi	r24, 0x20	; 32
    1028:	80 93 53 07 	sts	0x0753, r24
txBuffer[3]=0x00;
    102c:	10 92 54 07 	sts	0x0754, r1
txBuffer[4]=0x00;
    1030:	10 92 55 07 	sts	0x0755, r1
txBuffer[5]=0x00;
    1034:	10 92 56 07 	sts	0x0756, r1
data_tx();
    1038:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <data_tx>
    103c:	88 eb       	ldi	r24, 0xB8	; 184
    103e:	9b e0       	ldi	r25, 0x0B	; 11
    1040:	20 e9       	ldi	r18, 0x90	; 144
    1042:	31 e0       	ldi	r19, 0x01	; 1
    1044:	f9 01       	movw	r30, r18
    1046:	31 97       	sbiw	r30, 0x01	; 1
    1048:	f1 f7       	brne	.-4      	; 0x1046 <char_disp+0x136>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    104a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    104c:	d9 f7       	brne	.-10     	; 0x1044 <char_disp+0x134>
_delay_ms(keypress);
}

if(key=='1') //backspace and clear screen
    104e:	80 91 50 07 	lds	r24, 0x0750
    1052:	81 33       	cpi	r24, 0x31	; 49
    1054:	09 f0       	breq	.+2      	; 0x1058 <char_disp+0x148>
    1056:	45 c0       	rjmp	.+138    	; 0x10e2 <char_disp+0x1d2>
{
bksp_cnt=0;
    1058:	10 92 75 03 	sts	0x0375, r1
txBuffer[1]=0x0B;
    105c:	8b e0       	ldi	r24, 0x0B	; 11
    105e:	80 93 52 07 	sts	0x0752, r24
txBuffer[2]=0x00; 
    1062:	10 92 53 07 	sts	0x0753, r1
txBuffer[3]=0x00;
    1066:	10 92 54 07 	sts	0x0754, r1
txBuffer[4]=0x00;
    106a:	10 92 55 07 	sts	0x0755, r1
txBuffer[5]=0x00;
    106e:	10 92 56 07 	sts	0x0756, r1
data_tx();
    1072:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <data_tx>
    1076:	88 eb       	ldi	r24, 0xB8	; 184
    1078:	9b e0       	ldi	r25, 0x0B	; 11
    107a:	20 e9       	ldi	r18, 0x90	; 144
    107c:	31 e0       	ldi	r19, 0x01	; 1
    107e:	f9 01       	movw	r30, r18
    1080:	31 97       	sbiw	r30, 0x01	; 1
    1082:	f1 f7       	brne	.-4      	; 0x1080 <char_disp+0x170>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1084:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1086:	d9 f7       	brne	.-10     	; 0x107e <char_disp+0x16e>
_delay_ms(keypress);

//clear screen if key 1 is pressed for more than 1 second
key=key_read();
    1088:	0e 94 7a 00 	call	0xf4	; 0xf4 <key_read>
    108c:	80 93 50 07 	sts	0x0750, r24
    1090:	c0 e9       	ldi	r28, 0x90	; 144
    1092:	d1 e0       	ldi	r29, 0x01	; 1
    1094:	22 c0       	rjmp	.+68     	; 0x10da <char_disp+0x1ca>
while(key=='1'){
bksp_cnt++;
    1096:	80 91 75 03 	lds	r24, 0x0375
    109a:	8f 5f       	subi	r24, 0xFF	; 255
    109c:	80 93 75 03 	sts	0x0375, r24
key=key_read();
    10a0:	0e 94 7a 00 	call	0xf4	; 0xf4 <key_read>
    10a4:	80 93 50 07 	sts	0x0750, r24
    10a8:	88 ee       	ldi	r24, 0xE8	; 232
    10aa:	93 e0       	ldi	r25, 0x03	; 3
    10ac:	fe 01       	movw	r30, r28
    10ae:	31 97       	sbiw	r30, 0x01	; 1
    10b0:	f1 f7       	brne	.-4      	; 0x10ae <char_disp+0x19e>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    10b2:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    10b4:	d9 f7       	brne	.-10     	; 0x10ac <char_disp+0x19c>
_delay_ms(100);
if(bksp_cnt>10)
    10b6:	80 91 75 03 	lds	r24, 0x0375
    10ba:	8b 30       	cpi	r24, 0x0B	; 11
    10bc:	70 f0       	brcs	.+28     	; 0x10da <char_disp+0x1ca>
{
txBuffer[1]=0xAC;
    10be:	8c ea       	ldi	r24, 0xAC	; 172
    10c0:	80 93 52 07 	sts	0x0752, r24
txBuffer[2]=0x00; 
    10c4:	10 92 53 07 	sts	0x0753, r1
txBuffer[3]=0x00;
    10c8:	10 92 54 07 	sts	0x0754, r1
txBuffer[4]=0x00;
    10cc:	10 92 55 07 	sts	0x0755, r1
txBuffer[5]=0x00;
    10d0:	10 92 56 07 	sts	0x0756, r1
data_tx();
    10d4:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <data_tx>
    10d8:	04 c0       	rjmp	.+8      	; 0x10e2 <char_disp+0x1d2>
data_tx();
_delay_ms(keypress);

//clear screen if key 1 is pressed for more than 1 second
key=key_read();
while(key=='1'){
    10da:	80 91 50 07 	lds	r24, 0x0750
    10de:	81 33       	cpi	r24, 0x31	; 49
    10e0:	d1 f2       	breq	.-76     	; 0x1096 <char_disp+0x186>
data_tx();
_delay_ms(keypress);
}
*/

if(key=='9')//EXIT.... go out of sub menu to main menu
    10e2:	80 91 50 07 	lds	r24, 0x0750
    10e6:	89 33       	cpi	r24, 0x39	; 57
    10e8:	19 f4       	brne	.+6      	; 0x10f0 <char_disp+0x1e0>
{
menu_select=0;
    10ea:	10 92 73 03 	sts	0x0373, r1
    10ee:	04 c0       	rjmp	.+8      	; 0x10f8 <char_disp+0x1e8>
}      

if(key=='#'){submenu_select=0;}
    10f0:	83 32       	cpi	r24, 0x23	; 35
    10f2:	11 f4       	brne	.+4      	; 0x10f8 <char_disp+0x1e8>
    10f4:	10 92 74 03 	sts	0x0374, r1

}
    10f8:	df 91       	pop	r29
    10fa:	cf 91       	pop	r28
    10fc:	1f 91       	pop	r17
    10fe:	08 95       	ret

00001100 <init_array>:
}
}


void init_array()
{
    1100:	e7 e9       	ldi	r30, 0x97	; 151
    1102:	f6 e0       	ldi	r31, 0x06	; 6

uint8_t cnt;

for(cnt=0;cnt<total_samples;cnt++)
{
samp[cnt][0]=0;
    1104:	11 82       	std	Z+1, r1	; 0x01
    1106:	10 82       	st	Z, r1
samp[cnt][1]=0;
    1108:	13 82       	std	Z+3, r1	; 0x03
    110a:	12 82       	std	Z+2, r1	; 0x02
samp[cnt][2]=0;
    110c:	15 82       	std	Z+5, r1	; 0x05
    110e:	14 82       	std	Z+4, r1	; 0x04
samp[cnt][3]=0;
    1110:	17 82       	std	Z+7, r1	; 0x07
    1112:	16 82       	std	Z+6, r1	; 0x06
samp[cnt][4]=0;
    1114:	11 86       	std	Z+9, r1	; 0x09
    1116:	10 86       	std	Z+8, r1	; 0x08
    1118:	3a 96       	adiw	r30, 0x0a	; 10
void init_array()
{

uint8_t cnt;

for(cnt=0;cnt<total_samples;cnt++)
    111a:	86 e0       	ldi	r24, 0x06	; 6
    111c:	eb 3f       	cpi	r30, 0xFB	; 251
    111e:	f8 07       	cpc	r31, r24
    1120:	89 f7       	brne	.-30     	; 0x1104 <init_array+0x4>
    1122:	e6 e3       	ldi	r30, 0x36	; 54
    1124:	f7 e0       	ldi	r31, 0x07	; 7
alph[cnt][3]=0;
alph[cnt][4]=0;
}
*/

for(cnt=0;cnt<26;cnt++){prob[cnt]=0;}
    1126:	11 92       	st	Z+, r1
    1128:	87 e0       	ldi	r24, 0x07	; 7
    112a:	e0 35       	cpi	r30, 0x50	; 80
    112c:	f8 07       	cpc	r31, r24
    112e:	d9 f7       	brne	.-10     	; 0x1126 <init_array+0x26>
}
    1130:	08 95       	ret

00001132 <mousedata_tx>:
   //Select ADC Channel ch must be 0-7 (corresponds to the flex sensors...)
   //flex sensors from channel 0-4
   //acccelerometer from channel 5-7
   
   //ch=ch & 0b00000111;
   ADMUX = ch;
    1132:	81 e0       	ldi	r24, 0x01	; 1
    1134:	87 b9       	out	0x07, r24	; 7

   //Start Single conversion
   ADCSRA|=(1<<ADSC);
    1136:	36 9a       	sbi	0x06, 6	; 6

   //Wait for conversion to complete
   while(!(ADCSRA & (1<<ADIF)));
    1138:	34 9b       	sbis	0x06, 4	; 6
    113a:	fe cf       	rjmp	.-4      	; 0x1138 <mousedata_tx+0x6>

   //Clear ADIF by writing one to it
   ADCSRA|=(1<<ADIF);
    113c:	34 9a       	sbi	0x06, 4	; 6

   return(ADCW);
    113e:	64 b1       	in	r22, 0x04	; 4
    1140:	75 b1       	in	r23, 0x05	; 5


void mousedata_tx()
{

lclick=read_adc(1);
    1142:	70 93 7c 03 	sts	0x037C, r23
    1146:	60 93 7b 03 	sts	0x037B, r22
   //Select ADC Channel ch must be 0-7 (corresponds to the flex sensors...)
   //flex sensors from channel 0-4
   //acccelerometer from channel 5-7
   
   //ch=ch & 0b00000111;
   ADMUX = ch;
    114a:	82 e0       	ldi	r24, 0x02	; 2
    114c:	87 b9       	out	0x07, r24	; 7

   //Start Single conversion
   ADCSRA|=(1<<ADSC);
    114e:	36 9a       	sbi	0x06, 6	; 6

   //Wait for conversion to complete
   while(!(ADCSRA & (1<<ADIF)));
    1150:	34 9b       	sbis	0x06, 4	; 6
    1152:	fe cf       	rjmp	.-4      	; 0x1150 <mousedata_tx+0x1e>

   //Clear ADIF by writing one to it
   ADCSRA|=(1<<ADIF);
    1154:	34 9a       	sbi	0x06, 4	; 6

   return(ADCW);
    1156:	44 b1       	in	r20, 0x04	; 4
    1158:	55 b1       	in	r21, 0x05	; 5
rclick=read_adc(2);
    115a:	50 93 7e 03 	sts	0x037E, r21
    115e:	40 93 7d 03 	sts	0x037D, r20
   //Select ADC Channel ch must be 0-7 (corresponds to the flex sensors...)
   //flex sensors from channel 0-4
   //acccelerometer from channel 5-7
   
   //ch=ch & 0b00000111;
   ADMUX = ch;
    1162:	85 e0       	ldi	r24, 0x05	; 5
    1164:	87 b9       	out	0x07, r24	; 7

   //Start Single conversion
   ADCSRA|=(1<<ADSC);
    1166:	36 9a       	sbi	0x06, 6	; 6

   //Wait for conversion to complete
   while(!(ADCSRA & (1<<ADIF)));
    1168:	34 9b       	sbis	0x06, 4	; 6
    116a:	fe cf       	rjmp	.-4      	; 0x1168 <mousedata_tx+0x36>

   //Clear ADIF by writing one to it
   ADCSRA|=(1<<ADIF);
    116c:	34 9a       	sbi	0x06, 4	; 6

   return(ADCW);
    116e:	24 b1       	in	r18, 0x04	; 4
    1170:	35 b1       	in	r19, 0x05	; 5
mouse_y=read_adc(5);
    1172:	30 93 7a 03 	sts	0x037A, r19
    1176:	20 93 79 03 	sts	0x0379, r18
   //Select ADC Channel ch must be 0-7 (corresponds to the flex sensors...)
   //flex sensors from channel 0-4
   //acccelerometer from channel 5-7
   
   //ch=ch & 0b00000111;
   ADMUX = ch;
    117a:	86 e0       	ldi	r24, 0x06	; 6
    117c:	87 b9       	out	0x07, r24	; 7

   //Start Single conversion
   ADCSRA|=(1<<ADSC);
    117e:	36 9a       	sbi	0x06, 6	; 6

   //Wait for conversion to complete
   while(!(ADCSRA & (1<<ADIF)));
    1180:	34 9b       	sbis	0x06, 4	; 6
    1182:	fe cf       	rjmp	.-4      	; 0x1180 <mousedata_tx+0x4e>

   //Clear ADIF by writing one to it
   ADCSRA|=(1<<ADIF);
    1184:	34 9a       	sbi	0x06, 4	; 6

   return(ADCW);
    1186:	84 b1       	in	r24, 0x04	; 4
    1188:	95 b1       	in	r25, 0x05	; 5
mouse_x=read_adc(6);
    118a:	90 93 78 03 	sts	0x0378, r25
    118e:	80 93 77 03 	sts	0x0377, r24

tempx=0;
    1192:	10 92 57 07 	sts	0x0757, r1
tempy=0;
    1196:	10 92 83 03 	sts	0x0383, r1

if(rclick<=mouse_rc) {rc=0xDF;}
    119a:	45 5a       	subi	r20, 0xA5	; 165
    119c:	51 40       	sbci	r21, 0x01	; 1
    119e:	20 f4       	brcc	.+8      	; 0x11a8 <mousedata_tx+0x76>
    11a0:	8f ed       	ldi	r24, 0xDF	; 223
    11a2:	80 93 7f 03 	sts	0x037F, r24
    11a6:	02 c0       	rjmp	.+4      	; 0x11ac <mousedata_tx+0x7a>
else{rc=0x00;}
    11a8:	10 92 7f 03 	sts	0x037F, r1

if(lclick<=mouse_lc) {lc=0xEF;}
    11ac:	65 5a       	subi	r22, 0xA5	; 165
    11ae:	71 40       	sbci	r23, 0x01	; 1
    11b0:	20 f4       	brcc	.+8      	; 0x11ba <mousedata_tx+0x88>
    11b2:	8f ee       	ldi	r24, 0xEF	; 239
    11b4:	80 93 80 03 	sts	0x0380, r24
    11b8:	02 c0       	rjmp	.+4      	; 0x11be <mousedata_tx+0x8c>
else{lc=0x00;}
    11ba:	10 92 80 03 	sts	0x0380, r1


if((mouse_y > 250 )&&(mouse_y < 290))//fast down
    11be:	2b 5f       	subi	r18, 0xFB	; 251
    11c0:	30 40       	sbci	r19, 0x00	; 0
    11c2:	27 32       	cpi	r18, 0x27	; 39
    11c4:	31 05       	cpc	r19, r1
    11c6:	a0 f4       	brcc	.+40     	; 0x11f0 <mousedata_tx+0xbe>
{
tempy=4;
    11c8:	94 e0       	ldi	r25, 0x04	; 4
    11ca:	90 93 83 03 	sts	0x0383, r25
txBuffer[1]=0xCF;
    11ce:	8f ec       	ldi	r24, 0xCF	; 207
    11d0:	80 93 52 07 	sts	0x0752, r24
txBuffer[2]=tempx; 
    11d4:	10 92 53 07 	sts	0x0753, r1
txBuffer[3]=tempy;
    11d8:	90 93 54 07 	sts	0x0754, r25
txBuffer[4]=lc;
    11dc:	80 91 80 03 	lds	r24, 0x0380
    11e0:	80 93 55 07 	sts	0x0755, r24
txBuffer[5]=rc;
    11e4:	80 91 7f 03 	lds	r24, 0x037F
    11e8:	80 93 56 07 	sts	0x0756, r24
data_tx();
    11ec:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <data_tx>
}

if((mouse_y > 290 )&&(mouse_y < 310))//slow down
    11f0:	80 91 79 03 	lds	r24, 0x0379
    11f4:	90 91 7a 03 	lds	r25, 0x037A
    11f8:	83 52       	subi	r24, 0x23	; 35
    11fa:	91 40       	sbci	r25, 0x01	; 1
    11fc:	43 97       	sbiw	r24, 0x13	; 19
    11fe:	b0 f4       	brcc	.+44     	; 0x122c <mousedata_tx+0xfa>
{
tempy=3;
    1200:	93 e0       	ldi	r25, 0x03	; 3
    1202:	90 93 83 03 	sts	0x0383, r25
txBuffer[1]=0xCF;
    1206:	8f ec       	ldi	r24, 0xCF	; 207
    1208:	80 93 52 07 	sts	0x0752, r24
txBuffer[2]=tempx; 
    120c:	80 91 57 07 	lds	r24, 0x0757
    1210:	80 93 53 07 	sts	0x0753, r24
txBuffer[3]=tempy;
    1214:	90 93 54 07 	sts	0x0754, r25
txBuffer[4]=lc;
    1218:	80 91 80 03 	lds	r24, 0x0380
    121c:	80 93 55 07 	sts	0x0755, r24
txBuffer[5]=rc;
    1220:	80 91 7f 03 	lds	r24, 0x037F
    1224:	80 93 56 07 	sts	0x0756, r24
data_tx();
    1228:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <data_tx>
}

if((mouse_y > 350 )&&(mouse_y < 370))//slow up
    122c:	80 91 79 03 	lds	r24, 0x0379
    1230:	90 91 7a 03 	lds	r25, 0x037A
    1234:	8f 55       	subi	r24, 0x5F	; 95
    1236:	91 40       	sbci	r25, 0x01	; 1
    1238:	43 97       	sbiw	r24, 0x13	; 19
    123a:	b0 f4       	brcc	.+44     	; 0x1268 <mousedata_tx+0x136>
{
tempy=1;
    123c:	91 e0       	ldi	r25, 0x01	; 1
    123e:	90 93 83 03 	sts	0x0383, r25
txBuffer[1]=0xCF;
    1242:	8f ec       	ldi	r24, 0xCF	; 207
    1244:	80 93 52 07 	sts	0x0752, r24
txBuffer[2]=tempx; 
    1248:	80 91 57 07 	lds	r24, 0x0757
    124c:	80 93 53 07 	sts	0x0753, r24
txBuffer[3]=tempy;
    1250:	90 93 54 07 	sts	0x0754, r25
txBuffer[4]=lc;
    1254:	80 91 80 03 	lds	r24, 0x0380
    1258:	80 93 55 07 	sts	0x0755, r24
txBuffer[5]=rc;
    125c:	80 91 7f 03 	lds	r24, 0x037F
    1260:	80 93 56 07 	sts	0x0756, r24
data_tx();
    1264:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <data_tx>
}

if((mouse_y > 370 )&&(mouse_y < 400))//fast up
    1268:	80 91 79 03 	lds	r24, 0x0379
    126c:	90 91 7a 03 	lds	r25, 0x037A
    1270:	83 57       	subi	r24, 0x73	; 115
    1272:	91 40       	sbci	r25, 0x01	; 1
    1274:	4d 97       	sbiw	r24, 0x1d	; 29
    1276:	b0 f4       	brcc	.+44     	; 0x12a4 <mousedata_tx+0x172>
{
tempy=2;
    1278:	92 e0       	ldi	r25, 0x02	; 2
    127a:	90 93 83 03 	sts	0x0383, r25
txBuffer[1]=0xCF;
    127e:	8f ec       	ldi	r24, 0xCF	; 207
    1280:	80 93 52 07 	sts	0x0752, r24
txBuffer[2]=tempx; 
    1284:	80 91 57 07 	lds	r24, 0x0757
    1288:	80 93 53 07 	sts	0x0753, r24
txBuffer[3]=tempy;
    128c:	90 93 54 07 	sts	0x0754, r25
txBuffer[4]=lc;
    1290:	80 91 80 03 	lds	r24, 0x0380
    1294:	80 93 55 07 	sts	0x0755, r24
txBuffer[5]=rc;
    1298:	80 91 7f 03 	lds	r24, 0x037F
    129c:	80 93 56 07 	sts	0x0756, r24
data_tx();
    12a0:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <data_tx>
}

if((mouse_x > 250 )&&(mouse_x < 290))//fast right 
    12a4:	80 91 77 03 	lds	r24, 0x0377
    12a8:	90 91 78 03 	lds	r25, 0x0378
    12ac:	8b 5f       	subi	r24, 0xFB	; 251
    12ae:	90 40       	sbci	r25, 0x00	; 0
    12b0:	87 97       	sbiw	r24, 0x27	; 39
    12b2:	b0 f4       	brcc	.+44     	; 0x12e0 <mousedata_tx+0x1ae>
{
tempx=2;
    12b4:	92 e0       	ldi	r25, 0x02	; 2
    12b6:	90 93 57 07 	sts	0x0757, r25
txBuffer[1]=0xCF;
    12ba:	8f ec       	ldi	r24, 0xCF	; 207
    12bc:	80 93 52 07 	sts	0x0752, r24
txBuffer[2]=tempx; 
    12c0:	90 93 53 07 	sts	0x0753, r25
txBuffer[3]=tempy;
    12c4:	80 91 83 03 	lds	r24, 0x0383
    12c8:	80 93 54 07 	sts	0x0754, r24
txBuffer[4]=lc;
    12cc:	80 91 80 03 	lds	r24, 0x0380
    12d0:	80 93 55 07 	sts	0x0755, r24
txBuffer[5]=rc;
    12d4:	80 91 7f 03 	lds	r24, 0x037F
    12d8:	80 93 56 07 	sts	0x0756, r24
data_tx();
    12dc:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <data_tx>
}

if((mouse_x > 290 )&&(mouse_x < 310))//slow right 
    12e0:	80 91 77 03 	lds	r24, 0x0377
    12e4:	90 91 78 03 	lds	r25, 0x0378
    12e8:	83 52       	subi	r24, 0x23	; 35
    12ea:	91 40       	sbci	r25, 0x01	; 1
    12ec:	43 97       	sbiw	r24, 0x13	; 19
    12ee:	b0 f4       	brcc	.+44     	; 0x131c <mousedata_tx+0x1ea>
{
tempx=1;
    12f0:	91 e0       	ldi	r25, 0x01	; 1
    12f2:	90 93 57 07 	sts	0x0757, r25
txBuffer[1]=0xCF;
    12f6:	8f ec       	ldi	r24, 0xCF	; 207
    12f8:	80 93 52 07 	sts	0x0752, r24
txBuffer[2]=tempx; 
    12fc:	90 93 53 07 	sts	0x0753, r25
txBuffer[3]=tempy;
    1300:	80 91 83 03 	lds	r24, 0x0383
    1304:	80 93 54 07 	sts	0x0754, r24
txBuffer[4]=lc;
    1308:	80 91 80 03 	lds	r24, 0x0380
    130c:	80 93 55 07 	sts	0x0755, r24
txBuffer[5]=rc;
    1310:	80 91 7f 03 	lds	r24, 0x037F
    1314:	80 93 56 07 	sts	0x0756, r24
data_tx();
    1318:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <data_tx>
}

if((mouse_x > 350 )&&(mouse_x < 370))//fast left 
    131c:	80 91 77 03 	lds	r24, 0x0377
    1320:	90 91 78 03 	lds	r25, 0x0378
    1324:	8f 55       	subi	r24, 0x5F	; 95
    1326:	91 40       	sbci	r25, 0x01	; 1
    1328:	43 97       	sbiw	r24, 0x13	; 19
    132a:	b0 f4       	brcc	.+44     	; 0x1358 <mousedata_tx+0x226>
{
tempx=3;
    132c:	93 e0       	ldi	r25, 0x03	; 3
    132e:	90 93 57 07 	sts	0x0757, r25
txBuffer[1]=0xCF;
    1332:	8f ec       	ldi	r24, 0xCF	; 207
    1334:	80 93 52 07 	sts	0x0752, r24
txBuffer[2]=tempx; 
    1338:	90 93 53 07 	sts	0x0753, r25
txBuffer[3]=tempy;
    133c:	80 91 83 03 	lds	r24, 0x0383
    1340:	80 93 54 07 	sts	0x0754, r24
txBuffer[4]=lc;
    1344:	80 91 80 03 	lds	r24, 0x0380
    1348:	80 93 55 07 	sts	0x0755, r24
txBuffer[5]=rc;
    134c:	80 91 7f 03 	lds	r24, 0x037F
    1350:	80 93 56 07 	sts	0x0756, r24
data_tx();
    1354:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <data_tx>
}

if((mouse_x > 370 )&&(mouse_x < 400))//slow left 
    1358:	80 91 77 03 	lds	r24, 0x0377
    135c:	90 91 78 03 	lds	r25, 0x0378
    1360:	83 57       	subi	r24, 0x73	; 115
    1362:	91 40       	sbci	r25, 0x01	; 1
    1364:	4d 97       	sbiw	r24, 0x1d	; 29
    1366:	b0 f4       	brcc	.+44     	; 0x1394 <mousedata_tx+0x262>
{
tempx=4;
    1368:	94 e0       	ldi	r25, 0x04	; 4
    136a:	90 93 57 07 	sts	0x0757, r25
txBuffer[1]=0xCF;
    136e:	8f ec       	ldi	r24, 0xCF	; 207
    1370:	80 93 52 07 	sts	0x0752, r24
txBuffer[2]=tempx; 
    1374:	90 93 53 07 	sts	0x0753, r25
txBuffer[3]=tempy;
    1378:	80 91 83 03 	lds	r24, 0x0383
    137c:	80 93 54 07 	sts	0x0754, r24
txBuffer[4]=lc;
    1380:	80 91 80 03 	lds	r24, 0x0380
    1384:	80 93 55 07 	sts	0x0755, r24
txBuffer[5]=rc;
    1388:	80 91 7f 03 	lds	r24, 0x037F
    138c:	80 93 56 07 	sts	0x0756, r24
data_tx();
    1390:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <data_tx>
}


txBuffer[1]=0xCF;
    1394:	8f ec       	ldi	r24, 0xCF	; 207
    1396:	80 93 52 07 	sts	0x0752, r24
txBuffer[2]=tempx; 
    139a:	80 91 57 07 	lds	r24, 0x0757
    139e:	80 93 53 07 	sts	0x0753, r24
txBuffer[3]=tempy;
    13a2:	80 91 83 03 	lds	r24, 0x0383
    13a6:	80 93 54 07 	sts	0x0754, r24
txBuffer[4]=lc;
    13aa:	80 91 80 03 	lds	r24, 0x0380
    13ae:	80 93 55 07 	sts	0x0755, r24
txBuffer[5]=rc;
    13b2:	80 91 7f 03 	lds	r24, 0x037F
    13b6:	80 93 56 07 	sts	0x0756, r24
data_tx();
    13ba:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <data_tx>

key=key_read();
    13be:	0e 94 7a 00 	call	0xf4	; 0xf4 <key_read>
    13c2:	80 93 50 07 	sts	0x0750, r24
if(key=='#'){submenu_select=0;_delay_ms(keypress);}
    13c6:	83 32       	cpi	r24, 0x23	; 35
    13c8:	59 f4       	brne	.+22     	; 0x13e0 <mousedata_tx+0x2ae>
    13ca:	10 92 74 03 	sts	0x0374, r1
    13ce:	88 eb       	ldi	r24, 0xB8	; 184
    13d0:	9b e0       	ldi	r25, 0x0B	; 11
    13d2:	20 e9       	ldi	r18, 0x90	; 144
    13d4:	31 e0       	ldi	r19, 0x01	; 1
    13d6:	f9 01       	movw	r30, r18
    13d8:	31 97       	sbiw	r30, 0x01	; 1
    13da:	f1 f7       	brne	.-4      	; 0x13d8 <mousedata_tx+0x2a6>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    13dc:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    13de:	d9 f7       	brne	.-10     	; 0x13d6 <mousedata_tx+0x2a4>
    13e0:	08 95       	ret

000013e2 <menu>:


void menu() //main menu
{

txBuffer[1]=0xFF;
    13e2:	8f ef       	ldi	r24, 0xFF	; 255
    13e4:	80 93 52 07 	sts	0x0752, r24
txBuffer[2]=0x00;
    13e8:	10 92 53 07 	sts	0x0753, r1
txBuffer[3]=0x00;
    13ec:	10 92 54 07 	sts	0x0754, r1
txBuffer[4]=0x00;
    13f0:	10 92 55 07 	sts	0x0755, r1
txBuffer[5]=0x00;
    13f4:	10 92 56 07 	sts	0x0756, r1
data_tx();
    13f8:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <data_tx>

key=key_read();
while(key=='/'){key=key_read();}
    13fc:	0e 94 7a 00 	call	0xf4	; 0xf4 <key_read>
    1400:	80 93 50 07 	sts	0x0750, r24
    1404:	20 91 50 07 	lds	r18, 0x0750
    1408:	2f 32       	cpi	r18, 0x2F	; 47
    140a:	c1 f3       	breq	.-16     	; 0x13fc <menu+0x1a>
    140c:	88 eb       	ldi	r24, 0xB8	; 184
    140e:	9b e0       	ldi	r25, 0x0B	; 11
    1410:	40 e9       	ldi	r20, 0x90	; 144
    1412:	51 e0       	ldi	r21, 0x01	; 1
    1414:	fa 01       	movw	r30, r20
    1416:	31 97       	sbiw	r30, 0x01	; 1
    1418:	f1 f7       	brne	.-4      	; 0x1416 <menu+0x34>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    141a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    141c:	d9 f7       	brne	.-10     	; 0x1414 <menu+0x32>
_delay_ms(keypress);

switch(key)
    141e:	22 33       	cpi	r18, 0x32	; 50
    1420:	61 f0       	breq	.+24     	; 0x143a <menu+0x58>
    1422:	23 33       	cpi	r18, 0x33	; 51
    1424:	18 f4       	brcc	.+6      	; 0x142c <menu+0x4a>
    1426:	21 33       	cpi	r18, 0x31	; 49
    1428:	e1 f4       	brne	.+56     	; 0x1462 <menu+0x80>
    142a:	05 c0       	rjmp	.+10     	; 0x1436 <menu+0x54>
    142c:	23 33       	cpi	r18, 0x33	; 51
    142e:	39 f0       	breq	.+14     	; 0x143e <menu+0x5c>
    1430:	24 33       	cpi	r18, 0x34	; 52
    1432:	b9 f4       	brne	.+46     	; 0x1462 <menu+0x80>
    1434:	06 c0       	rjmp	.+12     	; 0x1442 <menu+0x60>
{
case'1':menu_select=1;
    1436:	91 e0       	ldi	r25, 0x01	; 1
    1438:	05 c0       	rjmp	.+10     	; 0x1444 <menu+0x62>
        txBuffer[4]=0x00;
        txBuffer[5]=0x00;
        data_tx();
        break;

case'2':menu_select=2; 
    143a:	92 e0       	ldi	r25, 0x02	; 2
    143c:	03 c0       	rjmp	.+6      	; 0x1444 <menu+0x62>
        txBuffer[4]=0x00;
        txBuffer[5]=0x00;
        data_tx();
        break;

case'3':menu_select=3;
    143e:	93 e0       	ldi	r25, 0x03	; 3
    1440:	01 c0       	rjmp	.+2      	; 0x1444 <menu+0x62>
        txBuffer[4]=0x00;
        txBuffer[5]=0x00;
        data_tx();
        break;

case'4':menu_select=4;
    1442:	94 e0       	ldi	r25, 0x04	; 4
    1444:	90 93 73 03 	sts	0x0373, r25
        txBuffer[1]=0xAF;
    1448:	8f ea       	ldi	r24, 0xAF	; 175
    144a:	80 93 52 07 	sts	0x0752, r24
        txBuffer[2]=4;
    144e:	90 93 53 07 	sts	0x0753, r25
        txBuffer[3]=0x00;
    1452:	10 92 54 07 	sts	0x0754, r1
        txBuffer[4]=0x00;
    1456:	10 92 55 07 	sts	0x0755, r1
        txBuffer[5]=0x00;
    145a:	10 92 56 07 	sts	0x0756, r1
        data_tx();
    145e:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <data_tx>
    1462:	88 e9       	ldi	r24, 0x98	; 152
    1464:	9a e3       	ldi	r25, 0x3A	; 58
    1466:	20 e9       	ldi	r18, 0x90	; 144
    1468:	31 e0       	ldi	r19, 0x01	; 1
    146a:	f9 01       	movw	r30, r18
    146c:	31 97       	sbiw	r30, 0x01	; 1
    146e:	f1 f7       	brne	.-4      	; 0x146c <menu+0x8a>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1470:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1472:	d9 f7       	brne	.-10     	; 0x146a <menu+0x88>
        break;
*/

}
_delay_ms(1500);
}
    1474:	08 95       	ret

00001476 <submenu>:

void submenu()//menu for mouse and normal text mode
{

key=key_read();
while(key=='/'){key=key_read();}
    1476:	0e 94 7a 00 	call	0xf4	; 0xf4 <key_read>
    147a:	80 93 50 07 	sts	0x0750, r24
    147e:	20 91 50 07 	lds	r18, 0x0750
    1482:	2f 32       	cpi	r18, 0x2F	; 47
    1484:	c1 f3       	breq	.-16     	; 0x1476 <submenu>
    1486:	88 eb       	ldi	r24, 0xB8	; 184
    1488:	9b e0       	ldi	r25, 0x0B	; 11
    148a:	40 e9       	ldi	r20, 0x90	; 144
    148c:	51 e0       	ldi	r21, 0x01	; 1
    148e:	fa 01       	movw	r30, r20
    1490:	31 97       	sbiw	r30, 0x01	; 1
    1492:	f1 f7       	brne	.-4      	; 0x1490 <submenu+0x1a>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1494:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1496:	d9 f7       	brne	.-10     	; 0x148e <submenu+0x18>
_delay_ms(keypress);

switch(key)
    1498:	23 33       	cpi	r18, 0x33	; 51
    149a:	81 f0       	breq	.+32     	; 0x14bc <submenu+0x46>
    149c:	24 33       	cpi	r18, 0x34	; 52
    149e:	28 f4       	brcc	.+10     	; 0x14aa <submenu+0x34>
    14a0:	21 33       	cpi	r18, 0x31	; 49
    14a2:	41 f0       	breq	.+16     	; 0x14b4 <submenu+0x3e>
    14a4:	22 33       	cpi	r18, 0x32	; 50
    14a6:	41 f5       	brne	.+80     	; 0x14f8 <submenu+0x82>
    14a8:	07 c0       	rjmp	.+14     	; 0x14b8 <submenu+0x42>
    14aa:	24 33       	cpi	r18, 0x34	; 52
    14ac:	49 f0       	breq	.+18     	; 0x14c0 <submenu+0x4a>
    14ae:	29 33       	cpi	r18, 0x39	; 57
    14b0:	19 f5       	brne	.+70     	; 0x14f8 <submenu+0x82>
    14b2:	1e c0       	rjmp	.+60     	; 0x14f0 <submenu+0x7a>
{
case'1':submenu_select=1;
    14b4:	91 e0       	ldi	r25, 0x01	; 1
    14b6:	09 c0       	rjmp	.+18     	; 0x14ca <submenu+0x54>
        txBuffer[4]=0x00;
        txBuffer[5]=0x00;
        data_tx();
        break;

case'2':submenu_select=2; 
    14b8:	92 e0       	ldi	r25, 0x02	; 2
    14ba:	07 c0       	rjmp	.+14     	; 0x14ca <submenu+0x54>
        txBuffer[4]=0x00;
        txBuffer[5]=0x00;
        data_tx();
        break;

case'3':submenu_select=3;
    14bc:	93 e0       	ldi	r25, 0x03	; 3
    14be:	05 c0       	rjmp	.+10     	; 0x14ca <submenu+0x54>
        txBuffer[4]=0x00;
        txBuffer[5]=0x00;
        data_tx();
        break;

case'4':if(menu_select==2)
    14c0:	80 91 73 03 	lds	r24, 0x0373
    14c4:	82 30       	cpi	r24, 0x02	; 2
    14c6:	89 f4       	brne	.+34     	; 0x14ea <submenu+0x74>
        {
        submenu_select=4;
    14c8:	94 e0       	ldi	r25, 0x04	; 4
    14ca:	90 93 74 03 	sts	0x0374, r25
        txBuffer[1]=0xBF;
    14ce:	8f eb       	ldi	r24, 0xBF	; 191
    14d0:	80 93 52 07 	sts	0x0752, r24
        txBuffer[2]=4;
    14d4:	90 93 53 07 	sts	0x0753, r25
        txBuffer[3]=0x00;
    14d8:	10 92 54 07 	sts	0x0754, r1
        txBuffer[4]=0x00;
    14dc:	10 92 55 07 	sts	0x0755, r1
        txBuffer[5]=0x00;
    14e0:	10 92 56 07 	sts	0x0756, r1
        data_tx();
    14e4:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <data_tx>
    14e8:	08 95       	ret
		}
		else {submenu_select=0;}
    14ea:	10 92 74 03 	sts	0x0374, r1
    14ee:	08 95       	ret
        break;

case'9':submenu_select=0;
    14f0:	10 92 74 03 	sts	0x0374, r1
        menu_select=0;
    14f4:	10 92 73 03 	sts	0x0373, r1
    14f8:	08 95       	ret

000014fa <cpy_samp>:
}
*/


void cpy_samp(uint8_t ch)
{
    14fa:	1f 93       	push	r17

switch(ch)
    14fc:	82 30       	cpi	r24, 0x02	; 2
    14fe:	09 f4       	brne	.+2      	; 0x1502 <cpy_samp+0x8>
    1500:	4a c0       	rjmp	.+148    	; 0x1596 <cpy_samp+0x9c>
    1502:	83 30       	cpi	r24, 0x03	; 3
    1504:	09 f4       	brne	.+2      	; 0x1508 <cpy_samp+0xe>
    1506:	8b c0       	rjmp	.+278    	; 0x161e <cpy_samp+0x124>
    1508:	81 30       	cpi	r24, 0x01	; 1
    150a:	09 f0       	breq	.+2      	; 0x150e <cpy_samp+0x14>
    150c:	cd c0       	rjmp	.+410    	; 0x16a8 <cpy_samp+0x1ae>
    150e:	10 e0       	ldi	r17, 0x00	; 0
    1510:	3e c0       	rjmp	.+124    	; 0x158e <cpy_samp+0x94>
{

case 1:
for(samp_cnt=0;samp_cnt<26;samp_cnt++)
{
alph[samp_cnt][0]=aniruddh[samp_cnt][0];
    1512:	41 2f       	mov	r20, r17
    1514:	50 e0       	ldi	r21, 0x00	; 0
    1516:	9a 01       	movw	r18, r20
    1518:	22 0f       	add	r18, r18
    151a:	33 1f       	adc	r19, r19
    151c:	ca 01       	movw	r24, r20
    151e:	63 e0       	ldi	r22, 0x03	; 3
    1520:	88 0f       	add	r24, r24
    1522:	99 1f       	adc	r25, r25
    1524:	6a 95       	dec	r22
    1526:	e1 f7       	brne	.-8      	; 0x1520 <cpy_samp+0x26>
    1528:	28 0f       	add	r18, r24
    152a:	39 1f       	adc	r19, r25
    152c:	b9 01       	movw	r22, r18
    152e:	6c 57       	subi	r22, 0x7C	; 124
    1530:	7c 4f       	sbci	r23, 0xFC	; 252
    1532:	20 5a       	subi	r18, 0xA0	; 160
    1534:	3f 4f       	sbci	r19, 0xFF	; 255
    1536:	f9 01       	movw	r30, r18
    1538:	80 81       	ld	r24, Z
    153a:	91 81       	ldd	r25, Z+1	; 0x01
    153c:	fb 01       	movw	r30, r22
    153e:	91 83       	std	Z+1, r25	; 0x01
    1540:	80 83       	st	Z, r24
alph[samp_cnt][1]=aniruddh[samp_cnt][1];
    1542:	fa 01       	movw	r30, r20
    1544:	ee 0f       	add	r30, r30
    1546:	ff 1f       	adc	r31, r31
    1548:	ee 0f       	add	r30, r30
    154a:	ff 1f       	adc	r31, r31
    154c:	e4 0f       	add	r30, r20
    154e:	f5 1f       	adc	r31, r21
    1550:	31 96       	adiw	r30, 0x01	; 1
    1552:	ee 0f       	add	r30, r30
    1554:	ff 1f       	adc	r31, r31
    1556:	df 01       	movw	r26, r30
    1558:	a0 5a       	subi	r26, 0xA0	; 160
    155a:	bf 4f       	sbci	r27, 0xFF	; 255
    155c:	8d 91       	ld	r24, X+
    155e:	9c 91       	ld	r25, X
    1560:	ec 57       	subi	r30, 0x7C	; 124
    1562:	fc 4f       	sbci	r31, 0xFC	; 252
    1564:	91 83       	std	Z+1, r25	; 0x01
    1566:	80 83       	st	Z, r24
alph[samp_cnt][2]=aniruddh[samp_cnt][2];
    1568:	f9 01       	movw	r30, r18
    156a:	84 81       	ldd	r24, Z+4	; 0x04
    156c:	95 81       	ldd	r25, Z+5	; 0x05
    156e:	fb 01       	movw	r30, r22
    1570:	95 83       	std	Z+5, r25	; 0x05
    1572:	84 83       	std	Z+4, r24	; 0x04
alph[samp_cnt][3]=aniruddh[samp_cnt][3];
    1574:	f9 01       	movw	r30, r18
    1576:	86 81       	ldd	r24, Z+6	; 0x06
    1578:	97 81       	ldd	r25, Z+7	; 0x07
    157a:	fb 01       	movw	r30, r22
    157c:	97 83       	std	Z+7, r25	; 0x07
    157e:	86 83       	std	Z+6, r24	; 0x06
alph[samp_cnt][4]=aniruddh[samp_cnt][4];
    1580:	f9 01       	movw	r30, r18
    1582:	80 85       	ldd	r24, Z+8	; 0x08
    1584:	91 85       	ldd	r25, Z+9	; 0x09
    1586:	fb 01       	movw	r30, r22
    1588:	91 87       	std	Z+9, r25	; 0x09
    158a:	80 87       	std	Z+8, r24	; 0x08
    158c:	1f 5f       	subi	r17, 0xFF	; 255

switch(ch)
{

case 1:
for(samp_cnt=0;samp_cnt<26;samp_cnt++)
    158e:	1a 31       	cpi	r17, 0x1A	; 26
    1590:	08 f4       	brcc	.+2      	; 0x1594 <cpy_samp+0x9a>
    1592:	bf cf       	rjmp	.-130    	; 0x1512 <cpy_samp+0x18>
    1594:	87 c0       	rjmp	.+270    	; 0x16a4 <cpy_samp+0x1aa>
    1596:	10 e0       	ldi	r17, 0x00	; 0
    1598:	3e c0       	rjmp	.+124    	; 0x1616 <cpy_samp+0x11c>


case 2:
for(samp_cnt=0;samp_cnt<26;samp_cnt++)
{
alph[samp_cnt][0]=siddesh[samp_cnt][0];
    159a:	41 2f       	mov	r20, r17
    159c:	50 e0       	ldi	r21, 0x00	; 0
    159e:	9a 01       	movw	r18, r20
    15a0:	22 0f       	add	r18, r18
    15a2:	33 1f       	adc	r19, r19
    15a4:	ca 01       	movw	r24, r20
    15a6:	63 e0       	ldi	r22, 0x03	; 3
    15a8:	88 0f       	add	r24, r24
    15aa:	99 1f       	adc	r25, r25
    15ac:	6a 95       	dec	r22
    15ae:	e1 f7       	brne	.-8      	; 0x15a8 <cpy_samp+0xae>
    15b0:	28 0f       	add	r18, r24
    15b2:	39 1f       	adc	r19, r25
    15b4:	b9 01       	movw	r22, r18
    15b6:	6c 57       	subi	r22, 0x7C	; 124
    15b8:	7c 4f       	sbci	r23, 0xFC	; 252
    15ba:	2c 59       	subi	r18, 0x9C	; 156
    15bc:	3e 4f       	sbci	r19, 0xFE	; 254
    15be:	f9 01       	movw	r30, r18
    15c0:	80 81       	ld	r24, Z
    15c2:	91 81       	ldd	r25, Z+1	; 0x01
    15c4:	fb 01       	movw	r30, r22
    15c6:	91 83       	std	Z+1, r25	; 0x01
    15c8:	80 83       	st	Z, r24
alph[samp_cnt][1]=siddesh[samp_cnt][1];
    15ca:	fa 01       	movw	r30, r20
    15cc:	ee 0f       	add	r30, r30
    15ce:	ff 1f       	adc	r31, r31
    15d0:	ee 0f       	add	r30, r30
    15d2:	ff 1f       	adc	r31, r31
    15d4:	e4 0f       	add	r30, r20
    15d6:	f5 1f       	adc	r31, r21
    15d8:	31 96       	adiw	r30, 0x01	; 1
    15da:	ee 0f       	add	r30, r30
    15dc:	ff 1f       	adc	r31, r31
    15de:	df 01       	movw	r26, r30
    15e0:	ac 59       	subi	r26, 0x9C	; 156
    15e2:	be 4f       	sbci	r27, 0xFE	; 254
    15e4:	8d 91       	ld	r24, X+
    15e6:	9c 91       	ld	r25, X
    15e8:	ec 57       	subi	r30, 0x7C	; 124
    15ea:	fc 4f       	sbci	r31, 0xFC	; 252
    15ec:	91 83       	std	Z+1, r25	; 0x01
    15ee:	80 83       	st	Z, r24
alph[samp_cnt][2]=siddesh[samp_cnt][2];
    15f0:	f9 01       	movw	r30, r18
    15f2:	84 81       	ldd	r24, Z+4	; 0x04
    15f4:	95 81       	ldd	r25, Z+5	; 0x05
    15f6:	fb 01       	movw	r30, r22
    15f8:	95 83       	std	Z+5, r25	; 0x05
    15fa:	84 83       	std	Z+4, r24	; 0x04
alph[samp_cnt][3]=siddesh[samp_cnt][3];
    15fc:	f9 01       	movw	r30, r18
    15fe:	86 81       	ldd	r24, Z+6	; 0x06
    1600:	97 81       	ldd	r25, Z+7	; 0x07
    1602:	fb 01       	movw	r30, r22
    1604:	97 83       	std	Z+7, r25	; 0x07
    1606:	86 83       	std	Z+6, r24	; 0x06
alph[samp_cnt][4]=siddesh[samp_cnt][4];
    1608:	f9 01       	movw	r30, r18
    160a:	80 85       	ldd	r24, Z+8	; 0x08
    160c:	91 85       	ldd	r25, Z+9	; 0x09
    160e:	fb 01       	movw	r30, r22
    1610:	91 87       	std	Z+9, r25	; 0x09
    1612:	80 87       	std	Z+8, r24	; 0x08
    1614:	1f 5f       	subi	r17, 0xFF	; 255

break;


case 2:
for(samp_cnt=0;samp_cnt<26;samp_cnt++)
    1616:	1a 31       	cpi	r17, 0x1A	; 26
    1618:	08 f4       	brcc	.+2      	; 0x161c <cpy_samp+0x122>
    161a:	bf cf       	rjmp	.-130    	; 0x159a <cpy_samp+0xa0>
    161c:	43 c0       	rjmp	.+134    	; 0x16a4 <cpy_samp+0x1aa>
    161e:	10 e0       	ldi	r17, 0x00	; 0
    1620:	3e c0       	rjmp	.+124    	; 0x169e <cpy_samp+0x1a4>
break;

case 3:
for(samp_cnt=0;samp_cnt<26;samp_cnt++)
{
alph[samp_cnt][0]=shawn[samp_cnt][0];
    1622:	41 2f       	mov	r20, r17
    1624:	50 e0       	ldi	r21, 0x00	; 0
    1626:	9a 01       	movw	r18, r20
    1628:	22 0f       	add	r18, r18
    162a:	33 1f       	adc	r19, r19
    162c:	ca 01       	movw	r24, r20
    162e:	63 e0       	ldi	r22, 0x03	; 3
    1630:	88 0f       	add	r24, r24
    1632:	99 1f       	adc	r25, r25
    1634:	6a 95       	dec	r22
    1636:	e1 f7       	brne	.-8      	; 0x1630 <cpy_samp+0x136>
    1638:	28 0f       	add	r18, r24
    163a:	39 1f       	adc	r19, r25
    163c:	b9 01       	movw	r22, r18
    163e:	6c 57       	subi	r22, 0x7C	; 124
    1640:	7c 4f       	sbci	r23, 0xFC	; 252
    1642:	28 59       	subi	r18, 0x98	; 152
    1644:	3d 4f       	sbci	r19, 0xFD	; 253
    1646:	f9 01       	movw	r30, r18
    1648:	80 81       	ld	r24, Z
    164a:	91 81       	ldd	r25, Z+1	; 0x01
    164c:	fb 01       	movw	r30, r22
    164e:	91 83       	std	Z+1, r25	; 0x01
    1650:	80 83       	st	Z, r24
alph[samp_cnt][1]=shawn[samp_cnt][1];
    1652:	fa 01       	movw	r30, r20
    1654:	ee 0f       	add	r30, r30
    1656:	ff 1f       	adc	r31, r31
    1658:	ee 0f       	add	r30, r30
    165a:	ff 1f       	adc	r31, r31
    165c:	e4 0f       	add	r30, r20
    165e:	f5 1f       	adc	r31, r21
    1660:	31 96       	adiw	r30, 0x01	; 1
    1662:	ee 0f       	add	r30, r30
    1664:	ff 1f       	adc	r31, r31
    1666:	df 01       	movw	r26, r30
    1668:	a8 59       	subi	r26, 0x98	; 152
    166a:	bd 4f       	sbci	r27, 0xFD	; 253
    166c:	8d 91       	ld	r24, X+
    166e:	9c 91       	ld	r25, X
    1670:	ec 57       	subi	r30, 0x7C	; 124
    1672:	fc 4f       	sbci	r31, 0xFC	; 252
    1674:	91 83       	std	Z+1, r25	; 0x01
    1676:	80 83       	st	Z, r24
alph[samp_cnt][2]=shawn[samp_cnt][2];
    1678:	f9 01       	movw	r30, r18
    167a:	84 81       	ldd	r24, Z+4	; 0x04
    167c:	95 81       	ldd	r25, Z+5	; 0x05
    167e:	fb 01       	movw	r30, r22
    1680:	95 83       	std	Z+5, r25	; 0x05
    1682:	84 83       	std	Z+4, r24	; 0x04
alph[samp_cnt][3]=shawn[samp_cnt][3];
    1684:	f9 01       	movw	r30, r18
    1686:	86 81       	ldd	r24, Z+6	; 0x06
    1688:	97 81       	ldd	r25, Z+7	; 0x07
    168a:	fb 01       	movw	r30, r22
    168c:	97 83       	std	Z+7, r25	; 0x07
    168e:	86 83       	std	Z+6, r24	; 0x06
alph[samp_cnt][4]=shawn[samp_cnt][4];
    1690:	f9 01       	movw	r30, r18
    1692:	80 85       	ldd	r24, Z+8	; 0x08
    1694:	91 85       	ldd	r25, Z+9	; 0x09
    1696:	fb 01       	movw	r30, r22
    1698:	91 87       	std	Z+9, r25	; 0x09
    169a:	80 87       	std	Z+8, r24	; 0x08
    169c:	1f 5f       	subi	r17, 0xFF	; 255
}

break;

case 3:
for(samp_cnt=0;samp_cnt<26;samp_cnt++)
    169e:	1a 31       	cpi	r17, 0x1A	; 26
    16a0:	08 f4       	brcc	.+2      	; 0x16a4 <cpy_samp+0x1aa>
    16a2:	bf cf       	rjmp	.-130    	; 0x1622 <cpy_samp+0x128>
    16a4:	10 93 72 03 	sts	0x0372, r17
break;

//add more users here...
}

}
    16a8:	1f 91       	pop	r17
    16aa:	08 95       	ret

000016ac <user_ch>:


void user_ch()
{
txBuffer[1]=0xAA;
    16ac:	8a ea       	ldi	r24, 0xAA	; 170
    16ae:	80 93 52 07 	sts	0x0752, r24
txBuffer[2]=0x00;
    16b2:	10 92 53 07 	sts	0x0753, r1
txBuffer[3]=0x00;
    16b6:	10 92 54 07 	sts	0x0754, r1
txBuffer[4]=0x00;
    16ba:	10 92 55 07 	sts	0x0755, r1
txBuffer[5]=0x00;
    16be:	10 92 56 07 	sts	0x0756, r1
data_tx();
    16c2:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <data_tx>

key=key_read();
while(key=='/'){key=key_read();}
    16c6:	0e 94 7a 00 	call	0xf4	; 0xf4 <key_read>
    16ca:	80 93 50 07 	sts	0x0750, r24
    16ce:	20 91 50 07 	lds	r18, 0x0750
    16d2:	2f 32       	cpi	r18, 0x2F	; 47
    16d4:	c1 f3       	breq	.-16     	; 0x16c6 <user_ch+0x1a>
    16d6:	88 eb       	ldi	r24, 0xB8	; 184
    16d8:	9b e0       	ldi	r25, 0x0B	; 11
    16da:	40 e9       	ldi	r20, 0x90	; 144
    16dc:	51 e0       	ldi	r21, 0x01	; 1
    16de:	fa 01       	movw	r30, r20
    16e0:	31 97       	sbiw	r30, 0x01	; 1
    16e2:	f1 f7       	brne	.-4      	; 0x16e0 <user_ch+0x34>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    16e4:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    16e6:	d9 f7       	brne	.-10     	; 0x16de <user_ch+0x32>
_delay_ms(keypress);


switch(key)
    16e8:	22 33       	cpi	r18, 0x32	; 50
    16ea:	61 f0       	breq	.+24     	; 0x1704 <user_ch+0x58>
    16ec:	23 33       	cpi	r18, 0x33	; 51
    16ee:	91 f0       	breq	.+36     	; 0x1714 <user_ch+0x68>
    16f0:	21 33       	cpi	r18, 0x31	; 49
    16f2:	09 f5       	brne	.+66     	; 0x1736 <user_ch+0x8a>
{
case'1':cpy_samp(1);
    16f4:	81 e0       	ldi	r24, 0x01	; 1
    16f6:	0e 94 7d 0a 	call	0x14fa	; 0x14fa <cpy_samp>
        txBuffer[1]=0xAE;
    16fa:	8e ea       	ldi	r24, 0xAE	; 174
    16fc:	80 93 52 07 	sts	0x0752, r24
        txBuffer[2]=1;
    1700:	81 e0       	ldi	r24, 0x01	; 1
    1702:	0f c0       	rjmp	.+30     	; 0x1722 <user_ch+0x76>
        txBuffer[4]=0x00;
        txBuffer[5]=0x00;
        data_tx();
        break;

case'2':cpy_samp(2); 
    1704:	82 e0       	ldi	r24, 0x02	; 2
    1706:	0e 94 7d 0a 	call	0x14fa	; 0x14fa <cpy_samp>
        txBuffer[1]=0xAE;
    170a:	8e ea       	ldi	r24, 0xAE	; 174
    170c:	80 93 52 07 	sts	0x0752, r24
        txBuffer[2]=2;
    1710:	82 e0       	ldi	r24, 0x02	; 2
    1712:	07 c0       	rjmp	.+14     	; 0x1722 <user_ch+0x76>
        txBuffer[4]=0x00;
        txBuffer[5]=0x00;
        data_tx();
        break;

case'3':cpy_samp(3);
    1714:	83 e0       	ldi	r24, 0x03	; 3
    1716:	0e 94 7d 0a 	call	0x14fa	; 0x14fa <cpy_samp>
        txBuffer[1]=0xAE;
    171a:	8e ea       	ldi	r24, 0xAE	; 174
    171c:	80 93 52 07 	sts	0x0752, r24
        txBuffer[2]=3;
    1720:	83 e0       	ldi	r24, 0x03	; 3
    1722:	80 93 53 07 	sts	0x0753, r24
        txBuffer[3]=0x00;
    1726:	10 92 54 07 	sts	0x0754, r1
        txBuffer[4]=0x00;
    172a:	10 92 55 07 	sts	0x0755, r1
        txBuffer[5]=0x00;
    172e:	10 92 56 07 	sts	0x0756, r1
        data_tx();
    1732:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <data_tx>
    1736:	80 e6       	ldi	r24, 0x60	; 96
    1738:	9d e6       	ldi	r25, 0x6D	; 109
    173a:	20 e9       	ldi	r18, 0x90	; 144
    173c:	31 e0       	ldi	r19, 0x01	; 1
    173e:	f9 01       	movw	r30, r18
    1740:	31 97       	sbiw	r30, 0x01	; 1
    1742:	f1 f7       	brne	.-4      	; 0x1740 <user_ch+0x94>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1744:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1746:	d9 f7       	brne	.-10     	; 0x173e <user_ch+0x92>
        break;


}
_delay_ms(2800);
}
    1748:	08 95       	ret

0000174a <main>:




int main()   //main code...
{
    174a:	2f 92       	push	r2
    174c:	3f 92       	push	r3
    174e:	4f 92       	push	r4
    1750:	5f 92       	push	r5
    1752:	6f 92       	push	r6
    1754:	7f 92       	push	r7
    1756:	8f 92       	push	r8
    1758:	9f 92       	push	r9
    175a:	af 92       	push	r10
    175c:	bf 92       	push	r11
    175e:	cf 92       	push	r12
    1760:	df 92       	push	r13
    1762:	ef 92       	push	r14
    1764:	ff 92       	push	r15
    1766:	0f 93       	push	r16
    1768:	1f 93       	push	r17
    176a:	cf 93       	push	r28
    176c:	df 93       	push	r29


void init_adc()                 //initialize the ADC of the microcontroller
                                //call this function first at the beginning
{
ADMUX=(1<<REFS0);              //Aref joined to AVcc
    176e:	80 e4       	ldi	r24, 0x40	; 64
    1770:	87 b9       	out	0x07, r24	; 7
ADCSRA=(1<<ADEN)|(7<<ADPS0);
    1772:	87 e8       	ldi	r24, 0x87	; 135
    1774:	86 b9       	out	0x06, r24	; 6

init_adc();
cc2500_init();
    1776:	0e 94 fb 03 	call	0x7f6	; 0x7f6 <cc2500_init>
    177a:	e7 e9       	ldi	r30, 0x97	; 151
    177c:	f6 e0       	ldi	r31, 0x06	; 6

uint8_t cnt;

for(cnt=0;cnt<total_samples;cnt++)
{
samp[cnt][0]=0;
    177e:	11 82       	std	Z+1, r1	; 0x01
    1780:	10 82       	st	Z, r1
samp[cnt][1]=0;
    1782:	13 82       	std	Z+3, r1	; 0x03
    1784:	12 82       	std	Z+2, r1	; 0x02
samp[cnt][2]=0;
    1786:	15 82       	std	Z+5, r1	; 0x05
    1788:	14 82       	std	Z+4, r1	; 0x04
samp[cnt][3]=0;
    178a:	17 82       	std	Z+7, r1	; 0x07
    178c:	16 82       	std	Z+6, r1	; 0x06
samp[cnt][4]=0;
    178e:	11 86       	std	Z+9, r1	; 0x09
    1790:	10 86       	std	Z+8, r1	; 0x08
    1792:	3a 96       	adiw	r30, 0x0a	; 10
void init_array()
{

uint8_t cnt;

for(cnt=0;cnt<total_samples;cnt++)
    1794:	26 e0       	ldi	r18, 0x06	; 6
    1796:	eb 3f       	cpi	r30, 0xFB	; 251
    1798:	f2 07       	cpc	r31, r18
    179a:	89 f7       	brne	.-30     	; 0x177e <main+0x34>
    179c:	e6 e3       	ldi	r30, 0x36	; 54
    179e:	f7 e0       	ldi	r31, 0x07	; 7
alph[cnt][3]=0;
alph[cnt][4]=0;
}
*/

for(cnt=0;cnt<26;cnt++){prob[cnt]=0;}
    17a0:	11 92       	st	Z+, r1
    17a2:	87 e0       	ldi	r24, 0x07	; 7
    17a4:	e0 35       	cpi	r30, 0x50	; 80
    17a6:	f8 07       	cpc	r31, r24
    17a8:	d9 f7       	brne	.-10     	; 0x17a0 <main+0x56>
{

init_adc();
cc2500_init();
init_array();
user_ch();
    17aa:	0e 94 56 0b 	call	0x16ac	; 0x16ac <user_ch>

while(menu_select==1)
{
if(submenu_select==0)
{
txBuffer[1]=0x1F;
    17ae:	7f e1       	ldi	r23, 0x1F	; 31
    17b0:	27 2e       	mov	r2, r23
    17b2:	c0 e9       	ldi	r28, 0x90	; 144
    17b4:	d1 e0       	ldi	r29, 0x01	; 1
_delay_ms(keypress);
}

if(dev=='y')
{
txBuffer[1]=0x1A;
    17b6:	0a e1       	ldi	r16, 0x1A	; 26
txBuffer[2]=5;
    17b8:	65 e0       	ldi	r22, 0x05	; 5
    17ba:	76 2e       	mov	r7, r22
}

if(dev=='o')
{
txBuffer[1]=0x1A;
txBuffer[2]=4;
    17bc:	54 e0       	ldi	r21, 0x04	; 4
    17be:	65 2e       	mov	r6, r21
}

if(dev=='d')
{
txBuffer[1]=0x1A;
txBuffer[2]=3;
    17c0:	43 e0       	ldi	r20, 0x03	; 3
    17c2:	54 2e       	mov	r5, r20
}

if(dev=='b')
{
txBuffer[1]=0x1A;
txBuffer[2]=2;
    17c4:	32 e0       	ldi	r19, 0x02	; 2
    17c6:	43 2e       	mov	r4, r19
}

if(dev=='a')
{
txBuffer[1]=0x1A;
txBuffer[2]=1;
    17c8:	33 24       	eor	r3, r3
    17ca:	33 94       	inc	r3



while(1)  
{
submenu_select=0;
    17cc:	10 92 74 03 	sts	0x0374, r1
menu();
    17d0:	0e 94 f1 09 	call	0x13e2	; 0x13e2 <menu>
    17d4:	21 c0       	rjmp	.+66     	; 0x1818 <main+0xce>

//MENU 1: SIGN TO TEXT AND NUMBER MODE

while(menu_select==1)
{
if(submenu_select==0)
    17d6:	80 91 74 03 	lds	r24, 0x0374
    17da:	88 23       	and	r24, r24
    17dc:	79 f4       	brne	.+30     	; 0x17fc <main+0xb2>
{
txBuffer[1]=0x1F;
    17de:	20 92 52 07 	sts	0x0752, r2
txBuffer[2]=0x00;
    17e2:	10 92 53 07 	sts	0x0753, r1
txBuffer[3]=0x00;
    17e6:	10 92 54 07 	sts	0x0754, r1
txBuffer[4]=0x00;
    17ea:	10 92 55 07 	sts	0x0755, r1
txBuffer[5]=0x00;
    17ee:	10 92 56 07 	sts	0x0756, r1
data_tx();
    17f2:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <data_tx>
submenu();
    17f6:	0e 94 3b 0a 	call	0x1476	; 0x1476 <submenu>
    17fa:	0e c0       	rjmp	.+28     	; 0x1818 <main+0xce>
}

else if(submenu_select==1){char_disp();}
    17fc:	81 30       	cpi	r24, 0x01	; 1
    17fe:	19 f4       	brne	.+6      	; 0x1806 <main+0xbc>
    1800:	0e 94 88 07 	call	0xf10	; 0xf10 <char_disp>
    1804:	09 c0       	rjmp	.+18     	; 0x1818 <main+0xce>
else if(submenu_select==2){num_disp();}
    1806:	82 30       	cpi	r24, 0x02	; 2
    1808:	19 f4       	brne	.+6      	; 0x1810 <main+0xc6>
    180a:	0e 94 4c 04 	call	0x898	; 0x898 <num_disp>
    180e:	04 c0       	rjmp	.+8      	; 0x1818 <main+0xce>
else if(submenu_select==3){sp_char_disp();}
    1810:	83 30       	cpi	r24, 0x03	; 3
    1812:	11 f4       	brne	.+4      	; 0x1818 <main+0xce>
    1814:	0e 94 70 04 	call	0x8e0	; 0x8e0 <sp_char_disp>



//MENU 1: SIGN TO TEXT AND NUMBER MODE

while(menu_select==1)
    1818:	80 91 73 03 	lds	r24, 0x0373
    181c:	81 30       	cpi	r24, 0x01	; 1
    181e:	d9 f2       	breq	.-74     	; 0x17d6 <main+0x8c>
    1820:	27 c0       	rjmp	.+78     	; 0x1870 <main+0x126>
//MENU 2: KEYBOARD AND MOUSE MODE

while(menu_select==2)
{

if(submenu_select==0)
    1822:	80 91 74 03 	lds	r24, 0x0374
    1826:	88 23       	and	r24, r24
    1828:	81 f4       	brne	.+32     	; 0x184a <main+0x100>
{
txBuffer[1]=0x2F;
    182a:	2f e2       	ldi	r18, 0x2F	; 47
    182c:	20 93 52 07 	sts	0x0752, r18
txBuffer[2]=0x00;
    1830:	10 92 53 07 	sts	0x0753, r1
txBuffer[3]=0x00;
    1834:	10 92 54 07 	sts	0x0754, r1
txBuffer[4]=0x00;
    1838:	10 92 55 07 	sts	0x0755, r1
txBuffer[5]=0x00;
    183c:	10 92 56 07 	sts	0x0756, r1
data_tx();
    1840:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <data_tx>
submenu();
    1844:	0e 94 3b 0a 	call	0x1476	; 0x1476 <submenu>
    1848:	13 c0       	rjmp	.+38     	; 0x1870 <main+0x126>
}

else if(submenu_select==1){char_disp();}
    184a:	81 30       	cpi	r24, 0x01	; 1
    184c:	19 f4       	brne	.+6      	; 0x1854 <main+0x10a>
    184e:	0e 94 88 07 	call	0xf10	; 0xf10 <char_disp>
    1852:	0e c0       	rjmp	.+28     	; 0x1870 <main+0x126>
else if(submenu_select==2){num_disp();}
    1854:	82 30       	cpi	r24, 0x02	; 2
    1856:	19 f4       	brne	.+6      	; 0x185e <main+0x114>
    1858:	0e 94 4c 04 	call	0x898	; 0x898 <num_disp>
    185c:	09 c0       	rjmp	.+18     	; 0x1870 <main+0x126>
else if(submenu_select==3){sp_char_disp();}
    185e:	83 30       	cpi	r24, 0x03	; 3
    1860:	19 f4       	brne	.+6      	; 0x1868 <main+0x11e>
    1862:	0e 94 70 04 	call	0x8e0	; 0x8e0 <sp_char_disp>
    1866:	04 c0       	rjmp	.+8      	; 0x1870 <main+0x126>
else if(submenu_select==4){mousedata_tx();}
    1868:	84 30       	cpi	r24, 0x04	; 4
    186a:	11 f4       	brne	.+4      	; 0x1870 <main+0x126>
    186c:	0e 94 99 08 	call	0x1132	; 0x1132 <mousedata_tx>



//MENU 2: KEYBOARD AND MOUSE MODE

while(menu_select==2)
    1870:	80 91 73 03 	lds	r24, 0x0373
    1874:	82 30       	cpi	r24, 0x02	; 2
    1876:	a9 f2       	breq	.-86     	; 0x1822 <main+0xd8>
    1878:	cc c0       	rjmp	.+408    	; 0x1a12 <main+0x2c8>
//MENU 3: APPLIANCE CONTROL MODE

while(menu_select==3)
{

key=key_read();
    187a:	0e 94 7a 00 	call	0xf4	; 0xf4 <key_read>
    187e:	80 93 50 07 	sts	0x0750, r24
    1882:	12 c0       	rjmp	.+36     	; 0x18a8 <main+0x15e>
while(key=='/'){key=key_read();if(read_adc(7)>alp_puts){key='*';break;}}
    1884:	0e 94 7a 00 	call	0xf4	; 0xf4 <key_read>
    1888:	80 93 50 07 	sts	0x0750, r24
   //Select ADC Channel ch must be 0-7 (corresponds to the flex sensors...)
   //flex sensors from channel 0-4
   //acccelerometer from channel 5-7
   
   //ch=ch & 0b00000111;
   ADMUX = ch;
    188c:	87 e0       	ldi	r24, 0x07	; 7
    188e:	87 b9       	out	0x07, r24	; 7

   //Start Single conversion
   ADCSRA|=(1<<ADSC);
    1890:	36 9a       	sbi	0x06, 6	; 6

   //Wait for conversion to complete
   while(!(ADCSRA & (1<<ADIF)));
    1892:	34 9b       	sbis	0x06, 4	; 6
    1894:	fe cf       	rjmp	.-4      	; 0x1892 <main+0x148>

   //Clear ADIF by writing one to it
   ADCSRA|=(1<<ADIF);
    1896:	34 9a       	sbi	0x06, 4	; 6

   return(ADCW);
    1898:	84 b1       	in	r24, 0x04	; 4
    189a:	95 b1       	in	r25, 0x05	; 5
    189c:	87 5d       	subi	r24, 0xD7	; 215
    189e:	91 40       	sbci	r25, 0x01	; 1
    18a0:	18 f0       	brcs	.+6      	; 0x18a8 <main+0x15e>
    18a2:	10 93 50 07 	sts	0x0750, r17
    18a6:	04 c0       	rjmp	.+8      	; 0x18b0 <main+0x166>
    18a8:	80 91 50 07 	lds	r24, 0x0750
    18ac:	8f 32       	cpi	r24, 0x2F	; 47
    18ae:	51 f3       	breq	.-44     	; 0x1884 <main+0x13a>

if(key=='*')    //normal small characters
    18b0:	80 91 50 07 	lds	r24, 0x0750
    18b4:	8a 32       	cpi	r24, 0x2A	; 42
    18b6:	61 f5       	brne	.+88     	; 0x1910 <main+0x1c6>
    18b8:	e7 e9       	ldi	r30, 0x97	; 151
    18ba:	f6 e0       	ldi	r31, 0x06	; 6

uint8_t cnt;

for(cnt=0;cnt<total_samples;cnt++)
{
samp[cnt][0]=0;
    18bc:	11 82       	std	Z+1, r1	; 0x01
    18be:	10 82       	st	Z, r1
samp[cnt][1]=0;
    18c0:	13 82       	std	Z+3, r1	; 0x03
    18c2:	12 82       	std	Z+2, r1	; 0x02
samp[cnt][2]=0;
    18c4:	15 82       	std	Z+5, r1	; 0x05
    18c6:	14 82       	std	Z+4, r1	; 0x04
samp[cnt][3]=0;
    18c8:	17 82       	std	Z+7, r1	; 0x07
    18ca:	16 82       	std	Z+6, r1	; 0x06
samp[cnt][4]=0;
    18cc:	11 86       	std	Z+9, r1	; 0x09
    18ce:	10 86       	std	Z+8, r1	; 0x08
    18d0:	3a 96       	adiw	r30, 0x0a	; 10
void init_array()
{

uint8_t cnt;

for(cnt=0;cnt<total_samples;cnt++)
    18d2:	86 e0       	ldi	r24, 0x06	; 6
    18d4:	eb 3f       	cpi	r30, 0xFB	; 251
    18d6:	f8 07       	cpc	r31, r24
    18d8:	89 f7       	brne	.-30     	; 0x18bc <main+0x172>
    18da:	e6 e3       	ldi	r30, 0x36	; 54
    18dc:	f7 e0       	ldi	r31, 0x07	; 7
alph[cnt][3]=0;
alph[cnt][4]=0;
}
*/

for(cnt=0;cnt<26;cnt++){prob[cnt]=0;}
    18de:	11 92       	st	Z+, r1
    18e0:	27 e0       	ldi	r18, 0x07	; 7
    18e2:	e0 35       	cpi	r30, 0x50	; 80
    18e4:	f2 07       	cpc	r31, r18
    18e6:	d9 f7       	brne	.-10     	; 0x18de <main+0x194>

if(key=='*')    //normal small characters
{
init_array();
//load_val();
take_samples();
    18e8:	0e 94 00 07 	call	0xe00	; 0xe00 <take_samples>
matched_char = patt_match();
    18ec:	0e 94 a7 05 	call	0xb4e	; 0xb4e <patt_match>
    18f0:	80 93 8a 04 	sts	0x048A, r24
if(matched_char!='*')
    18f4:	8a 32       	cpi	r24, 0x2A	; 42
    18f6:	51 f0       	breq	.+20     	; 0x190c <main+0x1c2>
{
dev=matched_char;
    18f8:	80 93 76 03 	sts	0x0376, r24
    18fc:	88 eb       	ldi	r24, 0xB8	; 184
    18fe:	9b e0       	ldi	r25, 0x0B	; 11
    1900:	fe 01       	movw	r30, r28
    1902:	31 97       	sbiw	r30, 0x01	; 1
    1904:	f1 f7       	brne	.-4      	; 0x1902 <main+0x1b8>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1906:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1908:	d9 f7       	brne	.-10     	; 0x1900 <main+0x1b6>
    190a:	02 c0       	rjmp	.+4      	; 0x1910 <main+0x1c6>
_delay_ms(keypress);
}
else{dev=0;}
    190c:	10 92 76 03 	sts	0x0376, r1
}

if(dev=='a')
    1910:	80 91 76 03 	lds	r24, 0x0376
    1914:	81 36       	cpi	r24, 0x61	; 97
    1916:	99 f4       	brne	.+38     	; 0x193e <main+0x1f4>
{
txBuffer[1]=0x1A;
    1918:	00 93 52 07 	sts	0x0752, r16
txBuffer[2]=1;
    191c:	30 92 53 07 	sts	0x0753, r3
txBuffer[3]=0x00;
    1920:	10 92 54 07 	sts	0x0754, r1
txBuffer[4]=0x00;
    1924:	10 92 55 07 	sts	0x0755, r1
txBuffer[5]=0x00;
    1928:	10 92 56 07 	sts	0x0756, r1
data_tx();
    192c:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <data_tx>
    1930:	88 eb       	ldi	r24, 0xB8	; 184
    1932:	9b e0       	ldi	r25, 0x0B	; 11
    1934:	fe 01       	movw	r30, r28
    1936:	31 97       	sbiw	r30, 0x01	; 1
    1938:	f1 f7       	brne	.-4      	; 0x1936 <main+0x1ec>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    193a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    193c:	d9 f7       	brne	.-10     	; 0x1934 <main+0x1ea>
_delay_ms(keypress);
}

if(dev=='b')
    193e:	80 91 76 03 	lds	r24, 0x0376
    1942:	82 36       	cpi	r24, 0x62	; 98
    1944:	99 f4       	brne	.+38     	; 0x196c <main+0x222>
{
txBuffer[1]=0x1A;
    1946:	00 93 52 07 	sts	0x0752, r16
txBuffer[2]=2;
    194a:	40 92 53 07 	sts	0x0753, r4
txBuffer[3]=0x00;
    194e:	10 92 54 07 	sts	0x0754, r1
txBuffer[4]=0x00;
    1952:	10 92 55 07 	sts	0x0755, r1
txBuffer[5]=0x00;
    1956:	10 92 56 07 	sts	0x0756, r1
data_tx();
    195a:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <data_tx>
    195e:	88 eb       	ldi	r24, 0xB8	; 184
    1960:	9b e0       	ldi	r25, 0x0B	; 11
    1962:	fe 01       	movw	r30, r28
    1964:	31 97       	sbiw	r30, 0x01	; 1
    1966:	f1 f7       	brne	.-4      	; 0x1964 <main+0x21a>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1968:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    196a:	d9 f7       	brne	.-10     	; 0x1962 <main+0x218>
_delay_ms(keypress);
}

if(dev=='d')
    196c:	80 91 76 03 	lds	r24, 0x0376
    1970:	84 36       	cpi	r24, 0x64	; 100
    1972:	99 f4       	brne	.+38     	; 0x199a <main+0x250>
{
txBuffer[1]=0x1A;
    1974:	00 93 52 07 	sts	0x0752, r16
txBuffer[2]=3;
    1978:	50 92 53 07 	sts	0x0753, r5
txBuffer[3]=0x00;
    197c:	10 92 54 07 	sts	0x0754, r1
txBuffer[4]=0x00;
    1980:	10 92 55 07 	sts	0x0755, r1
txBuffer[5]=0x00;
    1984:	10 92 56 07 	sts	0x0756, r1
data_tx();
    1988:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <data_tx>
    198c:	88 eb       	ldi	r24, 0xB8	; 184
    198e:	9b e0       	ldi	r25, 0x0B	; 11
    1990:	fe 01       	movw	r30, r28
    1992:	31 97       	sbiw	r30, 0x01	; 1
    1994:	f1 f7       	brne	.-4      	; 0x1992 <main+0x248>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1996:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1998:	d9 f7       	brne	.-10     	; 0x1990 <main+0x246>
_delay_ms(keypress);
}

if(dev=='o')
    199a:	80 91 76 03 	lds	r24, 0x0376
    199e:	8f 36       	cpi	r24, 0x6F	; 111
    19a0:	99 f4       	brne	.+38     	; 0x19c8 <main+0x27e>
{
txBuffer[1]=0x1A;
    19a2:	00 93 52 07 	sts	0x0752, r16
txBuffer[2]=4;
    19a6:	60 92 53 07 	sts	0x0753, r6
txBuffer[3]=0x00;
    19aa:	10 92 54 07 	sts	0x0754, r1
txBuffer[4]=0x00;
    19ae:	10 92 55 07 	sts	0x0755, r1
txBuffer[5]=0x00;
    19b2:	10 92 56 07 	sts	0x0756, r1
data_tx();
    19b6:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <data_tx>
    19ba:	88 eb       	ldi	r24, 0xB8	; 184
    19bc:	9b e0       	ldi	r25, 0x0B	; 11
    19be:	fe 01       	movw	r30, r28
    19c0:	31 97       	sbiw	r30, 0x01	; 1
    19c2:	f1 f7       	brne	.-4      	; 0x19c0 <main+0x276>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    19c4:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    19c6:	d9 f7       	brne	.-10     	; 0x19be <main+0x274>
_delay_ms(keypress);
}

if(dev=='y')
    19c8:	80 91 76 03 	lds	r24, 0x0376
    19cc:	89 37       	cpi	r24, 0x79	; 121
    19ce:	99 f4       	brne	.+38     	; 0x19f6 <main+0x2ac>
{
txBuffer[1]=0x1A;
    19d0:	00 93 52 07 	sts	0x0752, r16
txBuffer[2]=5;
    19d4:	70 92 53 07 	sts	0x0753, r7
txBuffer[3]=0x00;
    19d8:	10 92 54 07 	sts	0x0754, r1
txBuffer[4]=0x00;
    19dc:	10 92 55 07 	sts	0x0755, r1
txBuffer[5]=0x00;
    19e0:	10 92 56 07 	sts	0x0756, r1
data_tx();
    19e4:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <data_tx>
    19e8:	88 eb       	ldi	r24, 0xB8	; 184
    19ea:	9b e0       	ldi	r25, 0x0B	; 11
    19ec:	fe 01       	movw	r30, r28
    19ee:	31 97       	sbiw	r30, 0x01	; 1
    19f0:	f1 f7       	brne	.-4      	; 0x19ee <main+0x2a4>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    19f2:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    19f4:	d9 f7       	brne	.-10     	; 0x19ec <main+0x2a2>
_delay_ms(keypress);
}

if(key=='9')//EXIT.... go out of sub menu to main menu
    19f6:	80 91 50 07 	lds	r24, 0x0750
    19fa:	89 33       	cpi	r24, 0x39	; 57
    19fc:	59 f4       	brne	.+22     	; 0x1a14 <main+0x2ca>
{
menu_select=0;
    19fe:	10 92 73 03 	sts	0x0373, r1
    1a02:	88 eb       	ldi	r24, 0xB8	; 184
    1a04:	9b e0       	ldi	r25, 0x0B	; 11
    1a06:	fe 01       	movw	r30, r28
    1a08:	31 97       	sbiw	r30, 0x01	; 1
    1a0a:	f1 f7       	brne	.-4      	; 0x1a08 <main+0x2be>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1a0c:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1a0e:	d9 f7       	brne	.-10     	; 0x1a06 <main+0x2bc>
    1a10:	01 c0       	rjmp	.+2      	; 0x1a14 <main+0x2ca>

while(menu_select==3)
{

key=key_read();
while(key=='/'){key=key_read();if(read_adc(7)>alp_puts){key='*';break;}}
    1a12:	1a e2       	ldi	r17, 0x2A	; 42



//MENU 3: APPLIANCE CONTROL MODE

while(menu_select==3)
    1a14:	80 91 73 03 	lds	r24, 0x0373
    1a18:	83 30       	cpi	r24, 0x03	; 3
    1a1a:	09 f4       	brne	.+2      	; 0x1a1e <main+0x2d4>
    1a1c:	2e cf       	rjmp	.-420    	; 0x187a <main+0x130>
    1a1e:	cc c0       	rjmp	.+408    	; 0x1bb8 <main+0x46e>
   //Select ADC Channel ch must be 0-7 (corresponds to the flex sensors...)
   //flex sensors from channel 0-4
   //acccelerometer from channel 5-7
   
   //ch=ch & 0b00000111;
   ADMUX = ch;
    1a20:	85 e0       	ldi	r24, 0x05	; 5
    1a22:	87 b9       	out	0x07, r24	; 7

   //Start Single conversion
   ADCSRA|=(1<<ADSC);
    1a24:	36 9a       	sbi	0x06, 6	; 6

   //Wait for conversion to complete
   while(!(ADCSRA & (1<<ADIF)));
    1a26:	34 9b       	sbis	0x06, 4	; 6
    1a28:	fe cf       	rjmp	.-4      	; 0x1a26 <main+0x2dc>

   //Clear ADIF by writing one to it
   ADCSRA|=(1<<ADIF);
    1a2a:	34 9a       	sbi	0x06, 4	; 6

   return(ADCW);
    1a2c:	84 b1       	in	r24, 0x04	; 4
    1a2e:	95 b1       	in	r25, 0x05	; 5
//MENU 4: ROBOT CONTROL MODE

while(menu_select==4)
{

robo_y=read_adc(5);
    1a30:	90 93 fc 06 	sts	0x06FC, r25
    1a34:	80 93 fb 06 	sts	0x06FB, r24
   //Select ADC Channel ch must be 0-7 (corresponds to the flex sensors...)
   //flex sensors from channel 0-4
   //acccelerometer from channel 5-7
   
   //ch=ch & 0b00000111;
   ADMUX = ch;
    1a38:	87 b8       	out	0x07, r8	; 7

   //Start Single conversion
   ADCSRA|=(1<<ADSC);
    1a3a:	36 9a       	sbi	0x06, 6	; 6

   //Wait for conversion to complete
   while(!(ADCSRA & (1<<ADIF)));
    1a3c:	34 9b       	sbis	0x06, 4	; 6
    1a3e:	fe cf       	rjmp	.-4      	; 0x1a3c <main+0x2f2>

   //Clear ADIF by writing one to it
   ADCSRA|=(1<<ADIF);
    1a40:	34 9a       	sbi	0x06, 4	; 6

   return(ADCW);
    1a42:	44 b1       	in	r20, 0x04	; 4
    1a44:	55 b1       	in	r21, 0x05	; 5
robo_x=read_adc(6);
    1a46:	50 93 89 04 	sts	0x0489, r21
    1a4a:	40 93 88 04 	sts	0x0488, r20

if((robo_y > 250 )&&(robo_y < 310))//back
    1a4e:	20 91 fb 06 	lds	r18, 0x06FB
    1a52:	30 91 fc 06 	lds	r19, 0x06FC
    1a56:	c9 01       	movw	r24, r18
    1a58:	8b 5f       	subi	r24, 0xFB	; 251
    1a5a:	90 40       	sbci	r25, 0x00	; 0
    1a5c:	cb 97       	sbiw	r24, 0x3b	; 59
    1a5e:	38 f4       	brcc	.+14     	; 0x1a6e <main+0x324>
{
txBuffer[1]=mode;
    1a60:	80 91 6c 03 	lds	r24, 0x036C
    1a64:	80 93 52 07 	sts	0x0752, r24
txBuffer[2]=0xBB;
    1a68:	b0 92 53 07 	sts	0x0753, r11
    1a6c:	28 c0       	rjmp	.+80     	; 0x1abe <main+0x374>
txBuffer[4]=0x00;
txBuffer[5]=0x00;
data_tx();
}

else if((robo_y > 350 )&&(robo_y < 400))//forward
    1a6e:	2f 55       	subi	r18, 0x5F	; 95
    1a70:	31 40       	sbci	r19, 0x01	; 1
    1a72:	21 33       	cpi	r18, 0x31	; 49
    1a74:	31 05       	cpc	r19, r1
    1a76:	38 f4       	brcc	.+14     	; 0x1a86 <main+0x33c>
{
txBuffer[1]=mode;
    1a78:	80 91 6c 03 	lds	r24, 0x036C
    1a7c:	80 93 52 07 	sts	0x0752, r24
txBuffer[2]=0xAB;
    1a80:	c0 92 53 07 	sts	0x0753, r12
    1a84:	1c c0       	rjmp	.+56     	; 0x1abe <main+0x374>
txBuffer[4]=0x00;
txBuffer[5]=0x00;
data_tx();
}

else if((robo_x > 250 )&&(robo_x < 310))//right turn
    1a86:	ca 01       	movw	r24, r20
    1a88:	8b 5f       	subi	r24, 0xFB	; 251
    1a8a:	90 40       	sbci	r25, 0x00	; 0
    1a8c:	cb 97       	sbiw	r24, 0x3b	; 59
    1a8e:	38 f4       	brcc	.+14     	; 0x1a9e <main+0x354>
{
txBuffer[1]=mode;
    1a90:	80 91 6c 03 	lds	r24, 0x036C
    1a94:	80 93 52 07 	sts	0x0752, r24
txBuffer[2]=0xDB;
    1a98:	90 92 53 07 	sts	0x0753, r9
    1a9c:	10 c0       	rjmp	.+32     	; 0x1abe <main+0x374>
txBuffer[4]=0x00;
txBuffer[5]=0x00;
data_tx();
}

else if((robo_x > 350 )&&(robo_x < 400))//left turn
    1a9e:	4f 55       	subi	r20, 0x5F	; 95
    1aa0:	51 40       	sbci	r21, 0x01	; 1
    1aa2:	80 91 6c 03 	lds	r24, 0x036C
    1aa6:	41 33       	cpi	r20, 0x31	; 49
    1aa8:	51 05       	cpc	r21, r1
    1aaa:	28 f4       	brcc	.+10     	; 0x1ab6 <main+0x36c>
{
txBuffer[1]=mode;
    1aac:	80 93 52 07 	sts	0x0752, r24
txBuffer[2]=0xCB;
    1ab0:	a0 92 53 07 	sts	0x0753, r10
    1ab4:	04 c0       	rjmp	.+8      	; 0x1abe <main+0x374>
}

else //stop
{

txBuffer[1]=mode;
    1ab6:	80 93 52 07 	sts	0x0752, r24
txBuffer[2]=0x00;
    1aba:	10 92 53 07 	sts	0x0753, r1
txBuffer[3]=0x00;
    1abe:	10 92 54 07 	sts	0x0754, r1
txBuffer[4]=0x00;
    1ac2:	10 92 55 07 	sts	0x0755, r1
txBuffer[5]=0x00;
    1ac6:	10 92 56 07 	sts	0x0756, r1
data_tx();
    1aca:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <data_tx>
}


key=key_read();
    1ace:	0e 94 7a 00 	call	0xf4	; 0xf4 <key_read>
    1ad2:	80 93 50 07 	sts	0x0750, r24

if(key=='9')//EXIT.... go out of sub menu to main menu
    1ad6:	89 33       	cpi	r24, 0x39	; 57
    1ad8:	51 f4       	brne	.+20     	; 0x1aee <main+0x3a4>
{
menu_select=0;
    1ada:	10 92 73 03 	sts	0x0373, r1
    1ade:	88 eb       	ldi	r24, 0xB8	; 184
    1ae0:	9b e0       	ldi	r25, 0x0B	; 11
    1ae2:	fe 01       	movw	r30, r28
    1ae4:	31 97       	sbiw	r30, 0x01	; 1
    1ae6:	f1 f7       	brne	.-4      	; 0x1ae4 <main+0x39a>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1ae8:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1aea:	d9 f7       	brne	.-10     	; 0x1ae2 <main+0x398>
    1aec:	17 c0       	rjmp	.+46     	; 0x1b1c <main+0x3d2>
_delay_ms(keypress);
}      

if(key=='1')//select user mode on robot
    1aee:	81 33       	cpi	r24, 0x31	; 49
    1af0:	a9 f4       	brne	.+42     	; 0x1b1c <main+0x3d2>
{
mode=0x1B;
    1af2:	10 93 6c 03 	sts	0x036C, r17
txBuffer[1]=mode;
    1af6:	10 93 52 07 	sts	0x0752, r17
txBuffer[2]=0x00;
    1afa:	10 92 53 07 	sts	0x0753, r1
txBuffer[3]=0x00;
    1afe:	10 92 54 07 	sts	0x0754, r1
txBuffer[4]=0x00;
    1b02:	10 92 55 07 	sts	0x0755, r1
txBuffer[5]=0x00;
    1b06:	10 92 56 07 	sts	0x0756, r1
data_tx();
    1b0a:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <data_tx>
    1b0e:	88 eb       	ldi	r24, 0xB8	; 184
    1b10:	9b e0       	ldi	r25, 0x0B	; 11
    1b12:	fe 01       	movw	r30, r28
    1b14:	31 97       	sbiw	r30, 0x01	; 1
    1b16:	f1 f7       	brne	.-4      	; 0x1b14 <main+0x3ca>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1b18:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1b1a:	d9 f7       	brne	.-10     	; 0x1b12 <main+0x3c8>
_delay_ms(keypress);
}      

if(key=='2')//select training mode on robot
    1b1c:	80 91 50 07 	lds	r24, 0x0750
    1b20:	82 33       	cpi	r24, 0x32	; 50
    1b22:	a9 f4       	brne	.+42     	; 0x1b4e <main+0x404>
{
mode=0x2B;
    1b24:	d0 92 6c 03 	sts	0x036C, r13
txBuffer[1]=mode;
    1b28:	d0 92 52 07 	sts	0x0752, r13
txBuffer[2]=0x00;
    1b2c:	10 92 53 07 	sts	0x0753, r1
txBuffer[3]=0x00;
    1b30:	10 92 54 07 	sts	0x0754, r1
txBuffer[4]=0x00;
    1b34:	10 92 55 07 	sts	0x0755, r1
txBuffer[5]=0x00;
    1b38:	10 92 56 07 	sts	0x0756, r1
data_tx();
    1b3c:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <data_tx>
    1b40:	88 eb       	ldi	r24, 0xB8	; 184
    1b42:	9b e0       	ldi	r25, 0x0B	; 11
    1b44:	fe 01       	movw	r30, r28
    1b46:	31 97       	sbiw	r30, 0x01	; 1
    1b48:	f1 f7       	brne	.-4      	; 0x1b46 <main+0x3fc>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1b4a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1b4c:	d9 f7       	brne	.-10     	; 0x1b44 <main+0x3fa>
_delay_ms(keypress);
}      

if(key=='3')//select auto mode on robot
    1b4e:	80 91 50 07 	lds	r24, 0x0750
    1b52:	83 33       	cpi	r24, 0x33	; 51
    1b54:	a9 f4       	brne	.+42     	; 0x1b80 <main+0x436>
{
mode=0x3B;
    1b56:	f0 92 6c 03 	sts	0x036C, r15
txBuffer[1]=mode;
    1b5a:	f0 92 52 07 	sts	0x0752, r15
txBuffer[2]=0x00;
    1b5e:	10 92 53 07 	sts	0x0753, r1
txBuffer[3]=0x00;
    1b62:	10 92 54 07 	sts	0x0754, r1
txBuffer[4]=0x00;
    1b66:	10 92 55 07 	sts	0x0755, r1
txBuffer[5]=0x00;
    1b6a:	10 92 56 07 	sts	0x0756, r1
data_tx();
    1b6e:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <data_tx>
    1b72:	88 eb       	ldi	r24, 0xB8	; 184
    1b74:	9b e0       	ldi	r25, 0x0B	; 11
    1b76:	fe 01       	movw	r30, r28
    1b78:	31 97       	sbiw	r30, 0x01	; 1
    1b7a:	f1 f7       	brne	.-4      	; 0x1b78 <main+0x42e>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1b7c:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1b7e:	d9 f7       	brne	.-10     	; 0x1b76 <main+0x42c>
_delay_ms(keypress);
}      

if(key=='4')//select clear memory on robot
    1b80:	80 91 50 07 	lds	r24, 0x0750
    1b84:	84 33       	cpi	r24, 0x34	; 52
    1b86:	49 f5       	brne	.+82     	; 0x1bda <main+0x490>
{
mode=0x4B;
    1b88:	e0 92 6c 03 	sts	0x036C, r14
txBuffer[1]=mode;
    1b8c:	e0 92 52 07 	sts	0x0752, r14
txBuffer[2]=0x00;
    1b90:	10 92 53 07 	sts	0x0753, r1
txBuffer[3]=0x00;
    1b94:	10 92 54 07 	sts	0x0754, r1
txBuffer[4]=0x00;
    1b98:	10 92 55 07 	sts	0x0755, r1
txBuffer[5]=0x00;
    1b9c:	10 92 56 07 	sts	0x0756, r1
data_tx();
    1ba0:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <data_tx>
    1ba4:	88 eb       	ldi	r24, 0xB8	; 184
    1ba6:	9b e0       	ldi	r25, 0x0B	; 11
    1ba8:	fe 01       	movw	r30, r28
    1baa:	31 97       	sbiw	r30, 0x01	; 1
    1bac:	f1 f7       	brne	.-4      	; 0x1baa <main+0x460>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1bae:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1bb0:	d9 f7       	brne	.-10     	; 0x1ba8 <main+0x45e>
_delay_ms(keypress);
mode=0x1B;
    1bb2:	10 93 6c 03 	sts	0x036C, r17
    1bb6:	11 c0       	rjmp	.+34     	; 0x1bda <main+0x490>
   //Select ADC Channel ch must be 0-7 (corresponds to the flex sensors...)
   //flex sensors from channel 0-4
   //acccelerometer from channel 5-7
   
   //ch=ch & 0b00000111;
   ADMUX = ch;
    1bb8:	26 e0       	ldi	r18, 0x06	; 6
    1bba:	82 2e       	mov	r8, r18
}

else if((robo_x > 350 )&&(robo_x < 400))//left turn
{
txBuffer[1]=mode;
txBuffer[2]=0xCB;
    1bbc:	9b ec       	ldi	r25, 0xCB	; 203
    1bbe:	a9 2e       	mov	r10, r25
}

else if((robo_x > 250 )&&(robo_x < 310))//right turn
{
txBuffer[1]=mode;
txBuffer[2]=0xDB;
    1bc0:	8b ed       	ldi	r24, 0xDB	; 219
    1bc2:	98 2e       	mov	r9, r24
}

else if((robo_y > 350 )&&(robo_y < 400))//forward
{
txBuffer[1]=mode;
txBuffer[2]=0xAB;
    1bc4:	1b ea       	ldi	r17, 0xAB	; 171
    1bc6:	c1 2e       	mov	r12, r17
robo_x=read_adc(6);

if((robo_y > 250 )&&(robo_y < 310))//back
{
txBuffer[1]=mode;
txBuffer[2]=0xBB;
    1bc8:	bb eb       	ldi	r27, 0xBB	; 187
    1bca:	bb 2e       	mov	r11, r27
_delay_ms(keypress);
}      

if(key=='1')//select user mode on robot
{
mode=0x1B;
    1bcc:	1b e1       	ldi	r17, 0x1B	; 27
_delay_ms(keypress);
}      

if(key=='2')//select training mode on robot
{
mode=0x2B;
    1bce:	ab e2       	ldi	r26, 0x2B	; 43
    1bd0:	da 2e       	mov	r13, r26
_delay_ms(keypress);
}      

if(key=='3')//select auto mode on robot
{
mode=0x3B;
    1bd2:	fb e3       	ldi	r31, 0x3B	; 59
    1bd4:	ff 2e       	mov	r15, r31
_delay_ms(keypress);
}      

if(key=='4')//select clear memory on robot
{
mode=0x4B;
    1bd6:	eb e4       	ldi	r30, 0x4B	; 75
    1bd8:	ee 2e       	mov	r14, r30

}

//MENU 4: ROBOT CONTROL MODE

while(menu_select==4)
    1bda:	80 91 73 03 	lds	r24, 0x0373
    1bde:	84 30       	cpi	r24, 0x04	; 4
    1be0:	09 f0       	breq	.+2      	; 0x1be4 <main+0x49a>
    1be2:	f4 cd       	rjmp	.-1048   	; 0x17cc <main+0x82>
    1be4:	1d cf       	rjmp	.-454    	; 0x1a20 <main+0x2d6>

00001be6 <__udivmodhi4>:
    1be6:	aa 1b       	sub	r26, r26
    1be8:	bb 1b       	sub	r27, r27
    1bea:	51 e1       	ldi	r21, 0x11	; 17
    1bec:	07 c0       	rjmp	.+14     	; 0x1bfc <__udivmodhi4_ep>

00001bee <__udivmodhi4_loop>:
    1bee:	aa 1f       	adc	r26, r26
    1bf0:	bb 1f       	adc	r27, r27
    1bf2:	a6 17       	cp	r26, r22
    1bf4:	b7 07       	cpc	r27, r23
    1bf6:	10 f0       	brcs	.+4      	; 0x1bfc <__udivmodhi4_ep>
    1bf8:	a6 1b       	sub	r26, r22
    1bfa:	b7 0b       	sbc	r27, r23

00001bfc <__udivmodhi4_ep>:
    1bfc:	88 1f       	adc	r24, r24
    1bfe:	99 1f       	adc	r25, r25
    1c00:	5a 95       	dec	r21
    1c02:	a9 f7       	brne	.-22     	; 0x1bee <__udivmodhi4_loop>
    1c04:	80 95       	com	r24
    1c06:	90 95       	com	r25
    1c08:	bc 01       	movw	r22, r24
    1c0a:	cd 01       	movw	r24, r26
    1c0c:	08 95       	ret

00001c0e <_exit>:
    1c0e:	f8 94       	cli

00001c10 <__stop_program>:
    1c10:	ff cf       	rjmp	.-2      	; 0x1c10 <__stop_program>
