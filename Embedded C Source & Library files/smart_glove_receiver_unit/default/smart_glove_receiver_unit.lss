
smart_glove_receiver_unit.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00006ac2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000408  00800060  00006ac2  00006b56  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000000d7  00800468  00800468  00006f5e  2**0
                  ALLOC
  3 .debug_aranges 00000040  00000000  00000000  00006f5e  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 000005b2  00000000  00000000  00006f9e  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00004e25  00000000  00000000  00007550  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000655  00000000  00000000  0000c375  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00003ce6  00000000  00000000  0000c9ca  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000550  00000000  00000000  000106b0  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000646  00000000  00000000  00010c00  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00003057  00000000  00000000  00011246  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000828  00000000  00000000  0001429d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 12 	jmp	0x2454	; 0x2454 <__ctors_end>
       4:	0c 94 47 12 	jmp	0x248e	; 0x248e <__bad_interrupt>
       8:	0c 94 47 12 	jmp	0x248e	; 0x248e <__bad_interrupt>
       c:	0c 94 47 12 	jmp	0x248e	; 0x248e <__bad_interrupt>
      10:	0c 94 47 12 	jmp	0x248e	; 0x248e <__bad_interrupt>
      14:	0c 94 47 12 	jmp	0x248e	; 0x248e <__bad_interrupt>
      18:	0c 94 47 12 	jmp	0x248e	; 0x248e <__bad_interrupt>
      1c:	0c 94 47 12 	jmp	0x248e	; 0x248e <__bad_interrupt>
      20:	0c 94 47 12 	jmp	0x248e	; 0x248e <__bad_interrupt>
      24:	0c 94 47 12 	jmp	0x248e	; 0x248e <__bad_interrupt>
      28:	0c 94 47 12 	jmp	0x248e	; 0x248e <__bad_interrupt>
      2c:	0c 94 47 12 	jmp	0x248e	; 0x248e <__bad_interrupt>
      30:	0c 94 47 12 	jmp	0x248e	; 0x248e <__bad_interrupt>
      34:	0c 94 77 2c 	jmp	0x58ee	; 0x58ee <__vector_13>
      38:	0c 94 a1 2c 	jmp	0x5942	; 0x5942 <__vector_14>
      3c:	0c 94 47 12 	jmp	0x248e	; 0x248e <__bad_interrupt>
      40:	0c 94 47 12 	jmp	0x248e	; 0x248e <__bad_interrupt>
      44:	0c 94 47 12 	jmp	0x248e	; 0x248e <__bad_interrupt>
      48:	0c 94 47 12 	jmp	0x248e	; 0x248e <__bad_interrupt>
      4c:	0c 94 47 12 	jmp	0x248e	; 0x248e <__bad_interrupt>
      50:	0c 94 47 12 	jmp	0x248e	; 0x248e <__bad_interrupt>

00000054 <font>:
	...
      5c:	18 3c 24 24 24 24 24 3c 18 3c 24 24 24 24 3c 3c     .<$$$$$<.<$$$$<<
      6c:	18 3c 24 24 24 3c 3c 3c 18 3c 24 24 3c 3c 3c 3c     .<$$$<<<.<$$<<<<
      7c:	18 3c 24 3c 3c 3c 3c 3c 18 3c 3c 3c 3c 3c 3c 3c     .<$<<<<<.<<<<<<<
      8c:	18 3c 3c 3c 3c 3c 3c 3c 00 00 00 00 00 00 00 00     .<<<<<<<........
	...
     15c:	00 00 4f 00 00 00 00 00 00 07 00 07 00 00 00 00     ..O.............
     16c:	00 14 7f 14 7f 14 00 00 00 24 2a 7f 2a 12 00 00     .........$*.*...
     17c:	00 23 13 08 64 62 00 00 00 36 49 55 22 40 00 00     .#..db...6IU"@..
     18c:	00 00 05 03 00 00 00 00 00 1c 22 41 00 00 00 00     .........."A....
     19c:	00 41 22 1c 00 00 00 00 00 14 08 3e 08 14 00 00     .A"........>....
     1ac:	00 08 08 3e 08 08 00 00 00 00 28 18 00 00 00 00     ...>......(.....
     1bc:	00 08 08 08 08 08 08 00 00 30 30 00 00 00 00 00     .........00.....
     1cc:	00 20 10 08 04 02 00 00 00 3e 51 49 45 3e 00 00     . .......>QIE>..
     1dc:	00 00 42 7f 40 00 00 00 00 42 61 51 49 46 00 00     ..B.@....BaQIF..
     1ec:	00 21 41 45 4b 31 00 00 00 18 14 12 7f 10 00 00     .!AEK1..........
     1fc:	00 00 27 45 45 45 39 00 00 3c 4a 49 49 30 00 00     ..'EEE9..<JII0..
     20c:	00 01 71 09 05 03 00 00 00 36 49 49 49 36 00 00     ..q......6III6..
     21c:	00 06 49 49 29 1e 00 00 00 00 36 36 00 00 00 00     ..II).....66....
     22c:	00 00 56 36 00 00 00 00 00 08 14 22 41 00 00 00     ..V6......."A...
     23c:	00 24 24 24 24 24 00 00 00 00 41 22 14 08 00 00     .$$$$$....A"....
     24c:	00 02 01 51 09 06 00 00 00 32 49 79 41 3e 00 00     ...Q.....2IyA>..
     25c:	00 7e 11 11 11 7e 00 00 00 7f 49 49 49 36 00 00     .~...~....III6..
     26c:	00 3e 41 41 41 22 00 00 00 7f 41 41 22 1c 00 00     .>AAA"....AA"...
     27c:	00 7f 49 49 49 41 00 00 00 7f 09 09 09 01 00 00     ..IIIA..........
     28c:	00 3e 41 49 49 3a 00 00 00 7f 08 08 08 7f 00 00     .>AII:..........
     29c:	00 00 41 7f 41 00 00 00 00 20 40 41 3f 01 00 00     ..A.A.... @A?...
     2ac:	00 7f 08 14 22 41 00 00 00 7f 40 40 40 40 00 00     ...."A....@@@@..
     2bc:	00 7f 02 0c 02 7f 00 00 00 7f 04 08 10 7f 00 00     ................
     2cc:	00 3e 41 41 41 3e 00 00 00 7f 09 09 09 06 00 00     .>AAA>..........
     2dc:	3e 41 51 21 5e 00 00 00 00 7f 09 19 29 46 00 00     >AQ!^.......)F..
     2ec:	00 46 49 49 49 31 00 00 00 01 01 7f 01 01 00 00     .FIII1..........
     2fc:	00 3f 40 40 40 3f 00 00 00 1f 20 40 20 1f 00 00     .?@@@?.... @ ...
     30c:	00 3f 40 60 40 3f 00 00 00 63 14 08 14 63 00 00     .?@`@?...c...c..
     31c:	00 07 08 70 08 07 00 00 00 61 51 49 45 43 00 00     ...p.....aQIEC..
     32c:	00 7f 41 41 00 00 00 00 00 15 16 7c 16 15 00 00     ..AA.......|....
     33c:	00 41 41 7f 00 00 00 00 00 04 02 01 02 04 00 00     .AA.............
     34c:	00 40 40 40 40 40 00 00 00 01 02 04 00 00 00 00     .@@@@@..........
     35c:	00 20 54 54 54 78 00 00 00 7f 44 44 44 38 00 00     . TTTx....DDD8..
     36c:	00 38 44 44 44 00 00 00 00 38 44 44 48 7f 00 00     .8DDD....8DDH...
     37c:	00 38 54 54 54 18 00 00 00 10 7e 11 01 02 00 00     .8TTT.....~.....
     38c:	00 0c 52 52 52 3e 00 00 00 7f 08 04 04 78 00 00     ..RRR>.......x..
     39c:	00 00 44 7d 40 00 00 00 00 20 40 40 3d 00 00 00     ..D}@.... @@=...
     3ac:	00 7f 10 28 44 00 00 00 00 00 41 7f 40 00 00 00     ...(D.....A.@...
     3bc:	00 7c 04 18 04 78 00 00 00 7c 08 04 04 78 00 00     .|...x...|...x..
     3cc:	00 38 44 44 44 38 00 00 00 7c 14 14 14 08 00 00     .8DDD8...|......
     3dc:	00 08 14 14 18 7c 00 00 00 7c 08 04 04 08 00 00     .....|...|......
     3ec:	00 48 54 54 54 20 00 00 00 04 3f 44 40 20 00 00     .HTTT ....?D@ ..
     3fc:	00 3c 40 40 20 7c 00 00 00 1c 20 40 20 1c 00 00     .<@@ |.... @ ...
     40c:	00 1e 20 10 20 1e 00 00 00 22 14 08 14 22 00 00     .. . ...."..."..
     41c:	00 06 48 48 48 3e 00 00 00 44 64 54 4c 44 00 00     ..HHH>...DdTLD..
     42c:	00 08 36 41 00 00 00 00 00 00 00 7f 00 00 00 00     ..6A............
     43c:	00 41 36 08 00 00 00 00 00 08 08 2a 1c 08 00 00     .A6........*....
     44c:	00 08 1c 2a 08 08 00 00 00 3c 42 41 42 3c 00 00     ...*.....<BAB<..
     45c:	00 04 06 1d 25 24 20 20 20 20 20 20 a0 20 28 30     ....%$      . (0
     46c:	20 20 20 20 b0 20 20 20 00 30 28 20 a0 20 30 20         .   .0( . 0 
     47c:	20 20 20 22 20 22 28 30 20 20 20 22 30 22 20 20        " "(0   "0"  
     48c:	00 30 28 22 20 22 30 20 20 20 20 22 21 22 28 30     .0(" "0    "!"(0
     49c:	20 20 20 22 31 22 20 20 00 30 28 22 21 22 30 20        "1"  .0("!"0 
     4ac:	20 20 28 28 28 b0 20 20 20 20 28 28 28 30 20 20       (((.    (((0  
     4bc:	20 20 28 2a 28 30 20 20 00 24 24 24 38 20 20 20       (*(0  .$$$8   
     4cc:	00 24 25 24 38 20 20 20 00 80 80 40 30 20 20 20     .$%$8   ...@0   
     4dc:	00 80 80 40 34 20 20 20 20 20 20 38 20 38 20 18     ...@4      8 8 .
     4ec:	20 20 38 20 38 20 38 20 60 80 80 78 20 38 20 18       8 8 8 `..x 8 .
     4fc:	20 20 20 38 22 39 22 18 20 20 38 22 39 22 38 20        8"9".  8"9"8 
     50c:	60 80 80 78 22 39 22 18 20 20 30 20 30 28 28 18     `..x"9".  0 0((.
     51c:	20 30 20 30 28 28 38 20 60 80 80 60 30 28 28 38      0 0((8 `..`0((8
     52c:	20 20 30 20 30 28 2a 18 20 30 20 30 28 2a 38 20       0 0(*. 0 0(*8 
     53c:	60 80 80 60 30 28 2a 38 20 20 3e 30 28 28 38 20     `..`0(*8  >0((8 
     54c:	20 20 3e 30 28 2a 38 20 20 20 20 20 30 28 28 00       >0(*8     0((.
     55c:	20 20 20 30 28 28 20 20 00 40 a0 b0 28 28 20 20        0((  .@..((  
     56c:	20 20 20 20 30 28 2a 00 20 20 20 30 28 2a 20 20         0(*.   0(*  
     57c:	00 40 a0 b0 28 2a 20 20 20 20 20 20 30 28 2a 30     .@..(*      0(*0
     58c:	20 20 30 28 2a 30 20 20 00 18 20 20 30 28 2a 30       0(*0  ..  0(*0
     59c:	20 20 20 20 30 2a 28 32 20 20 30 2a 28 32 20 20         0*(2  0*(2  
     5ac:	60 80 80 b2 a8 7a 20 20 22 25 25 25 25 25 25 19     `....z  "%%%%%%.
     5bc:	20 20 20 1c 22 21 20 20 30 28 2c 2a 20 3f 20 20        ."!  0(,* ?  
     5cc:	20 20 20 20 20 20 1f 00 20 20 20 20 1f 20 20 20           ..    .   
     5dc:	00 30 40 40 3f 20 20 20 20 20 20 20 30 48 48 30     .0@@?       0HH0
     5ec:	20 20 30 48 48 30 20 20 80 40 30 48 48 30 20 20       0HH0  .@0HH0  
     5fc:	20 20 20 20 22 20 18 00 20 20 20 20 1a 20 20 20         " ..    .   
     60c:	30 40 44 40 30 20 20 20 20 20 20 30 28 3a 2c 18     0@D@0      0(:,.
     61c:	20 20 30 28 3a 2c 38 20 00 18 14 14 18 20 20 20       0(:,8 .....   
     62c:	00 21 22 24 28 10 0f 00 00 b0 a8 78 20 20 20 20     .!"$(......x    
     63c:	20 20 20 a0 20 a0 28 30 20 20 20 a0 30 a0 20 20        . .(0   .0.  
     64c:	00 60 80 80 a0 50 10 20 00 1e 20 20 20 20 20 20     .`...P. ..      
     65c:	00 20 30 28 28 20 00 00 00 04 02 02 3a 02 02 01     . 0(( ......:...
     66c:	00 00 04 06 3d 05 04 00 00 00 04 b6 ad 7d 04 00     ....=........}..
     67c:	00 00 80 c0 bf a0 80 00 04 66 85 95 a8 a8 48 00     .........f....H.
     68c:	00 00 00 3f 00 00 00 00 00 30 28 20 a0 20 28 30     ...?.....0( . (0
     69c:	00 00 30 2a 28 32 00 00 00 30 28 22 20 22 28 30     ..0*(2...0(" "(0
     6ac:	00 30 28 22 21 22 28 30 00 c0 a8 a8 28 b0 20 20     .0("!"(0....(.  
     6bc:	00 c0 a8 a8 a8 30 20 20 00 c0 a8 aa 28 30 20 20     .....0  ....(0  
     6cc:	00 00 24 24 24 38 00 00 00 00 24 25 24 38 00 00     ..$$$8....$%$8..
     6dc:	00 80 80 40 30 00 00 00 00 00 80 80 40 34 00 00     ...@0.......@4..
     6ec:	60 80 80 78 20 38 20 18 60 80 80 78 22 39 22 18     `..x 8 .`..x"9".
     6fc:	60 80 80 60 30 28 28 18 60 80 80 60 30 28 2a 18     `..`0((.`..`0(*.
     70c:	00 22 14 08 14 22 00 00 20 20 3e 30 28 28 18 00     ."..."..  >0((..
     71c:	20 20 3e 30 28 2a 18 00 00 00 40 a0 b0 28 28 00       >0(*....@..((.
     72c:	00 00 40 a0 b0 2a 28 00 20 20 20 20 20 20 20 20     ..@..*(.        
     73c:	00 18 20 20 30 28 2a 30 00 60 80 80 b2 a8 7a 00     ..  0(*0.`....z.
     74c:	00 30 28 2c 2a 20 3f 00 00 40 a9 aa a8 f0 00 00     .0(,* ?..@......
     75c:	00 00 60 80 80 7e 00 00 00 40 aa a9 aa f0 00 00     ..`..~...@......
     76c:	00 00 c0 20 30 28 28 30 00 00 60 80 88 80 60 00     ... 0((0..`...`.
     77c:	00 00 30 28 28 30 00 00 00 00 00 b0 a8 78 00 00     ..0((0.......x..
     78c:	04 26 25 25 28 10 0f 00 04 22 22 26 29 10 0f 00     .&%%(....""&)...
     79c:	00 21 22 24 a8 d0 af a0 00 70 aa a9 aa 30 00 00     .!"$.....p...0..
     7ac:	00 70 aa a8 aa 30 00 00 00 30 40 40 50 28 08 00     .p...0...0@@P(..
     7bc:	00 30 c0 40 d0 28 08 00 00 00 02 79 02 00 00 00     .0.@.(.....y....
     7cc:	00 00 02 78 02 00 00 00 00 00 00 00 00 05 05 05     ...x............
     7dc:	00 00 00 04 03 0b 06 06 a0 a0 a0 00 00 00 00 00     ................
     7ec:	00 00 01 01 01 01 00 00 00 21 22 24 28 10 2f 20     .........!"$(./ 
     7fc:	00 00 00 00 00 04 03 03 00 00 80 80 80 80 00 00     ................
     80c:	00 00 10 10 54 10 10 00 00 00 02 04 02 04 02 00     ....T...........
     81c:	20 24 26 25 25 20 28 30 20 24 26 25 35 20 20 20      $&%% (0 $&%5   
     82c:	08 6c 8a 8a a0 50 10 20 04 b6 ad 7d 24 20 20 20     .l...P. ...}$   
     83c:	00 19 14 15 18 20 20 20 04 02 02 1a 22 22 21 20     .....   ....""! 
     84c:	00 40 60 50 48 50 40 40                             .@`PHP@@

00000854 <hand6>:
	...
     8a4:	00 c0 e0 e0 c0 00 00 e0 f0 f0 f0 c0 40 00 00 00     ............@...
     8b4:	80 80 c0 c0 c0 00 40 00 00 00 00 00 00 00 00 00     ......@.........
	...
     8ec:	00 f0 08 04 22 22 31 11 09 07 00 00 00 00 00 00     ....""1.........
	...
     908:	00 40 c0 c0 70 58 40 00 00 00 00 00 00 00 00 00     .@..pX@.........
     918:	20 00 00 40 1e 3e fc fa e4 c0 80 80 00 3f ff ff      ..@.>.......?..
     928:	ff fe 80 ff ff ff ff ff e0 d2 f0 f0 fc ff ff 1f     ................
     938:	03 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
     968:	00 70 98 88 80 80 c3 46 38 00 e0 18 66 1d 0e 7b     .p.....F8...f..{
     978:	8c 06 71 4c 42 31 79 8f c0 38 1e 05 0e 0b 0d 04     ..qLB1y..8......
     988:	78 46 61 30 08 00 00 00 00 00 00 00 00 00 00 00     xFa0............
     998:	00 00 00 00 00 00 00 05 93 ff ff ff ff ff ff ff     ................
     9a8:	ff ff ff ff ff ff ff ff ff ff ff ff ff 81 82 81     ................
     9b8:	c0 80 80 c0 c0 c0 e0 e0 c0 c0 80 00 00 00 00 00     ................
	...
     a1c:	00 00 00 40 00 c8 ff ff ff ff ff ff ff ff ff ff     ...@............
     a2c:	ff ff ff 7f 3f 3f 1f 5f 1f 0f 0f 1f 07 07 03 03     ....??._........
     a3c:	03 09 01 01 01 01 01 01 00 00 00 00 00 00 00 00     ................
	...
     a6c:	00 00 00 80 40 60 20 10 90 e0 00 00 c0 20 90 70     ....@` ...... .p
	...
     a9c:	00 90 f0 f9 ff ff ff ff ff ff ff ff ff ff ff ff     ................
     aac:	3f 07 01 41 00 00 00 00 00 00 00 00 00 00 00 00     ?..A............
	...
     ae8:	00 00 c0 70 1c 06 03 01 80 c8 0c 06 e3 78 2e 99     ...p.........x..
     af8:	04 c2 21 90 70 00 c0 30 80 f0 b0 c0 40 a0 50 30     ..!.p..0....@.P0
	...
     b18:	b0 e0 fe fe ff ff ff ff ff ff ff ff ff ff ff ff     ................
     b28:	ff ff 7f 20 10 00 00 00 00 00 00 00 00 00 00 00     ... ............
	...
     b68:	00 00 03 04 04 c4 72 1f 07 01 00 07 04 02 01 00     ......r.........
     b78:	07 04 02 01 00 07 04 02 01 00 00 07 05 04 04 02     ................
     b88:	01 00 00 00 00 00 00 00 00 00 00 00 00 00 04 07     ................
     b98:	07 07 07 07 07 07 07 07 07 07 07 07 07 07 07 07     ................
     ba8:	07 07 00 02 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
     bec:	00 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...

00000c54 <hand1>:
	...
     cec:	00 f0 08 04 22 22 31 11 09 07 00 00 00 00 00 00     ....""1.........
	...
     d08:	00 40 c0 c0 70 58 40 00 00 00 00 00 00 00 00 00     .@..pX@.........
	...
     d68:	00 70 98 88 80 80 c3 46 38 00 e0 18 66 1d 0e 7b     .p.....F8...f..{
     d78:	8c 06 71 4c 42 31 79 8f c0 38 1e 05 0e 0b 0d 04     ..qLB1y..8......
     d88:	78 46 61 30 08 00 00 00 00 00 00 00 00 00 00 00     xFa0............
	...
     da8:	00 80 40 00 80 00 80 00 00 00 40 c0 80 c0 80 40     ..@.......@....@
     db8:	00 80 00 80 80 00 80 00 40 80 00 00 00 00 00 00     ........@.......
	...
     e20:	00 00 80 04 f0 e0 f8 fa f8 fc ff fc fe fe fe fe     ................
     e30:	fe fe ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
     e40:	de e0 08 8b 10 14 08 80 20 00 00 00 00 00 00 00     ........ .......
	...
     e6c:	00 00 00 80 40 60 20 10 90 e0 00 00 c0 20 90 70     ....@` ...... .p
	...
     e9c:	20 00 00 00 00 04 00 00 e3 ff ff ff ff ff ff ff      ...............
     eac:	ff ff ff ff ff ff ff ff ff ff ff ff 3f 1f 1f 8f     ............?...
     ebc:	07 07 03 03 09 00 00 02 01 00 00 00 00 00 00 00     ................
	...
     ee8:	00 00 c0 70 1c 06 03 01 80 c8 0c 06 e3 78 2e 99     ...p.........x..
     ef8:	04 c2 21 90 70 00 c0 30 80 f0 b0 c0 40 a0 50 30     ..!.p..0....@.P0
	...
     f1c:	02 00 80 d1 f2 fc fe ff ff ff ff ff ff ff ff ff     ................
     f2c:	ff ff ff ff ff ff ff 7f 3f 0f 47 08 00 00 00 05     ........?.G.....
	...
     f68:	00 00 03 04 04 c4 72 1f 07 01 00 07 04 02 01 00     ......r.........
     f78:	07 04 02 01 00 07 04 02 01 00 00 07 05 04 04 02     ................
     f88:	01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     f98:	00 80 c8 f0 fc fe ff ff ff ff ff ff ff ff ff ff     ................
     fa8:	ff ff ff ff ff ff ff ff ff 1f 01 00 00 00 8a 00     ................
	...
     fec:	00 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
    1018:	00 1f 1f 1f 1f 1f 1f 1f 1f 1f 1f 1f 1f 1f 1f 1f     ................
    1028:	1f 1f 1f 1f 1f 1f 1f 1f 1f 00 00 04 00 00 10 00     ................
	...

00001054 <hand2>:
	...
    10bc:	00 80 80 80 80 80 00 00 00 00 00 00 00 00 00 00     ................
	...
    10ec:	00 f0 08 04 22 22 31 11 09 07 00 00 00 00 00 00     ....""1.........
	...
    1108:	00 40 c0 c0 70 58 40 00 00 00 00 00 00 00 00 00     .@..pX@.........
	...
    1138:	00 00 00 80 e0 ff ff ff ff ff ff 10 02 00 00 00     ................
	...
    1168:	00 70 98 88 80 80 c3 46 38 00 e0 18 66 1d 0e 7b     .p.....F8...f..{
    1178:	8c 06 71 4c 42 31 79 8f c0 38 1e 05 0e 0b 0d 04     ..qLB1y..8......
    1188:	78 46 61 30 08 00 00 00 00 00 00 00 00 00 00 00     xFa0............
	...
    11a4:	00 00 00 80 e0 f0 f0 f8 f8 f8 f8 fc fc fc fe fe     ................
    11b4:	fe ff ff fe fe fe fe ff ff ff ff ff ff 3f 03 00     .............?..
    11c4:	02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
    1224:	00 00 00 20 37 8f ff ff ff ff ff ff ff ff ff ff     ... 7...........
    1234:	ff ff ff ff ff ff ff ff 7f 1f 0f 07 00 00 00 00     ................
	...
    126c:	00 00 00 80 40 60 20 10 90 e0 00 00 c0 20 90 70     ....@` ...... .p
	...
    12a4:	00 90 e0 fc ff ff ff ff ff ff ff ff ff ff ff ff     ................
    12b4:	ff ff ff ff ff 3f 07 11 18 20 28 00 00 00 00 00     .....?... (.....
	...
    12e8:	00 00 c0 70 1c 06 03 01 80 c8 0c 06 e3 78 2e 99     ...p.........x..
    12f8:	04 c2 21 90 70 00 c0 30 80 f0 b0 c0 40 a0 50 30     ..!.p..0....@.P0
	...
    131c:	00 00 20 00 04 e0 f0 f8 ff ff ff ff ff ff ff ff     .. .............
    132c:	ff ff ff ff ff ff ff ff ff ff ff 0f 20 00 00 04     ............ ...
	...
    1368:	00 00 03 04 04 c4 72 1f 07 01 00 07 04 02 01 00     ......r.........
    1378:	07 04 02 01 00 07 04 02 01 00 00 07 05 04 04 02     ................
    1388:	01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1398:	00 00 10 00 40 70 7c 7f 7f 7f 7f 7f 7f 7f 7f 7f     ....@p|.........
    13a8:	7f 7f 7f 7f 7f 7f 7f 7f 7f 7f 7f 7f 7f 7f 7f 18     ................
	...
    13ec:	00 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...

00001454 <hand3>:
	...
    14ec:	00 f0 08 04 22 22 31 11 09 07 00 00 00 00 00 00     ....""1.........
	...
    1508:	00 40 c0 c0 70 58 40 00 00 00 00 00 00 00 00 00     .@..pX@.........
	...
    152c:	80 10 fe fe fe fe fc fc 00 40 00 f0 f8 f8 f8 f8     .........@......
    153c:	f0 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
    1568:	00 70 98 88 80 80 c3 46 38 00 e0 18 66 1d 0e 7b     .p.....F8...f..{
    1578:	8c 06 71 4c 42 31 79 8f c0 38 1e 05 0e 0b 0d 04     ..qLB1y..8......
    1588:	78 46 61 30 08 00 00 00 00 00 00 00 00 00 00 00     xFa0............
	...
    15a0:	00 00 00 40 80 c0 98 c0 c8 c0 f0 e1 e0 f0 e7 ff     ...@............
    15b0:	ff ff ff ff f0 f0 fe ff ff ff ff 07 f0 04 00 00     ................
	...
    1620:	04 10 40 10 fe ff ff ff ff ff ff ff ff ff ff ff     ..@.............
    1630:	ff ff ff ff ff ff 7f 3f 1f 01 00 00 00 00 00 00     .......?........
	...
    166c:	00 00 00 80 40 60 20 10 90 e0 00 00 c0 20 90 70     ....@` ...... .p
	...
    1698:	00 00 00 80 00 10 00 50 c0 f8 fc ff ff ff ff ff     .......P........
    16a8:	ff ff ff ff ff ff ff ff 3f 1f 87 03 0d 00 00 00     ........?.......
	...
    16e8:	00 00 c0 70 1c 06 03 01 80 c8 0c 06 e3 78 2e 99     ...p.........x..
    16f8:	04 c2 21 90 70 00 c0 30 80 f0 b0 c0 40 a0 50 30     ..!.p..0....@.P0
	...
    1714:	00 00 00 10 00 20 00 00 c0 f0 f8 ff ff ff ff ff     ..... ..........
    1724:	ff ff ff ff ff ff ff ff ff ff 7f 0f 00 01 00 00     ................
	...
    1768:	00 00 03 04 04 c4 72 1f 07 01 00 07 04 02 01 00     ......r.........
    1778:	07 04 02 01 00 07 04 02 01 00 00 07 05 04 04 02     ................
    1788:	01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 80     ................
    1798:	80 c8 f0 fc ff ff ff ff ff ff ff ff ff ff ff ff     ................
    17a8:	ff ff ff ff ff 3f 20 4d 00 00 00 00 00 00 00 00     .....? M........
	...
    17ec:	00 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
    1818:	00 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1828:	00 00 00 00 00 00 01 00 00 00 00 00 00 00 00 00     ................
	...

00001854 <hand4>:
	...
    18a4:	00 c0 e0 c0 c0 00 c0 e0 e0 e0 c0 00 00 00 00 80     ................
    18b4:	80 c0 c0 c0 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
    18ec:	00 f0 08 04 22 22 31 11 09 07 00 00 00 00 00 00     ....""1.........
	...
    1908:	00 40 c0 c0 70 58 40 00 00 00 00 00 00 00 00 00     .@..pX@.........
	...
    1920:	00 20 04 00 00 ff ff ff ff c0 ff ff ff ff ff 00     . ..............
    1930:	a4 e0 f4 fc ff ff 7f 1f 00 00 08 00 00 00 00 00     ................
	...
    1968:	00 70 98 88 80 80 c3 46 38 00 e0 18 66 1d 0e 7b     .p.....F8...f..{
    1978:	8c 06 71 4c 42 31 79 8f c0 38 1e 05 0e 0b 0d 04     ..qLB1y..8......
    1988:	78 46 61 30 08 00 00 00 00 00 00 00 00 00 00 00     xFa0............
	...
    19a0:	00 f4 f8 f8 fc ff ff ff ff ff ff ff ff ff ff ff     ................
    19b0:	ff ff ff 3f 07 01 80 01 00 00 00 00 00 00 00 00     ...?............
	...
    1a20:	00 03 ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
    1a30:	7f 4b 20 00 04 00 00 00 00 00 00 00 00 00 00 00     .K .............
	...
    1a6c:	00 00 00 80 40 60 20 10 90 e0 00 00 c0 20 90 70     ....@` ...... .p
	...
    1a9c:	41 00 90 f0 f8 ff ff ff ff ff ff ff ff ff ff ff     A...............
    1aac:	ff 7f 0f 93 02 00 00 00 00 00 00 00 00 00 00 00     ................
	...
    1ae8:	00 00 c0 70 1c 06 03 01 80 c8 0c 06 e3 78 2e 99     ...p.........x..
    1af8:	04 c2 21 90 70 00 c0 30 80 f0 b0 c0 40 a0 50 30     ..!.p..0....@.P0
	...
    1b14:	00 00 00 80 00 00 c0 f0 fc fe ff ff ff ff ff ff     ................
    1b24:	ff ff ff ff ff ff ff ff 0f 80 00 00 00 01 00 00     ................
	...
    1b68:	00 00 03 04 04 c4 72 1f 07 01 00 07 04 02 01 00     ......r.........
    1b78:	07 04 02 01 00 07 04 02 01 00 00 07 05 04 04 02     ................
    1b88:	01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 30     ...............0
    1b98:	7e 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f 3f     ~???????????????
    1ba8:	3f 3f 3f 3f 00 00 00 00 00 00 00 00 00 00 00 00     ????............
	...
    1bec:	00 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...

00001c54 <hand5>:
	...
    1ca4:	00 00 80 80 80 80 00 40 c0 c0 c0 80 20 00 00 00     .......@.... ...
    1cb4:	80 80 80 80 80 00 00 00 00 00 00 00 00 00 00 00     ................
	...
    1cec:	00 f0 08 04 22 22 31 11 09 07 00 00 00 00 00 00     ....""1.........
	...
    1d08:	00 40 c0 c0 70 58 40 00 00 00 00 00 00 00 00 00     .@..pX@.........
    1d18:	00 00 00 00 00 00 10 2a 18 f8 f8 f0 c0 80 ff ff     .......*........
    1d28:	ff ff f8 e2 ff ff ff ff fe 04 d0 f0 fe ff ff ff     ................
    1d38:	3f 80 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ?...............
	...
    1d68:	00 70 98 88 80 80 c3 46 38 00 e0 18 66 1d 0e 7b     .p.....F8...f..{
    1d78:	8c 06 71 4c 42 31 79 8f c0 38 1e 05 0e 0b 0d 04     ..qLB1y..8......
    1d88:	78 46 61 30 08 00 00 00 00 00 00 00 00 00 00 00     xFa0............
    1d98:	00 00 00 00 00 00 02 00 00 00 05 ff ff ff fe ff     ................
    1da8:	ff ff ff ff ff ff ff ff ff ff ff ff ff 1f 01 11     ................
    1db8:	01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
    1e20:	00 02 00 03 87 ff ff ff ff ff ff ff ff ff ff ff     ................
    1e30:	ff ff 3f 0f 43 00 00 00 00 00 00 00 00 00 00 00     ..?.C...........
	...
    1e6c:	00 00 00 80 40 60 20 10 90 e0 00 00 c0 20 90 70     ....@` ...... .p
	...
    1e9c:	00 20 80 40 00 c0 e0 ff ff ff ff ff ff ff ff ff     . .@............
    1eac:	ff ff ff 1f 0f 08 04 00 00 00 00 00 00 00 00 00     ................
	...
    1ee8:	00 00 c0 70 1c 06 03 01 80 c8 0c 06 e3 78 2e 99     ...p.........x..
    1ef8:	04 c2 21 90 70 00 c0 30 80 f0 b0 c0 40 a0 50 30     ..!.p..0....@.P0
	...
    1f1c:	c0 f2 f8 fc ff ff ff ff ff ff ff ff ff ff ff ff     ................
    1f2c:	ff ff 1f 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
    1f68:	00 00 03 04 04 c4 72 1f 07 01 00 07 04 02 01 00     ......r.........
    1f78:	07 04 02 01 00 07 04 02 01 00 00 07 05 04 04 02     ................
    1f88:	01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1f98:	00 00 00 00 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f 0f     ................
    1fa8:	0f 0f 0f 0f 0f 0f 00 00 00 00 00 00 00 00 00 00     ................
	...
    1fec:	00 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...

00002054 <author>:
    2054:	00 00 00 00 00 80 c0 60 a0 a0 20 60 c0 00 00 80     .......`.. `....
    2064:	80 00 80 80 80 00 80 20 00 00 80 80 80 80 80 00     ....... ........
    2074:	80 00 00 00 80 80 00 00 00 80 80 e0 10 10 00 80     ................
    2084:	40 60 a0 e0 a0 60 80 00 00 80 00 00 00 00 00 00     @`...`..........
	...
    20d8:	00 03 04 08 0e 09 08 04 03 0f 0b 0a 05 0c 09 0e     ................
    20e8:	00 0c 03 70 4e 49 68 3e 01 0e 01 0d 0b 00 0f 0b     ...pNIh>........
    20f8:	0a 05 00 0e 09 04 0f 04 00 00 00 03 02 08 0f 08     ................
    2108:	48 47 21 1f 0c 03 00 00 00 00 00 00 00 00 00 00     HG!.............
	...
    217c:	00 00 30 48 88 38 00 80 78 44 e4 00 80 40 20 e0     ..0H.8..xD...@ .
    218c:	40 20 e0 20 00 e0 00 e0 00 a0 60 40 e0 00 00 00     @ . ......`@....
    219c:	00 e0 30 18 a8 68 08 18 f0 00 20 18 30 48 88 38     ..0..h.... .0H.8
    21ac:	00 c0 20 20 e0 00 a0 60 80 60 00 60 a0 60 60 20     ..  ...`.`.`.`` 
    21bc:	80 40 20 e0 00 00 00 00 00 00 00 00 00 00 00 00     .@ .............
	...
    21fc:	02 04 04 06 03 00 00 03 00 03 02 00 03 02 03 02     ................
    220c:	00 00 03 02 01 03 01 00 00 03 00 03 02 00 00 00     ................
    221c:	00 00 01 02 03 02 02 01 00 00 02 04 04 06 03 00     ................
    222c:	00 03 02 03 00 00 03 02 03 02 02 03 02 02 03 00     ................
    223c:	03 02 03 02 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
    2278:	00 00 80 4c 32 2e fe 82 00 e8 18 d0 b8 00 c0 38     ...L2..........8
    2288:	02 c8 38 10 08 e8 98 e0 98 00 e0 90 48 f8 4e e1     ..8.........H.N.
    2298:	91 48 f8 4e e1 1f d1 b9 00 00 00 00 00 70 8c 84     .H.N.........p..
    22a8:	82 d2 32 16 e0 90 c8 b8 10 08 f8 88 40 f8 40 38     ..2.........@.@8
    22b8:	00 e0 90 c8 b8 00 e0 90 48 f8 4e f1 b1 a8 58 00     ........H.N...X.
	...
    22f8:	01 01 00 00 80 80 80 00 00 00 80 00 00 00 00 80     ................
    2308:	40 40 00 00 80 40 40 00 00 00 00 00 00 00 80 40     @@...@@........@
    2318:	40 00 00 00 00 00 00 00 00 80 80 80 80 00 04 04     @...............
    2328:	06 01 00 00 00 00 80 40 40 00 00 00 00 00 00 00     .......@@.......
	...
    2378:	00 20 40 43 64 38 03 00 30 0e 00 38 24 12 3e 13     . @Cd8..0..8$.>.
    2388:	38 24 12 3e 13 3c 2c 2a 16 30 26 3a 02 38 07 34     8$.>.<,*.0&:.8.4
    2398:	2e 00 00 00 00 00 1c 23 21 a0 74 0c 05 38 24 32     .......#!.t..8$2
    23a8:	2e 00 38 24 12 3e 13 00 00 00 00 00 00 00 00 00     ..8$.>..........
	...
    241c:	00 00 00 01 01 01 00 00 00 00 00 00 00 00 00 00     ................
	...

00002454 <__ctors_end>:
    2454:	11 24       	eor	r1, r1
    2456:	1f be       	out	0x3f, r1	; 63
    2458:	cf e5       	ldi	r28, 0x5F	; 95
    245a:	d8 e0       	ldi	r29, 0x08	; 8
    245c:	de bf       	out	0x3e, r29	; 62
    245e:	cd bf       	out	0x3d, r28	; 61

00002460 <__do_copy_data>:
    2460:	14 e0       	ldi	r17, 0x04	; 4
    2462:	a0 e6       	ldi	r26, 0x60	; 96
    2464:	b0 e0       	ldi	r27, 0x00	; 0
    2466:	e2 ec       	ldi	r30, 0xC2	; 194
    2468:	fa e6       	ldi	r31, 0x6A	; 106
    246a:	02 c0       	rjmp	.+4      	; 0x2470 <.do_copy_data_start>

0000246c <.do_copy_data_loop>:
    246c:	05 90       	lpm	r0, Z+
    246e:	0d 92       	st	X+, r0

00002470 <.do_copy_data_start>:
    2470:	a8 36       	cpi	r26, 0x68	; 104
    2472:	b1 07       	cpc	r27, r17
    2474:	d9 f7       	brne	.-10     	; 0x246c <.do_copy_data_loop>

00002476 <__do_clear_bss>:
    2476:	15 e0       	ldi	r17, 0x05	; 5
    2478:	a8 e6       	ldi	r26, 0x68	; 104
    247a:	b4 e0       	ldi	r27, 0x04	; 4
    247c:	01 c0       	rjmp	.+2      	; 0x2480 <.do_clear_bss_start>

0000247e <.do_clear_bss_loop>:
    247e:	1d 92       	st	X+, r1

00002480 <.do_clear_bss_start>:
    2480:	af 33       	cpi	r26, 0x3F	; 63
    2482:	b1 07       	cpc	r27, r17
    2484:	e1 f7       	brne	.-8      	; 0x247e <.do_clear_bss_loop>
    2486:	0e 94 0a 24 	call	0x4814	; 0x4814 <main>
    248a:	0c 94 5f 35 	jmp	0x6abe	; 0x6abe <_exit>

0000248e <__bad_interrupt>:
    248e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00002492 <trigger>:
//#define CS_ACTIVE_LOW   1   //Define this if your GLCD CS
                              //is active low 

void trigger()
{
	CONTROLPORT |= EN;	//EN high
    2492:	97 9a       	sbi	0x12, 7	; 18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    2494:	8a e1       	ldi	r24, 0x1A	; 26
    2496:	98 2f       	mov	r25, r24
    2498:	9a 95       	dec	r25
    249a:	f1 f7       	brne	.-4      	; 0x2498 <trigger+0x6>
   _delay_us(E_DELAY);
   CONTROLPORT &= ~EN;	//EN low
    249c:	97 98       	cbi	0x12, 7	; 18
    249e:	8a 95       	dec	r24
    24a0:	f1 f7       	brne	.-4      	; 0x249e <trigger+0xc>
   _delay_us(E_DELAY);
}
    24a2:	08 95       	ret

000024a4 <glcd_on>:
{
#ifdef CS_ACTIVE_LOW
   CONTROLPORT &= ~CS1;	//Activate both chips
   CONTROLPORT &= ~CS2;
#else
   CONTROLPORT |= CS1;	//Activate both chips
    24a4:	93 9a       	sbi	0x12, 3	; 18
   CONTROLPORT |= CS2;
    24a6:	94 9a       	sbi	0x12, 4	; 18
#endif
   CONTROLPORT &= ~DI;	//DI low --> command
    24a8:	95 98       	cbi	0x12, 5	; 18
   CONTROLPORT &= ~RW;	//RW low --> write
    24aa:	96 98       	cbi	0x12, 6	; 18
   DATAPORT = 0x3F; 	//ON command
    24ac:	8f e3       	ldi	r24, 0x3F	; 63
    24ae:	85 bb       	out	0x15, r24	; 21
//#define CS_ACTIVE_LOW   1   //Define this if your GLCD CS
                              //is active low 

void trigger()
{
	CONTROLPORT |= EN;	//EN high
    24b0:	97 9a       	sbi	0x12, 7	; 18
    24b2:	8a e1       	ldi	r24, 0x1A	; 26
    24b4:	98 2f       	mov	r25, r24
    24b6:	9a 95       	dec	r25
    24b8:	f1 f7       	brne	.-4      	; 0x24b6 <glcd_on+0x12>
   _delay_us(E_DELAY);
   CONTROLPORT &= ~EN;	//EN low
    24ba:	97 98       	cbi	0x12, 7	; 18
    24bc:	8a 95       	dec	r24
    24be:	f1 f7       	brne	.-4      	; 0x24bc <glcd_on+0x18>
#endif
   CONTROLPORT &= ~DI;	//DI low --> command
   CONTROLPORT &= ~RW;	//RW low --> write
   DATAPORT = 0x3F; 	//ON command
   trigger();
}           
    24c0:	08 95       	ret

000024c2 <glcd_off>:
{
#ifdef CS_ACTIVE_LOW
   CONTROLPORT &= ~CS1;	//Activate both chips
   CONTROLPORT &= ~CS2;
#else
   CONTROLPORT |= CS1;	//Activate both chips
    24c2:	93 9a       	sbi	0x12, 3	; 18
   CONTROLPORT |= CS2;
    24c4:	94 9a       	sbi	0x12, 4	; 18
#endif
	CONTROLPORT &= ~DI;	//DI low --> command
    24c6:	95 98       	cbi	0x12, 5	; 18
	CONTROLPORT &= ~RW;	//RW low --> write
    24c8:	96 98       	cbi	0x12, 6	; 18
	DATAPORT = 0x3E;    //OFF command
    24ca:	8e e3       	ldi	r24, 0x3E	; 62
    24cc:	85 bb       	out	0x15, r24	; 21
//#define CS_ACTIVE_LOW   1   //Define this if your GLCD CS
                              //is active low 

void trigger()
{
	CONTROLPORT |= EN;	//EN high
    24ce:	97 9a       	sbi	0x12, 7	; 18
    24d0:	8a e1       	ldi	r24, 0x1A	; 26
    24d2:	98 2f       	mov	r25, r24
    24d4:	9a 95       	dec	r25
    24d6:	f1 f7       	brne	.-4      	; 0x24d4 <glcd_off+0x12>
   _delay_us(E_DELAY);
   CONTROLPORT &= ~EN;	//EN low
    24d8:	97 98       	cbi	0x12, 7	; 18
    24da:	8a 95       	dec	r24
    24dc:	f1 f7       	brne	.-4      	; 0x24da <glcd_off+0x18>
#endif
	CONTROLPORT &= ~DI;	//DI low --> command
	CONTROLPORT &= ~RW;	//RW low --> write
	DATAPORT = 0x3E;    //OFF command
	trigger();
}     
    24de:	08 95       	ret

000024e0 <set_start_line>:
//----------------------
void set_start_line(byte line)
{
	CONTROLPORT &= ~DI;			//RS low --> command
    24e0:	95 98       	cbi	0x12, 5	; 18
	CONTROLPORT &= ~RW;			//RW low --> write
    24e2:	96 98       	cbi	0x12, 6	; 18
    //Activate both chips
    #ifdef CS_ACTIVE_LOW
		CONTROLPORT &= ~CS1;
		CONTROLPORT &= ~CS2;
    #else
		CONTROLPORT |= CS1;
    24e4:	93 9a       	sbi	0x12, 3	; 18
		CONTROLPORT |= CS2;
    24e6:	94 9a       	sbi	0x12, 4	; 18
    #endif
    DATAPORT = 0xC0 | line;     //Set Start Line command
    24e8:	80 6c       	ori	r24, 0xC0	; 192
    24ea:	85 bb       	out	0x15, r24	; 21
//#define CS_ACTIVE_LOW   1   //Define this if your GLCD CS
                              //is active low 

void trigger()
{
	CONTROLPORT |= EN;	//EN high
    24ec:	97 9a       	sbi	0x12, 7	; 18
    24ee:	8a e1       	ldi	r24, 0x1A	; 26
    24f0:	98 2f       	mov	r25, r24
    24f2:	9a 95       	dec	r25
    24f4:	f1 f7       	brne	.-4      	; 0x24f2 <set_start_line+0x12>
   _delay_us(E_DELAY);
   CONTROLPORT &= ~EN;	//EN low
    24f6:	97 98       	cbi	0x12, 7	; 18
    24f8:	8a 95       	dec	r24
    24fa:	f1 f7       	brne	.-4      	; 0x24f8 <set_start_line+0x18>
		CONTROLPORT |= CS1;
		CONTROLPORT |= CS2;
    #endif
    DATAPORT = 0xC0 | line;     //Set Start Line command
    trigger();
}
    24fc:	08 95       	ret

000024fe <goto_col>:
//----------------------
void goto_col(unsigned int x)
{
   byte pattern;
   CONTROLPORT &= ~DI;	//DI low --> command
    24fe:	95 98       	cbi	0x12, 5	; 18
   CONTROLPORT &= ~RW;	//RW low --> write
    2500:	96 98       	cbi	0x12, 6	; 18
   if(x<64)             //left section
    2502:	80 34       	cpi	r24, 0x40	; 64
    2504:	91 05       	cpc	r25, r1
    2506:	18 f4       	brcc	.+6      	; 0x250e <goto_col+0x10>
   {
#ifdef CS_ACTIVE_LOW
      CONTROLPORT &= ~CS1;	//select chip 1
      CONTROLPORT |= CS2;	//deselect chip 2
#else
      CONTROLPORT |= CS1;	//select chip 1
    2508:	93 9a       	sbi	0x12, 3	; 18
      CONTROLPORT &= ~CS2;	//deselect chip 2
    250a:	94 98       	cbi	0x12, 4	; 18
    250c:	03 c0       	rjmp	.+6      	; 0x2514 <goto_col+0x16>
   {
#ifdef CS_ACTIVE_LOW
	   CONTROLPORT |= CS1;	//deselct chip 1
	   CONTROLPORT &= ~CS2;	//select chip 2
#else
	   CONTROLPORT &= ~CS1;	//deselct chip 1
    250e:	93 98       	cbi	0x12, 3	; 18
	   CONTROLPORT |= CS2;	//select chip 2
    2510:	94 9a       	sbi	0x12, 4	; 18
#endif
	   pattern = x-64;   //put column address on data port
    2512:	80 54       	subi	r24, 0x40	; 64
   }    
   pattern = (pattern | 0x40 ) & 0x7F;  //Command format
    2514:	8f 73       	andi	r24, 0x3F	; 63
    2516:	80 64       	ori	r24, 0x40	; 64
   DATAPORT = pattern; 
    2518:	85 bb       	out	0x15, r24	; 21
//#define CS_ACTIVE_LOW   1   //Define this if your GLCD CS
                              //is active low 

void trigger()
{
	CONTROLPORT |= EN;	//EN high
    251a:	97 9a       	sbi	0x12, 7	; 18
    251c:	8a e1       	ldi	r24, 0x1A	; 26
    251e:	98 2f       	mov	r25, r24
    2520:	9a 95       	dec	r25
    2522:	f1 f7       	brne	.-4      	; 0x2520 <goto_col+0x22>
   _delay_us(E_DELAY);
   CONTROLPORT &= ~EN;	//EN low
    2524:	97 98       	cbi	0x12, 7	; 18
    2526:	8a 95       	dec	r24
    2528:	f1 f7       	brne	.-4      	; 0x2526 <goto_col+0x28>
	   pattern = x-64;   //put column address on data port
   }    
   pattern = (pattern | 0x40 ) & 0x7F;  //Command format
   DATAPORT = pattern; 
   trigger();     
}   
    252a:	08 95       	ret

0000252c <goto_row>:
//----------------------
void goto_row(unsigned int y)
{    
   byte pattern;
   CONTROLPORT &= ~DI;	//DI low --> command
    252c:	95 98       	cbi	0x12, 5	; 18
   CONTROLPORT &= ~RW;	//RW low --> write
    252e:	96 98       	cbi	0x12, 6	; 18
   pattern = (y | 0xB8) & 0xBF; //put row address on data port set command
    2530:	87 70       	andi	r24, 0x07	; 7
    2532:	88 6b       	ori	r24, 0xB8	; 184
   DATAPORT = pattern;   
    2534:	85 bb       	out	0x15, r24	; 21
//#define CS_ACTIVE_LOW   1   //Define this if your GLCD CS
                              //is active low 

void trigger()
{
	CONTROLPORT |= EN;	//EN high
    2536:	97 9a       	sbi	0x12, 7	; 18
    2538:	8a e1       	ldi	r24, 0x1A	; 26
    253a:	98 2f       	mov	r25, r24
    253c:	9a 95       	dec	r25
    253e:	f1 f7       	brne	.-4      	; 0x253c <goto_row+0x10>
   _delay_us(E_DELAY);
   CONTROLPORT &= ~EN;	//EN low
    2540:	97 98       	cbi	0x12, 7	; 18
    2542:	8a 95       	dec	r24
    2544:	f1 f7       	brne	.-4      	; 0x2542 <goto_row+0x16>
   CONTROLPORT &= ~DI;	//DI low --> command
   CONTROLPORT &= ~RW;	//RW low --> write
   pattern = (y | 0xB8) & 0xBF; //put row address on data port set command
   DATAPORT = pattern;   
   trigger();             
}
    2546:	08 95       	ret

00002548 <goto_xy>:
//----------------------
void goto_xy(unsigned int x,unsigned int y)
{    
    2548:	1f 93       	push	r17
    254a:	16 2f       	mov	r17, r22
    goto_col(x);
    254c:	0e 94 7f 12 	call	0x24fe	; 0x24fe <goto_col>
}   
//----------------------
void goto_row(unsigned int y)
{    
   byte pattern;
   CONTROLPORT &= ~DI;	//DI low --> command
    2550:	95 98       	cbi	0x12, 5	; 18
   CONTROLPORT &= ~RW;	//RW low --> write
    2552:	96 98       	cbi	0x12, 6	; 18
   pattern = (y | 0xB8) & 0xBF; //put row address on data port set command
    2554:	17 70       	andi	r17, 0x07	; 7
    2556:	18 6b       	ori	r17, 0xB8	; 184
   DATAPORT = pattern;   
    2558:	15 bb       	out	0x15, r17	; 21
//#define CS_ACTIVE_LOW   1   //Define this if your GLCD CS
                              //is active low 

void trigger()
{
	CONTROLPORT |= EN;	//EN high
    255a:	97 9a       	sbi	0x12, 7	; 18
    255c:	8a e1       	ldi	r24, 0x1A	; 26
    255e:	98 2f       	mov	r25, r24
    2560:	9a 95       	dec	r25
    2562:	f1 f7       	brne	.-4      	; 0x2560 <goto_xy+0x18>
   _delay_us(E_DELAY);
   CONTROLPORT &= ~EN;	//EN low
    2564:	97 98       	cbi	0x12, 7	; 18
    2566:	8a 95       	dec	r24
    2568:	f1 f7       	brne	.-4      	; 0x2566 <goto_xy+0x1e>
//----------------------
void goto_xy(unsigned int x,unsigned int y)
{    
    goto_col(x);
    goto_row(y);
}  
    256a:	1f 91       	pop	r17
    256c:	08 95       	ret

0000256e <glcd_write>:
//----------------------
void glcd_write(byte b)
{
	CONTROLPORT |= DI;	//DI high --> data
    256e:	95 9a       	sbi	0x12, 5	; 18
	CONTROLPORT &= ~RW;	//RW low --> write
    2570:	96 98       	cbi	0x12, 6	; 18
	DATAPORT = b;    	//put data on data port
    2572:	85 bb       	out	0x15, r24	; 21
    2574:	85 e0       	ldi	r24, 0x05	; 5
    2576:	8a 95       	dec	r24
    2578:	f1 f7       	brne	.-4      	; 0x2576 <glcd_write+0x8>
//#define CS_ACTIVE_LOW   1   //Define this if your GLCD CS
                              //is active low 

void trigger()
{
	CONTROLPORT |= EN;	//EN high
    257a:	97 9a       	sbi	0x12, 7	; 18
    257c:	8a e1       	ldi	r24, 0x1A	; 26
    257e:	98 2f       	mov	r25, r24
    2580:	9a 95       	dec	r25
    2582:	f1 f7       	brne	.-4      	; 0x2580 <glcd_write+0x12>
   _delay_us(E_DELAY);
   CONTROLPORT &= ~EN;	//EN low
    2584:	97 98       	cbi	0x12, 7	; 18
    2586:	8a 95       	dec	r24
    2588:	f1 f7       	brne	.-4      	; 0x2586 <glcd_write+0x18>
	CONTROLPORT |= DI;	//DI high --> data
	CONTROLPORT &= ~RW;	//RW low --> write
	DATAPORT = b;    	//put data on data port
   _delay_us(1);
   trigger();
}
    258a:	08 95       	ret

0000258c <glcd_clrln>:
//------------------------
void glcd_clrln(byte ln)
{
    258c:	1f 93       	push	r17
    258e:	18 2f       	mov	r17, r24
    int i;
    goto_xy(0,ln);      //At start of line of left side
    2590:	80 e0       	ldi	r24, 0x00	; 0
    2592:	90 e0       	ldi	r25, 0x00	; 0
    2594:	61 2f       	mov	r22, r17
    2596:	70 e0       	ldi	r23, 0x00	; 0
    2598:	0e 94 a4 12 	call	0x2548	; 0x2548 <goto_xy>
    goto_xy(64,ln);     //At start of line of right side (Problem)
    259c:	80 e4       	ldi	r24, 0x40	; 64
    259e:	90 e0       	ldi	r25, 0x00	; 0
    25a0:	61 2f       	mov	r22, r17
    25a2:	70 e0       	ldi	r23, 0x00	; 0
    25a4:	0e 94 a4 12 	call	0x2548	; 0x2548 <goto_xy>
#ifdef CS_ACTIVE_LOW
    CONTROLPORT &= ~CS1;
#else
    CONTROLPORT |= CS1;
    25a8:	93 9a       	sbi	0x12, 3	; 18
    25aa:	20 e0       	ldi	r18, 0x00	; 0
    25ac:	30 e0       	ldi	r19, 0x00	; 0
    25ae:	45 e0       	ldi	r20, 0x05	; 5
    goto_row(y);
}  
//----------------------
void glcd_write(byte b)
{
	CONTROLPORT |= DI;	//DI high --> data
    25b0:	9a e1       	ldi	r25, 0x1A	; 26
    25b2:	95 9a       	sbi	0x12, 5	; 18
	CONTROLPORT &= ~RW;	//RW low --> write
    25b4:	96 98       	cbi	0x12, 6	; 18
	DATAPORT = b;    	//put data on data port
    25b6:	15 ba       	out	0x15, r1	; 21
    25b8:	84 2f       	mov	r24, r20
    25ba:	8a 95       	dec	r24
    25bc:	f1 f7       	brne	.-4      	; 0x25ba <glcd_clrln+0x2e>
//#define CS_ACTIVE_LOW   1   //Define this if your GLCD CS
                              //is active low 

void trigger()
{
	CONTROLPORT |= EN;	//EN high
    25be:	97 9a       	sbi	0x12, 7	; 18
    25c0:	89 2f       	mov	r24, r25
    25c2:	8a 95       	dec	r24
    25c4:	f1 f7       	brne	.-4      	; 0x25c2 <glcd_clrln+0x36>
   _delay_us(E_DELAY);
   CONTROLPORT &= ~EN;	//EN low
    25c6:	97 98       	cbi	0x12, 7	; 18
    25c8:	89 2f       	mov	r24, r25
    25ca:	8a 95       	dec	r24
    25cc:	f1 f7       	brne	.-4      	; 0x25ca <glcd_clrln+0x3e>
#ifdef CS_ACTIVE_LOW
    CONTROLPORT &= ~CS1;
#else
    CONTROLPORT |= CS1;
#endif
    for(i=0;i<64;i++)
    25ce:	2f 5f       	subi	r18, 0xFF	; 255
    25d0:	3f 4f       	sbci	r19, 0xFF	; 255
    25d2:	20 34       	cpi	r18, 0x40	; 64
    25d4:	31 05       	cpc	r19, r1
    25d6:	69 f7       	brne	.-38     	; 0x25b2 <glcd_clrln+0x26>
        glcd_write(0);
}
    25d8:	1f 91       	pop	r17
    25da:	08 95       	ret

000025dc <glcd_clear>:
//-------------------------
void glcd_clear() //clear the screen
{
    25dc:	1f 93       	push	r17
    25de:	10 e0       	ldi	r17, 0x00	; 0
   int i;
   for(i=0;i<8;i++)
	   glcd_clrln(i);
    25e0:	81 2f       	mov	r24, r17
    25e2:	0e 94 c6 12 	call	0x258c	; 0x258c <glcd_clrln>
    25e6:	1f 5f       	subi	r17, 0xFF	; 255
}
//-------------------------
void glcd_clear() //clear the screen
{
   int i;
   for(i=0;i<8;i++)
    25e8:	18 30       	cpi	r17, 0x08	; 8
    25ea:	d1 f7       	brne	.-12     	; 0x25e0 <glcd_clear+0x4>
	   glcd_clrln(i);
}
    25ec:	1f 91       	pop	r17
    25ee:	08 95       	ret

000025f0 <glcd_read>:
//-----------------------   
byte glcd_read(byte column)
{
    byte read_data = 0; //Read data here
    DATADDR = 0x00;     //Input 
    25f0:	14 ba       	out	0x14, r1	; 20
    
    CONTROLPORT |= RW;	//Read
    25f2:	96 9a       	sbi	0x12, 6	; 18
    CONTROLPORT |= DI;	//Data
    25f4:	95 9a       	sbi	0x12, 5	; 18

    if(column<64)
    25f6:	80 34       	cpi	r24, 0x40	; 64
    25f8:	18 f4       	brcc	.+6      	; 0x2600 <glcd_read+0x10>
    {
#ifdef CS_ACTIVE_LOW
    	CONTROLPORT &= ~CS1;	//Enable CS1
    	CONTROLPORT |= CS2;		//Disable CS2
#else
    	CONTROLPORT |= CS1;		//Enable CS1
    25fa:	93 9a       	sbi	0x12, 3	; 18
    	CONTROLPORT &= ~CS2;	//Disable CS2
    25fc:	94 98       	cbi	0x12, 4	; 18
    25fe:	02 c0       	rjmp	.+4      	; 0x2604 <glcd_read+0x14>
    {
#ifdef CS_ACTIVE_LOW
    	CONTROLPORT &= ~CS2;	//Enable CS2
    	CONTROLPORT |= CS1;		//Disable CS1
#else
    	CONTROLPORT |= CS2;		//Enable CS2
    2600:	94 9a       	sbi	0x12, 4	; 18
    	CONTROLPORT &= ~CS1;	//Disable CS1
    2602:	93 98       	cbi	0x12, 3	; 18
    2604:	95 e0       	ldi	r25, 0x05	; 5
    2606:	89 2f       	mov	r24, r25
    2608:	8a 95       	dec	r24
    260a:	f1 f7       	brne	.-4      	; 0x2608 <glcd_read+0x18>
#endif
    }
    _delay_us(1);        		//tasu
    CONTROLPORT |= EN;			//Latch RAM data into ouput register
    260c:	97 9a       	sbi	0x12, 7	; 18
    260e:	89 2f       	mov	r24, r25
    2610:	8a 95       	dec	r24
    2612:	f1 f7       	brne	.-4      	; 0x2610 <glcd_read+0x20>
    _delay_us(1);        		//twl + tf
    
    //Dummy read
    CONTROLPORT &= ~EN;			//Low Enable
    2614:	97 98       	cbi	0x12, 7	; 18
    2616:	8a e6       	ldi	r24, 0x6A	; 106
    2618:	8a 95       	dec	r24
    261a:	f1 f7       	brne	.-4      	; 0x2618 <glcd_read+0x28>
    _delay_us(20);       		//tf + twl + error
    
    CONTROLPORT |= EN;			//latch data from output register to data bus
    261c:	97 9a       	sbi	0x12, 7	; 18
    261e:	89 2f       	mov	r24, r25
    2620:	8a 95       	dec	r24
    2622:	f1 f7       	brne	.-4      	; 0x2620 <glcd_read+0x30>
    _delay_us(1);        		//tr + td(twh)
                                  
    read_data = DATAPIN;    	//Input data
    2624:	83 b3       	in	r24, 0x13	; 19
    CONTROLPORT &= ~EN;			//Low Enable to remove data from the bus
    2626:	97 98       	cbi	0x12, 7	; 18
    2628:	9a 95       	dec	r25
    262a:	f1 f7       	brne	.-4      	; 0x2628 <glcd_read+0x38>
    _delay_us(1);        		//tdhr
    DATADDR = 0xFF;             //Output again
    262c:	9f ef       	ldi	r25, 0xFF	; 255
    262e:	94 bb       	out	0x14, r25	; 20
    return read_data;      
}
    2630:	08 95       	ret

00002632 <point_at>:
//-----------------------
// set color 0 for light and 1 for dark

void point_at(unsigned int x,unsigned int y,byte color)// set point at (x,y,color)
{
    2632:	df 92       	push	r13
    2634:	ef 92       	push	r14
    2636:	ff 92       	push	r15
    2638:	0f 93       	push	r16
    263a:	1f 93       	push	r17
    263c:	cf 93       	push	r28
    263e:	df 93       	push	r29
    2640:	08 2f       	mov	r16, r24
    2642:	d9 2e       	mov	r13, r25
    2644:	eb 01       	movw	r28, r22
    2646:	14 2f       	mov	r17, r20
    byte pattern = 0;
    goto_xy(x,(int)(y/8));  
    2648:	7b 01       	movw	r14, r22
    264a:	83 e0       	ldi	r24, 0x03	; 3
    264c:	f6 94       	lsr	r15
    264e:	e7 94       	ror	r14
    2650:	8a 95       	dec	r24
    2652:	e1 f7       	brne	.-8      	; 0x264c <point_at+0x1a>
    2654:	80 2f       	mov	r24, r16
    2656:	b7 01       	movw	r22, r14
    2658:	0e 94 a4 12 	call	0x2548	; 0x2548 <goto_xy>
    switch (color)
    265c:	11 23       	and	r17, r17
    265e:	21 f0       	breq	.+8      	; 0x2668 <point_at+0x36>
    2660:	11 30       	cpi	r17, 0x01	; 1
    2662:	91 f0       	breq	.+36     	; 0x2688 <point_at+0x56>
    2664:	10 e0       	ldi	r17, 0x00	; 0
    2666:	1e c0       	rjmp	.+60     	; 0x26a4 <point_at+0x72>
    {               
        case 0:                                
            pattern = ~(1<<(y%8)) & glcd_read(x);                  
    2668:	80 2f       	mov	r24, r16
    266a:	0e 94 f8 12 	call	0x25f0	; 0x25f0 <glcd_read>
    266e:	c7 70       	andi	r28, 0x07	; 7
    2670:	d0 70       	andi	r29, 0x00	; 0
    2672:	21 e0       	ldi	r18, 0x01	; 1
    2674:	30 e0       	ldi	r19, 0x00	; 0
    2676:	02 c0       	rjmp	.+4      	; 0x267c <point_at+0x4a>
    2678:	22 0f       	add	r18, r18
    267a:	33 1f       	adc	r19, r19
    267c:	ca 95       	dec	r28
    267e:	e2 f7       	brpl	.-8      	; 0x2678 <point_at+0x46>
    2680:	12 2f       	mov	r17, r18
    2682:	10 95       	com	r17
    2684:	18 23       	and	r17, r24
    2686:	0e c0       	rjmp	.+28     	; 0x26a4 <point_at+0x72>
        break;    
        case 1:                     
            pattern = (1<<(y%8)) | glcd_read(x);
    2688:	80 2f       	mov	r24, r16
    268a:	0e 94 f8 12 	call	0x25f0	; 0x25f0 <glcd_read>
    268e:	c7 70       	andi	r28, 0x07	; 7
    2690:	d0 70       	andi	r29, 0x00	; 0
    2692:	21 e0       	ldi	r18, 0x01	; 1
    2694:	30 e0       	ldi	r19, 0x00	; 0
    2696:	02 c0       	rjmp	.+4      	; 0x269c <point_at+0x6a>
    2698:	22 0f       	add	r18, r18
    269a:	33 1f       	adc	r19, r19
    269c:	ca 95       	dec	r28
    269e:	e2 f7       	brpl	.-8      	; 0x2698 <point_at+0x66>
    26a0:	18 2f       	mov	r17, r24
    26a2:	12 2b       	or	r17, r18
        break;
    }           
    goto_xy(x,(int)(y/8));                                
    26a4:	80 2f       	mov	r24, r16
    26a6:	9d 2d       	mov	r25, r13
    26a8:	b7 01       	movw	r22, r14
    26aa:	0e 94 a4 12 	call	0x2548	; 0x2548 <goto_xy>
    goto_row(y);
}  
//----------------------
void glcd_write(byte b)
{
	CONTROLPORT |= DI;	//DI high --> data
    26ae:	95 9a       	sbi	0x12, 5	; 18
	CONTROLPORT &= ~RW;	//RW low --> write
    26b0:	96 98       	cbi	0x12, 6	; 18
	DATAPORT = b;    	//put data on data port
    26b2:	15 bb       	out	0x15, r17	; 21
    26b4:	85 e0       	ldi	r24, 0x05	; 5
    26b6:	8a 95       	dec	r24
    26b8:	f1 f7       	brne	.-4      	; 0x26b6 <point_at+0x84>
//#define CS_ACTIVE_LOW   1   //Define this if your GLCD CS
                              //is active low 

void trigger()
{
	CONTROLPORT |= EN;	//EN high
    26ba:	97 9a       	sbi	0x12, 7	; 18
    26bc:	8a e1       	ldi	r24, 0x1A	; 26
    26be:	98 2f       	mov	r25, r24
    26c0:	9a 95       	dec	r25
    26c2:	f1 f7       	brne	.-4      	; 0x26c0 <point_at+0x8e>
   _delay_us(E_DELAY);
   CONTROLPORT &= ~EN;	//EN low
    26c4:	97 98       	cbi	0x12, 7	; 18
    26c6:	8a 95       	dec	r24
    26c8:	f1 f7       	brne	.-4      	; 0x26c6 <point_at+0x94>
            pattern = (1<<(y%8)) | glcd_read(x);
        break;
    }           
    goto_xy(x,(int)(y/8));                                
    glcd_write(pattern);
}
    26ca:	df 91       	pop	r29
    26cc:	cf 91       	pop	r28
    26ce:	1f 91       	pop	r17
    26d0:	0f 91       	pop	r16
    26d2:	ff 90       	pop	r15
    26d4:	ef 90       	pop	r14
    26d6:	df 90       	pop	r13
    26d8:	08 95       	ret

000026da <h_line>:
//-----------------------
void h_line(unsigned int x,unsigned int y,byte l,byte s,byte c)// horizontal line (x,y,length,space between points,color)
{
    26da:	bf 92       	push	r11
    26dc:	cf 92       	push	r12
    26de:	df 92       	push	r13
    26e0:	ef 92       	push	r14
    26e2:	ff 92       	push	r15
    26e4:	0f 93       	push	r16
    26e6:	1f 93       	push	r17
    26e8:	cf 93       	push	r28
    26ea:	df 93       	push	r29
    26ec:	6b 01       	movw	r12, r22
    26ee:	b0 2e       	mov	r11, r16
    int i;
    for(i=x; i<(l+x); i += (byte)(s+1))
    26f0:	ec 01       	movw	r28, r24
    26f2:	7c 01       	movw	r14, r24
    26f4:	e4 0e       	add	r14, r20
    26f6:	f1 1c       	adc	r15, r1
        point_at(i,y,c);
    26f8:	2f 5f       	subi	r18, 0xFF	; 255
    26fa:	02 2f       	mov	r16, r18
    26fc:	10 e0       	ldi	r17, 0x00	; 0
    26fe:	07 c0       	rjmp	.+14     	; 0x270e <h_line+0x34>
    2700:	ce 01       	movw	r24, r28
    2702:	b6 01       	movw	r22, r12
    2704:	4b 2d       	mov	r20, r11
    2706:	0e 94 19 13 	call	0x2632	; 0x2632 <point_at>
    270a:	c0 0f       	add	r28, r16
    270c:	d1 1f       	adc	r29, r17
}
//-----------------------
void h_line(unsigned int x,unsigned int y,byte l,byte s,byte c)// horizontal line (x,y,length,space between points,color)
{
    int i;
    for(i=x; i<(l+x); i += (byte)(s+1))
    270e:	ce 15       	cp	r28, r14
    2710:	df 05       	cpc	r29, r15
    2712:	b0 f3       	brcs	.-20     	; 0x2700 <h_line+0x26>
        point_at(i,y,c);
}
    2714:	df 91       	pop	r29
    2716:	cf 91       	pop	r28
    2718:	1f 91       	pop	r17
    271a:	0f 91       	pop	r16
    271c:	ff 90       	pop	r15
    271e:	ef 90       	pop	r14
    2720:	df 90       	pop	r13
    2722:	cf 90       	pop	r12
    2724:	bf 90       	pop	r11
    2726:	08 95       	ret

00002728 <v_line>:
//-----------------------
void v_line(unsigned int x,unsigned int y,signed int l,byte s,byte c)// vertical line (x,y,length,space between points,color)
{
    2728:	bf 92       	push	r11
    272a:	cf 92       	push	r12
    272c:	df 92       	push	r13
    272e:	ef 92       	push	r14
    2730:	ff 92       	push	r15
    2732:	0f 93       	push	r16
    2734:	1f 93       	push	r17
    2736:	cf 93       	push	r28
    2738:	df 93       	push	r29
    273a:	6c 01       	movw	r12, r24
    273c:	7a 01       	movw	r14, r20
    273e:	b0 2e       	mov	r11, r16
    2740:	eb 01       	movw	r28, r22
    unsigned int i;
    for(i=y; i<(y+l); i += (byte)(s+1))
    2742:	e6 0e       	add	r14, r22
    2744:	f7 1e       	adc	r15, r23
        point_at(x,i,c);
    2746:	2f 5f       	subi	r18, 0xFF	; 255
    2748:	02 2f       	mov	r16, r18
    274a:	10 e0       	ldi	r17, 0x00	; 0
    274c:	07 c0       	rjmp	.+14     	; 0x275c <v_line+0x34>
    274e:	c6 01       	movw	r24, r12
    2750:	be 01       	movw	r22, r28
    2752:	4b 2d       	mov	r20, r11
    2754:	0e 94 19 13 	call	0x2632	; 0x2632 <point_at>
    2758:	c0 0f       	add	r28, r16
    275a:	d1 1f       	adc	r29, r17
}
//-----------------------
void v_line(unsigned int x,unsigned int y,signed int l,byte s,byte c)// vertical line (x,y,length,space between points,color)
{
    unsigned int i;
    for(i=y; i<(y+l); i += (byte)(s+1))
    275c:	ce 15       	cp	r28, r14
    275e:	df 05       	cpc	r29, r15
    2760:	b0 f3       	brcs	.-20     	; 0x274e <v_line+0x26>
        point_at(x,i,c);
}
    2762:	df 91       	pop	r29
    2764:	cf 91       	pop	r28
    2766:	1f 91       	pop	r17
    2768:	0f 91       	pop	r16
    276a:	ff 90       	pop	r15
    276c:	ef 90       	pop	r14
    276e:	df 90       	pop	r13
    2770:	cf 90       	pop	r12
    2772:	bf 90       	pop	r11
    2774:	08 95       	ret

00002776 <rectangle>:
}

void rectangle(unsigned int x1,unsigned int y1,
               unsigned int x2,unsigned int y2,
               byte s,byte c)// rectangle(x1,y1,x2,y2,space between points,color)
{
    2776:	6f 92       	push	r6
    2778:	7f 92       	push	r7
    277a:	8f 92       	push	r8
    277c:	9f 92       	push	r9
    277e:	af 92       	push	r10
    2780:	bf 92       	push	r11
    2782:	cf 92       	push	r12
    2784:	df 92       	push	r13
    2786:	ef 92       	push	r14
    2788:	ff 92       	push	r15
    278a:	0f 93       	push	r16
    278c:	1f 93       	push	r17
    278e:	18 2f       	mov	r17, r24
    2790:	f9 2e       	mov	r15, r25
    2792:	5b 01       	movw	r10, r22
    2794:	74 2e       	mov	r7, r20
    2796:	65 2e       	mov	r6, r21
    2798:	69 01       	movw	r12, r18
    279a:	90 2e       	mov	r9, r16
    h_line(x1,y1,(x2-x1),s,c);
    279c:	84 2e       	mov	r8, r20
    279e:	88 1a       	sub	r8, r24
    27a0:	48 2d       	mov	r20, r8
    27a2:	20 2f       	mov	r18, r16
    27a4:	0e 2d       	mov	r16, r14
    27a6:	0e 94 6d 13 	call	0x26da	; 0x26da <h_line>
    h_line(x1,y2,(x2-x1),s,c);
    27aa:	81 2f       	mov	r24, r17
    27ac:	9f 2d       	mov	r25, r15
    27ae:	b6 01       	movw	r22, r12
    27b0:	48 2d       	mov	r20, r8
    27b2:	29 2d       	mov	r18, r9
    27b4:	0e 94 6d 13 	call	0x26da	; 0x26da <h_line>
    v_line(x1,y1,(y2-y1),s,c);
    27b8:	ca 18       	sub	r12, r10
    27ba:	db 08       	sbc	r13, r11
    27bc:	81 2f       	mov	r24, r17
    27be:	9f 2d       	mov	r25, r15
    27c0:	b5 01       	movw	r22, r10
    27c2:	a6 01       	movw	r20, r12
    27c4:	29 2d       	mov	r18, r9
    27c6:	0e 94 94 13 	call	0x2728	; 0x2728 <v_line>
    v_line(x2,y1,(y2-y1+1),s,c);
    27ca:	08 94       	sec
    27cc:	c1 1c       	adc	r12, r1
    27ce:	d1 1c       	adc	r13, r1
    27d0:	87 2d       	mov	r24, r7
    27d2:	96 2d       	mov	r25, r6
    27d4:	b5 01       	movw	r22, r10
    27d6:	a6 01       	movw	r20, r12
    27d8:	29 2d       	mov	r18, r9
    27da:	0e 94 94 13 	call	0x2728	; 0x2728 <v_line>
}
    27de:	1f 91       	pop	r17
    27e0:	0f 91       	pop	r16
    27e2:	ff 90       	pop	r15
    27e4:	ef 90       	pop	r14
    27e6:	df 90       	pop	r13
    27e8:	cf 90       	pop	r12
    27ea:	bf 90       	pop	r11
    27ec:	af 90       	pop	r10
    27ee:	9f 90       	pop	r9
    27f0:	8f 90       	pop	r8
    27f2:	7f 90       	pop	r7
    27f4:	6f 90       	pop	r6
    27f6:	08 95       	ret

000027f8 <glcd_putchar>:
    v_line(x0-(i-1) ,y0,y ,s,c);
    v_line(x0-(i-1) ,y0-y ,y,s,c);    
}

void glcd_putchar(int c,int x,int y) //(character ie x+8 and  line y from 0-8
{
    27f8:	ef 92       	push	r14
    27fa:	ff 92       	push	r15
    27fc:	1f 93       	push	r17
    27fe:	7c 01       	movw	r14, r24
    2800:	cb 01       	movw	r24, r22
    2802:	14 2f       	mov	r17, r20
   byte i;
  goto_col(x);
    2804:	0e 94 7f 12 	call	0x24fe	; 0x24fe <goto_col>
}   
//----------------------
void goto_row(unsigned int y)
{    
   byte pattern;
   CONTROLPORT &= ~DI;	//DI low --> command
    2808:	95 98       	cbi	0x12, 5	; 18
   CONTROLPORT &= ~RW;	//RW low --> write
    280a:	96 98       	cbi	0x12, 6	; 18
   pattern = (y | 0xB8) & 0xBF; //put row address on data port set command
    280c:	17 70       	andi	r17, 0x07	; 7
    280e:	18 6b       	ori	r17, 0xB8	; 184
   DATAPORT = pattern;   
    2810:	15 bb       	out	0x15, r17	; 21
//#define CS_ACTIVE_LOW   1   //Define this if your GLCD CS
                              //is active low 

void trigger()
{
	CONTROLPORT |= EN;	//EN high
    2812:	97 9a       	sbi	0x12, 7	; 18
    2814:	8a e1       	ldi	r24, 0x1A	; 26
    2816:	98 2f       	mov	r25, r24
    2818:	9a 95       	dec	r25
    281a:	f1 f7       	brne	.-4      	; 0x2818 <glcd_putchar+0x20>
   _delay_us(E_DELAY);
   CONTROLPORT &= ~EN;	//EN low
    281c:	97 98       	cbi	0x12, 7	; 18
    281e:	8a 95       	dec	r24
    2820:	f1 f7       	brne	.-4      	; 0x281e <glcd_putchar+0x26>
    2822:	f7 01       	movw	r30, r14
    2824:	93 e0       	ldi	r25, 0x03	; 3
    2826:	ee 0f       	add	r30, r30
    2828:	ff 1f       	adc	r31, r31
    282a:	9a 95       	dec	r25
    282c:	e1 f7       	brne	.-8      	; 0x2826 <glcd_putchar+0x2e>
    282e:	ec 5a       	subi	r30, 0xAC	; 172
    2830:	ff 4f       	sbci	r31, 0xFF	; 255
    2832:	90 e0       	ldi	r25, 0x00	; 0
   byte i;
  goto_col(x);
  goto_row(y);
  for(i=0;i<8;i++)
  {
     glcd_write(pgm_read_byte(&(font[(8*(c))+i]))); 
    2834:	35 e0       	ldi	r19, 0x05	; 5
    2836:	2a e1       	ldi	r18, 0x1A	; 26
    2838:	84 91       	lpm	r24, Z+
    goto_row(y);
}  
//----------------------
void glcd_write(byte b)
{
	CONTROLPORT |= DI;	//DI high --> data
    283a:	95 9a       	sbi	0x12, 5	; 18
	CONTROLPORT &= ~RW;	//RW low --> write
    283c:	96 98       	cbi	0x12, 6	; 18
	DATAPORT = b;    	//put data on data port
    283e:	85 bb       	out	0x15, r24	; 21
    2840:	83 2f       	mov	r24, r19
    2842:	8a 95       	dec	r24
    2844:	f1 f7       	brne	.-4      	; 0x2842 <glcd_putchar+0x4a>
//#define CS_ACTIVE_LOW   1   //Define this if your GLCD CS
                              //is active low 

void trigger()
{
	CONTROLPORT |= EN;	//EN high
    2846:	97 9a       	sbi	0x12, 7	; 18
    2848:	82 2f       	mov	r24, r18
    284a:	8a 95       	dec	r24
    284c:	f1 f7       	brne	.-4      	; 0x284a <glcd_putchar+0x52>
   _delay_us(E_DELAY);
   CONTROLPORT &= ~EN;	//EN low
    284e:	97 98       	cbi	0x12, 7	; 18
    2850:	82 2f       	mov	r24, r18
    2852:	8a 95       	dec	r24
    2854:	f1 f7       	brne	.-4      	; 0x2852 <glcd_putchar+0x5a>
void glcd_putchar(int c,int x,int y) //(character ie x+8 and  line y from 0-8
{
   byte i;
  goto_col(x);
  goto_row(y);
  for(i=0;i<8;i++)
    2856:	9f 5f       	subi	r25, 0xFF	; 255
    2858:	31 96       	adiw	r30, 0x01	; 1
    285a:	98 30       	cpi	r25, 0x08	; 8
    285c:	69 f7       	brne	.-38     	; 0x2838 <glcd_putchar+0x40>
  {
     glcd_write(pgm_read_byte(&(font[(8*(c))+i]))); 
  }
}
    285e:	1f 91       	pop	r17
    2860:	ff 90       	pop	r15
    2862:	ef 90       	pop	r14
    2864:	08 95       	ret

00002866 <glcdwrite>:
   }
}

void glcdwrite (uint8_t b)
{
	CONTROLPORT |= DI;	//DI high --> data
    2866:	95 9a       	sbi	0x12, 5	; 18
	CONTROLPORT &= ~RW;	//RW low --> write
    2868:	96 98       	cbi	0x12, 6	; 18
	DATAPORT = b;    	//put data on data port
    286a:	85 bb       	out	0x15, r24	; 21
    286c:	85 e0       	ldi	r24, 0x05	; 5
    286e:	8a 95       	dec	r24
    2870:	f1 f7       	brne	.-4      	; 0x286e <glcdwrite+0x8>
//#define CS_ACTIVE_LOW   1   //Define this if your GLCD CS
                              //is active low 

void trigger()
{
	CONTROLPORT |= EN;	//EN high
    2872:	97 9a       	sbi	0x12, 7	; 18
    2874:	8a e1       	ldi	r24, 0x1A	; 26
    2876:	98 2f       	mov	r25, r24
    2878:	9a 95       	dec	r25
    287a:	f1 f7       	brne	.-4      	; 0x2878 <glcdwrite+0x12>
   _delay_us(E_DELAY);
   CONTROLPORT &= ~EN;	//EN low
    287c:	97 98       	cbi	0x12, 7	; 18
    287e:	8a 95       	dec	r24
    2880:	f1 f7       	brne	.-4      	; 0x287e <glcdwrite+0x18>
	CONTROLPORT |= DI;	//DI high --> data
	CONTROLPORT &= ~RW;	//RW low --> write
	DATAPORT = b;    	//put data on data port
   _delay_us(1);
   trigger();
}
    2882:	08 95       	ret

00002884 <bmp_disp>:

//---------------------BITMAP IMAGE DISPLAY----------------------------
void bmp_disp(byte *bmp)
{
    2884:	ef 92       	push	r14
    2886:	ff 92       	push	r15
    2888:	0f 93       	push	r16
    288a:	1f 93       	push	r17
    288c:	cf 93       	push	r28
    288e:	df 93       	push	r29
    2890:	7c 01       	movw	r14, r24
    2892:	c0 e0       	ldi	r28, 0x00	; 0
    2894:	d0 e0       	ldi	r29, 0x00	; 0
    2896:	1a e1       	ldi	r17, 0x1A	; 26
int i;
for(i=0;i<1024;i++)
{       

   goto_col(i%128);            
    2898:	05 e0       	ldi	r16, 0x05	; 5
    289a:	ce 01       	movw	r24, r28
    289c:	8f 77       	andi	r24, 0x7F	; 127
    289e:	90 70       	andi	r25, 0x00	; 0
    28a0:	0e 94 7f 12 	call	0x24fe	; 0x24fe <goto_col>
}   
//----------------------
void goto_row(unsigned int y)
{    
   byte pattern;
   CONTROLPORT &= ~DI;	//DI low --> command
    28a4:	95 98       	cbi	0x12, 5	; 18
   CONTROLPORT &= ~RW;	//RW low --> write
    28a6:	96 98       	cbi	0x12, 6	; 18
   pattern = (y | 0xB8) & 0xBF; //put row address on data port set command
    28a8:	ce 01       	movw	r24, r28
    28aa:	88 0f       	add	r24, r24
    28ac:	89 2f       	mov	r24, r25
    28ae:	88 1f       	adc	r24, r24
    28b0:	99 0b       	sbc	r25, r25
    28b2:	87 70       	andi	r24, 0x07	; 7
    28b4:	88 6b       	ori	r24, 0xB8	; 184
   DATAPORT = pattern;   
    28b6:	85 bb       	out	0x15, r24	; 21
//#define CS_ACTIVE_LOW   1   //Define this if your GLCD CS
                              //is active low 

void trigger()
{
	CONTROLPORT |= EN;	//EN high
    28b8:	97 9a       	sbi	0x12, 7	; 18
    28ba:	81 2f       	mov	r24, r17
    28bc:	8a 95       	dec	r24
    28be:	f1 f7       	brne	.-4      	; 0x28bc <bmp_disp+0x38>
   _delay_us(E_DELAY);
   CONTROLPORT &= ~EN;	//EN low
    28c0:	97 98       	cbi	0x12, 7	; 18
    28c2:	81 2f       	mov	r24, r17
    28c4:	8a 95       	dec	r24
    28c6:	f1 f7       	brne	.-4      	; 0x28c4 <bmp_disp+0x40>
for(i=0;i<1024;i++)
{       

   goto_col(i%128);            
   goto_row(i/128);   
   glcd_write(pgm_read_byte(&bmp[i]));                              
    28c8:	f7 01       	movw	r30, r14
    28ca:	ec 0f       	add	r30, r28
    28cc:	fd 1f       	adc	r31, r29
    28ce:	e4 91       	lpm	r30, Z+
    goto_row(y);
}  
//----------------------
void glcd_write(byte b)
{
	CONTROLPORT |= DI;	//DI high --> data
    28d0:	95 9a       	sbi	0x12, 5	; 18
	CONTROLPORT &= ~RW;	//RW low --> write
    28d2:	96 98       	cbi	0x12, 6	; 18
	DATAPORT = b;    	//put data on data port
    28d4:	e5 bb       	out	0x15, r30	; 21
    28d6:	80 2f       	mov	r24, r16
    28d8:	8a 95       	dec	r24
    28da:	f1 f7       	brne	.-4      	; 0x28d8 <bmp_disp+0x54>
//#define CS_ACTIVE_LOW   1   //Define this if your GLCD CS
                              //is active low 

void trigger()
{
	CONTROLPORT |= EN;	//EN high
    28dc:	97 9a       	sbi	0x12, 7	; 18
    28de:	81 2f       	mov	r24, r17
    28e0:	8a 95       	dec	r24
    28e2:	f1 f7       	brne	.-4      	; 0x28e0 <bmp_disp+0x5c>
   _delay_us(E_DELAY);
   CONTROLPORT &= ~EN;	//EN low
    28e4:	97 98       	cbi	0x12, 7	; 18
    28e6:	81 2f       	mov	r24, r17
    28e8:	8a 95       	dec	r24
    28ea:	f1 f7       	brne	.-4      	; 0x28e8 <bmp_disp+0x64>

//---------------------BITMAP IMAGE DISPLAY----------------------------
void bmp_disp(byte *bmp)
{
int i;
for(i=0;i<1024;i++)
    28ec:	21 96       	adiw	r28, 0x01	; 1
    28ee:	84 e0       	ldi	r24, 0x04	; 4
    28f0:	c0 30       	cpi	r28, 0x00	; 0
    28f2:	d8 07       	cpc	r29, r24
    28f4:	91 f6       	brne	.-92     	; 0x289a <bmp_disp+0x16>

   goto_col(i%128);            
   goto_row(i/128);   
   glcd_write(pgm_read_byte(&bmp[i]));                              
}   
}
    28f6:	df 91       	pop	r29
    28f8:	cf 91       	pop	r28
    28fa:	1f 91       	pop	r17
    28fc:	0f 91       	pop	r16
    28fe:	ff 90       	pop	r15
    2900:	ef 90       	pop	r14
    2902:	08 95       	ret

00002904 <horizontal_change>:

//----------------ANIMATION AND TRANSITION EFFECTS---------------------

void horizontal_change(byte *bmp,uint8_t color)
//transition to new image with horizontal wipe-in effect 
{
    2904:	bf 92       	push	r11
    2906:	cf 92       	push	r12
    2908:	df 92       	push	r13
    290a:	ef 92       	push	r14
    290c:	ff 92       	push	r15
    290e:	0f 93       	push	r16
    2910:	1f 93       	push	r17
    2912:	cf 93       	push	r28
    2914:	df 93       	push	r29
    2916:	e6 2e       	mov	r14, r22
    2918:	8c 01       	movw	r16, r24
    291a:	c0 e0       	ldi	r28, 0x00	; 0
    291c:	d0 e0       	ldi	r29, 0x00	; 0
    291e:	6a e1       	ldi	r22, 0x1A	; 26
    2920:	f6 2e       	mov	r15, r22
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    2922:	55 e0       	ldi	r21, 0x05	; 5
    2924:	b5 2e       	mov	r11, r21
    2926:	40 e4       	ldi	r20, 0x40	; 64
    2928:	c4 2e       	mov	r12, r20
    292a:	4f e1       	ldi	r20, 0x1F	; 31
    292c:	d4 2e       	mov	r13, r20
int i;
for(i=0;i<1024;i++)
{       

   goto_col(i%128);            
    292e:	ce 01       	movw	r24, r28
    2930:	8f 77       	andi	r24, 0x7F	; 127
    2932:	90 70       	andi	r25, 0x00	; 0
    2934:	0e 94 7f 12 	call	0x24fe	; 0x24fe <goto_col>
}   
//----------------------
void goto_row(unsigned int y)
{    
   byte pattern;
   CONTROLPORT &= ~DI;	//DI low --> command
    2938:	95 98       	cbi	0x12, 5	; 18
   CONTROLPORT &= ~RW;	//RW low --> write
    293a:	96 98       	cbi	0x12, 6	; 18
   pattern = (y | 0xB8) & 0xBF; //put row address on data port set command
    293c:	ce 01       	movw	r24, r28
    293e:	88 0f       	add	r24, r24
    2940:	89 2f       	mov	r24, r25
    2942:	88 1f       	adc	r24, r24
    2944:	99 0b       	sbc	r25, r25
    2946:	87 70       	andi	r24, 0x07	; 7
    2948:	88 6b       	ori	r24, 0xB8	; 184
   DATAPORT = pattern;   
    294a:	85 bb       	out	0x15, r24	; 21
//#define CS_ACTIVE_LOW   1   //Define this if your GLCD CS
                              //is active low 

void trigger()
{
	CONTROLPORT |= EN;	//EN high
    294c:	97 9a       	sbi	0x12, 7	; 18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    294e:	8f 2d       	mov	r24, r15
    2950:	8a 95       	dec	r24
    2952:	f1 f7       	brne	.-4      	; 0x2950 <horizontal_change+0x4c>
   _delay_us(E_DELAY);
   CONTROLPORT &= ~EN;	//EN low
    2954:	97 98       	cbi	0x12, 7	; 18
    2956:	8f 2d       	mov	r24, r15
    2958:	8a 95       	dec	r24
    295a:	f1 f7       	brne	.-4      	; 0x2958 <horizontal_change+0x54>
for(i=0;i<1024;i++)
{       

   goto_col(i%128);            
   goto_row(i/128); 
   if(color==1)  
    295c:	81 e0       	ldi	r24, 0x01	; 1
    295e:	e8 16       	cp	r14, r24
    2960:	19 f4       	brne	.+6      	; 0x2968 <horizontal_change+0x64>
   glcd_write(pgm_read_byte(&bmp[i])); 
    2962:	f8 01       	movw	r30, r16
    2964:	84 91       	lpm	r24, Z+
    2966:	03 c0       	rjmp	.+6      	; 0x296e <horizontal_change+0x6a>
   else 
   glcd_write(~(pgm_read_byte(&bmp[i]))); 
    2968:	f8 01       	movw	r30, r16
    296a:	84 91       	lpm	r24, Z+
    296c:	80 95       	com	r24
    goto_row(y);
}  
//----------------------
void glcd_write(byte b)
{
	CONTROLPORT |= DI;	//DI high --> data
    296e:	95 9a       	sbi	0x12, 5	; 18
	CONTROLPORT &= ~RW;	//RW low --> write
    2970:	96 98       	cbi	0x12, 6	; 18
	DATAPORT = b;    	//put data on data port
    2972:	85 bb       	out	0x15, r24	; 21
    2974:	8b 2d       	mov	r24, r11
    2976:	8a 95       	dec	r24
    2978:	f1 f7       	brne	.-4      	; 0x2976 <horizontal_change+0x72>
//#define CS_ACTIVE_LOW   1   //Define this if your GLCD CS
                              //is active low 

void trigger()
{
	CONTROLPORT |= EN;	//EN high
    297a:	97 9a       	sbi	0x12, 7	; 18
    297c:	8f 2d       	mov	r24, r15
    297e:	8a 95       	dec	r24
    2980:	f1 f7       	brne	.-4      	; 0x297e <horizontal_change+0x7a>
   _delay_us(E_DELAY);
   CONTROLPORT &= ~EN;	//EN low
    2982:	97 98       	cbi	0x12, 7	; 18
    2984:	8f 2d       	mov	r24, r15
    2986:	8a 95       	dec	r24
    2988:	f1 f7       	brne	.-4      	; 0x2986 <horizontal_change+0x82>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    298a:	c6 01       	movw	r24, r12
    298c:	01 97       	sbiw	r24, 0x01	; 1
    298e:	f1 f7       	brne	.-4      	; 0x298c <horizontal_change+0x88>

void horizontal_change(byte *bmp,uint8_t color)
//transition to new image with horizontal wipe-in effect 
{
int i;
for(i=0;i<1024;i++)
    2990:	21 96       	adiw	r28, 0x01	; 1
    2992:	0f 5f       	subi	r16, 0xFF	; 255
    2994:	1f 4f       	sbci	r17, 0xFF	; 255
    2996:	f4 e0       	ldi	r31, 0x04	; 4
    2998:	c0 30       	cpi	r28, 0x00	; 0
    299a:	df 07       	cpc	r29, r31
    299c:	09 f0       	breq	.+2      	; 0x29a0 <horizontal_change+0x9c>
    299e:	c7 cf       	rjmp	.-114    	; 0x292e <horizontal_change+0x2a>
   glcd_write(pgm_read_byte(&bmp[i])); 
   else 
   glcd_write(~(pgm_read_byte(&bmp[i]))); 
   _delay_ms(2);                            
}   
}
    29a0:	df 91       	pop	r29
    29a2:	cf 91       	pop	r28
    29a4:	1f 91       	pop	r17
    29a6:	0f 91       	pop	r16
    29a8:	ff 90       	pop	r15
    29aa:	ef 90       	pop	r14
    29ac:	df 90       	pop	r13
    29ae:	cf 90       	pop	r12
    29b0:	bf 90       	pop	r11
    29b2:	08 95       	ret

000029b4 <vertical_change>:

void vertical_change(byte *bmp,uint8_t color)
//transition to new image with vertical wipe-in effect  
{
    29b4:	9f 92       	push	r9
    29b6:	af 92       	push	r10
    29b8:	bf 92       	push	r11
    29ba:	cf 92       	push	r12
    29bc:	df 92       	push	r13
    29be:	ef 92       	push	r14
    29c0:	ff 92       	push	r15
    29c2:	0f 93       	push	r16
    29c4:	1f 93       	push	r17
    29c6:	cf 93       	push	r28
    29c8:	df 93       	push	r29
    29ca:	c6 2e       	mov	r12, r22
    29cc:	7c 01       	movw	r14, r24
    29ce:	00 e0       	ldi	r16, 0x00	; 0
    29d0:	10 e0       	ldi	r17, 0x00	; 0
    29d2:	c0 e0       	ldi	r28, 0x00	; 0
    29d4:	d0 e0       	ldi	r29, 0x00	; 0
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    29d6:	aa e1       	ldi	r26, 0x1A	; 26
    29d8:	da 2e       	mov	r13, r26
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    29da:	f5 e0       	ldi	r31, 0x05	; 5
    29dc:	9f 2e       	mov	r9, r31
    29de:	e0 e9       	ldi	r30, 0x90	; 144
    29e0:	ae 2e       	mov	r10, r30
    29e2:	e1 e0       	ldi	r30, 0x01	; 1
    29e4:	be 2e       	mov	r11, r30
int i,cnt=0,cnt_prev=0;

for(i=0;i<1024;i++)
{       

   goto_col(i%128);            
    29e6:	ce 01       	movw	r24, r28
    29e8:	8f 77       	andi	r24, 0x7F	; 127
    29ea:	90 70       	andi	r25, 0x00	; 0
    29ec:	0e 94 7f 12 	call	0x24fe	; 0x24fe <goto_col>
   goto_row(i/128); 
    29f0:	9e 01       	movw	r18, r28
    29f2:	22 0f       	add	r18, r18
    29f4:	23 2f       	mov	r18, r19
    29f6:	22 1f       	adc	r18, r18
    29f8:	33 0b       	sbc	r19, r19
}   
//----------------------
void goto_row(unsigned int y)
{    
   byte pattern;
   CONTROLPORT &= ~DI;	//DI low --> command
    29fa:	95 98       	cbi	0x12, 5	; 18
   CONTROLPORT &= ~RW;	//RW low --> write
    29fc:	96 98       	cbi	0x12, 6	; 18
   pattern = (y | 0xB8) & 0xBF; //put row address on data port set command
    29fe:	82 2f       	mov	r24, r18
    2a00:	87 70       	andi	r24, 0x07	; 7
    2a02:	88 6b       	ori	r24, 0xB8	; 184
   DATAPORT = pattern;   
    2a04:	85 bb       	out	0x15, r24	; 21
//#define CS_ACTIVE_LOW   1   //Define this if your GLCD CS
                              //is active low 

void trigger()
{
	CONTROLPORT |= EN;	//EN high
    2a06:	97 9a       	sbi	0x12, 7	; 18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    2a08:	8d 2d       	mov	r24, r13
    2a0a:	8a 95       	dec	r24
    2a0c:	f1 f7       	brne	.-4      	; 0x2a0a <vertical_change+0x56>
   _delay_us(E_DELAY);
   CONTROLPORT &= ~EN;	//EN low
    2a0e:	97 98       	cbi	0x12, 7	; 18
    2a10:	8d 2d       	mov	r24, r13
    2a12:	8a 95       	dec	r24
    2a14:	f1 f7       	brne	.-4      	; 0x2a12 <vertical_change+0x5e>
{       

   goto_col(i%128);            
   goto_row(i/128); 
   cnt=(int)(i/128);
   if(color==1)  
    2a16:	81 e0       	ldi	r24, 0x01	; 1
    2a18:	c8 16       	cp	r12, r24
    2a1a:	19 f4       	brne	.+6      	; 0x2a22 <vertical_change+0x6e>
   glcd_write(pgm_read_byte(&bmp[i])); 
    2a1c:	f7 01       	movw	r30, r14
    2a1e:	84 91       	lpm	r24, Z+
    2a20:	03 c0       	rjmp	.+6      	; 0x2a28 <vertical_change+0x74>
   else 
   glcd_write(~(pgm_read_byte(&bmp[i]))); 
    2a22:	f7 01       	movw	r30, r14
    2a24:	84 91       	lpm	r24, Z+
    2a26:	80 95       	com	r24
    goto_row(y);
}  
//----------------------
void glcd_write(byte b)
{
	CONTROLPORT |= DI;	//DI high --> data
    2a28:	95 9a       	sbi	0x12, 5	; 18
	CONTROLPORT &= ~RW;	//RW low --> write
    2a2a:	96 98       	cbi	0x12, 6	; 18
	DATAPORT = b;    	//put data on data port
    2a2c:	85 bb       	out	0x15, r24	; 21
    2a2e:	89 2d       	mov	r24, r9
    2a30:	8a 95       	dec	r24
    2a32:	f1 f7       	brne	.-4      	; 0x2a30 <vertical_change+0x7c>
//#define CS_ACTIVE_LOW   1   //Define this if your GLCD CS
                              //is active low 

void trigger()
{
	CONTROLPORT |= EN;	//EN high
    2a34:	97 9a       	sbi	0x12, 7	; 18
    2a36:	8d 2d       	mov	r24, r13
    2a38:	8a 95       	dec	r24
    2a3a:	f1 f7       	brne	.-4      	; 0x2a38 <vertical_change+0x84>
   _delay_us(E_DELAY);
   CONTROLPORT &= ~EN;	//EN low
    2a3c:	97 98       	cbi	0x12, 7	; 18
    2a3e:	8d 2d       	mov	r24, r13
    2a40:	8a 95       	dec	r24
    2a42:	f1 f7       	brne	.-4      	; 0x2a40 <vertical_change+0x8c>
   cnt=(int)(i/128);
   if(color==1)  
   glcd_write(pgm_read_byte(&bmp[i])); 
   else 
   glcd_write(~(pgm_read_byte(&bmp[i]))); 
   if(cnt>cnt_prev)
    2a44:	02 17       	cp	r16, r18
    2a46:	13 07       	cpc	r17, r19
    2a48:	14 f0       	brlt	.+4      	; 0x2a4e <vertical_change+0x9a>
    2a4a:	98 01       	movw	r18, r16
    2a4c:	07 c0       	rjmp	.+14     	; 0x2a5c <vertical_change+0xa8>
    2a4e:	80 ed       	ldi	r24, 0xD0	; 208
    2a50:	97 e0       	ldi	r25, 0x07	; 7
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    2a52:	f5 01       	movw	r30, r10
    2a54:	31 97       	sbiw	r30, 0x01	; 1
    2a56:	f1 f7       	brne	.-4      	; 0x2a54 <vertical_change+0xa0>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2a58:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2a5a:	d9 f7       	brne	.-10     	; 0x2a52 <vertical_change+0x9e>
void vertical_change(byte *bmp,uint8_t color)
//transition to new image with vertical wipe-in effect  
{
int i,cnt=0,cnt_prev=0;

for(i=0;i<1024;i++)
    2a5c:	21 96       	adiw	r28, 0x01	; 1
    2a5e:	08 94       	sec
    2a60:	e1 1c       	adc	r14, r1
    2a62:	f1 1c       	adc	r15, r1
    2a64:	f4 e0       	ldi	r31, 0x04	; 4
    2a66:	c0 30       	cpi	r28, 0x00	; 0
    2a68:	df 07       	cpc	r29, r31
    2a6a:	11 f0       	breq	.+4      	; 0x2a70 <vertical_change+0xbc>
    2a6c:	89 01       	movw	r16, r18
    2a6e:	bb cf       	rjmp	.-138    	; 0x29e6 <vertical_change+0x32>
   glcd_write(~(pgm_read_byte(&bmp[i]))); 
   if(cnt>cnt_prev)
   {_delay_ms(200);cnt_prev=cnt;}  
} 

}
    2a70:	df 91       	pop	r29
    2a72:	cf 91       	pop	r28
    2a74:	1f 91       	pop	r17
    2a76:	0f 91       	pop	r16
    2a78:	ff 90       	pop	r15
    2a7a:	ef 90       	pop	r14
    2a7c:	df 90       	pop	r13
    2a7e:	cf 90       	pop	r12
    2a80:	bf 90       	pop	r11
    2a82:	af 90       	pop	r10
    2a84:	9f 90       	pop	r9
    2a86:	08 95       	ret

00002a88 <glcd_hclear>:

void glcd_hclear(uint8_t color)
//clears screen with horizontal wipe-in effect 
{
    2a88:	cf 92       	push	r12
    2a8a:	df 92       	push	r13
    2a8c:	ef 92       	push	r14
    2a8e:	ff 92       	push	r15
    2a90:	0f 93       	push	r16
    2a92:	1f 93       	push	r17
    2a94:	cf 93       	push	r28
    2a96:	df 93       	push	r29
    2a98:	08 2f       	mov	r16, r24
    2a9a:	c0 e0       	ldi	r28, 0x00	; 0
    2a9c:	d0 e0       	ldi	r29, 0x00	; 0
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    2a9e:	1a e1       	ldi	r17, 0x1A	; 26
//----------------------
void glcd_write(byte b)
{
	CONTROLPORT |= DI;	//DI high --> data
	CONTROLPORT &= ~RW;	//RW low --> write
	DATAPORT = b;    	//put data on data port
    2aa0:	95 e0       	ldi	r25, 0x05	; 5
    2aa2:	d9 2e       	mov	r13, r25
    2aa4:	cc 24       	eor	r12, r12
    2aa6:	ca 94       	dec	r12
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    2aa8:	80 e4       	ldi	r24, 0x40	; 64
    2aaa:	e8 2e       	mov	r14, r24
    2aac:	8f e1       	ldi	r24, 0x1F	; 31
    2aae:	f8 2e       	mov	r15, r24
{
int i;
for(i=0;i<1024;i++)
{       

   goto_col(i%128);            
    2ab0:	ce 01       	movw	r24, r28
    2ab2:	8f 77       	andi	r24, 0x7F	; 127
    2ab4:	90 70       	andi	r25, 0x00	; 0
    2ab6:	0e 94 7f 12 	call	0x24fe	; 0x24fe <goto_col>
}   
//----------------------
void goto_row(unsigned int y)
{    
   byte pattern;
   CONTROLPORT &= ~DI;	//DI low --> command
    2aba:	95 98       	cbi	0x12, 5	; 18
   CONTROLPORT &= ~RW;	//RW low --> write
    2abc:	96 98       	cbi	0x12, 6	; 18
   pattern = (y | 0xB8) & 0xBF; //put row address on data port set command
    2abe:	ce 01       	movw	r24, r28
    2ac0:	88 0f       	add	r24, r24
    2ac2:	89 2f       	mov	r24, r25
    2ac4:	88 1f       	adc	r24, r24
    2ac6:	99 0b       	sbc	r25, r25
    2ac8:	87 70       	andi	r24, 0x07	; 7
    2aca:	88 6b       	ori	r24, 0xB8	; 184
   DATAPORT = pattern;   
    2acc:	85 bb       	out	0x15, r24	; 21
//#define CS_ACTIVE_LOW   1   //Define this if your GLCD CS
                              //is active low 

void trigger()
{
	CONTROLPORT |= EN;	//EN high
    2ace:	97 9a       	sbi	0x12, 7	; 18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    2ad0:	81 2f       	mov	r24, r17
    2ad2:	8a 95       	dec	r24
    2ad4:	f1 f7       	brne	.-4      	; 0x2ad2 <glcd_hclear+0x4a>
   _delay_us(E_DELAY);
   CONTROLPORT &= ~EN;	//EN low
    2ad6:	97 98       	cbi	0x12, 7	; 18
    2ad8:	81 2f       	mov	r24, r17
    2ada:	8a 95       	dec	r24
    2adc:	f1 f7       	brne	.-4      	; 0x2ada <glcd_hclear+0x52>
for(i=0;i<1024;i++)
{       

   goto_col(i%128);            
   goto_row(i/128);   
   if(color==1)  
    2ade:	01 30       	cpi	r16, 0x01	; 1
    2ae0:	21 f4       	brne	.+8      	; 0x2aea <glcd_hclear+0x62>
    goto_row(y);
}  
//----------------------
void glcd_write(byte b)
{
	CONTROLPORT |= DI;	//DI high --> data
    2ae2:	95 9a       	sbi	0x12, 5	; 18
	CONTROLPORT &= ~RW;	//RW low --> write
    2ae4:	96 98       	cbi	0x12, 6	; 18
	DATAPORT = b;    	//put data on data port
    2ae6:	c5 ba       	out	0x15, r12	; 21
    2ae8:	03 c0       	rjmp	.+6      	; 0x2af0 <glcd_hclear+0x68>
    goto_row(y);
}  
//----------------------
void glcd_write(byte b)
{
	CONTROLPORT |= DI;	//DI high --> data
    2aea:	95 9a       	sbi	0x12, 5	; 18
	CONTROLPORT &= ~RW;	//RW low --> write
    2aec:	96 98       	cbi	0x12, 6	; 18
	DATAPORT = b;    	//put data on data port
    2aee:	15 ba       	out	0x15, r1	; 21
    2af0:	8d 2d       	mov	r24, r13
    2af2:	8a 95       	dec	r24
    2af4:	f1 f7       	brne	.-4      	; 0x2af2 <glcd_hclear+0x6a>
//#define CS_ACTIVE_LOW   1   //Define this if your GLCD CS
                              //is active low 

void trigger()
{
	CONTROLPORT |= EN;	//EN high
    2af6:	97 9a       	sbi	0x12, 7	; 18
    2af8:	81 2f       	mov	r24, r17
    2afa:	8a 95       	dec	r24
    2afc:	f1 f7       	brne	.-4      	; 0x2afa <glcd_hclear+0x72>
   _delay_us(E_DELAY);
   CONTROLPORT &= ~EN;	//EN low
    2afe:	97 98       	cbi	0x12, 7	; 18
    2b00:	81 2f       	mov	r24, r17
    2b02:	8a 95       	dec	r24
    2b04:	f1 f7       	brne	.-4      	; 0x2b02 <glcd_hclear+0x7a>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    2b06:	c7 01       	movw	r24, r14
    2b08:	01 97       	sbiw	r24, 0x01	; 1
    2b0a:	f1 f7       	brne	.-4      	; 0x2b08 <glcd_hclear+0x80>

void glcd_hclear(uint8_t color)
//clears screen with horizontal wipe-in effect 
{
int i;
for(i=0;i<1024;i++)
    2b0c:	21 96       	adiw	r28, 0x01	; 1
    2b0e:	84 e0       	ldi	r24, 0x04	; 4
    2b10:	c0 30       	cpi	r28, 0x00	; 0
    2b12:	d8 07       	cpc	r29, r24
    2b14:	69 f6       	brne	.-102    	; 0x2ab0 <glcd_hclear+0x28>
   glcd_write(0xff); 
   else 
   glcd_write(0x00); 
   _delay_ms(2);                            
}                                
}   
    2b16:	df 91       	pop	r29
    2b18:	cf 91       	pop	r28
    2b1a:	1f 91       	pop	r17
    2b1c:	0f 91       	pop	r16
    2b1e:	ff 90       	pop	r15
    2b20:	ef 90       	pop	r14
    2b22:	df 90       	pop	r13
    2b24:	cf 90       	pop	r12
    2b26:	08 95       	ret

00002b28 <glcd_vclear>:

void glcd_vclear(uint8_t color)
//clears screen with vertical wipe-in effect 
{
    2b28:	af 92       	push	r10
    2b2a:	bf 92       	push	r11
    2b2c:	cf 92       	push	r12
    2b2e:	df 92       	push	r13
    2b30:	ef 92       	push	r14
    2b32:	ff 92       	push	r15
    2b34:	0f 93       	push	r16
    2b36:	1f 93       	push	r17
    2b38:	cf 93       	push	r28
    2b3a:	df 93       	push	r29
    2b3c:	e8 2e       	mov	r14, r24
    2b3e:	c0 e0       	ldi	r28, 0x00	; 0
    2b40:	d0 e0       	ldi	r29, 0x00	; 0
    2b42:	00 e0       	ldi	r16, 0x00	; 0
    2b44:	10 e0       	ldi	r17, 0x00	; 0
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    2b46:	7a e1       	ldi	r23, 0x1A	; 26
    2b48:	f7 2e       	mov	r15, r23
//----------------------
void glcd_write(byte b)
{
	CONTROLPORT |= DI;	//DI high --> data
	CONTROLPORT &= ~RW;	//RW low --> write
	DATAPORT = b;    	//put data on data port
    2b4a:	65 e0       	ldi	r22, 0x05	; 5
    2b4c:	b6 2e       	mov	r11, r22
    2b4e:	aa 24       	eor	r10, r10
    2b50:	aa 94       	dec	r10
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    2b52:	50 e9       	ldi	r21, 0x90	; 144
    2b54:	c5 2e       	mov	r12, r21
    2b56:	51 e0       	ldi	r21, 0x01	; 1
    2b58:	d5 2e       	mov	r13, r21
int i,cnt=0,cnt_prev=0;

for(i=0;i<1024;i++)
{       

   goto_col(i%128);            
    2b5a:	ce 01       	movw	r24, r28
    2b5c:	8f 77       	andi	r24, 0x7F	; 127
    2b5e:	90 70       	andi	r25, 0x00	; 0
    2b60:	0e 94 7f 12 	call	0x24fe	; 0x24fe <goto_col>
   goto_row(i/128); 
    2b64:	9e 01       	movw	r18, r28
    2b66:	22 0f       	add	r18, r18
    2b68:	23 2f       	mov	r18, r19
    2b6a:	22 1f       	adc	r18, r18
    2b6c:	33 0b       	sbc	r19, r19
}   
//----------------------
void goto_row(unsigned int y)
{    
   byte pattern;
   CONTROLPORT &= ~DI;	//DI low --> command
    2b6e:	95 98       	cbi	0x12, 5	; 18
   CONTROLPORT &= ~RW;	//RW low --> write
    2b70:	96 98       	cbi	0x12, 6	; 18
   pattern = (y | 0xB8) & 0xBF; //put row address on data port set command
    2b72:	82 2f       	mov	r24, r18
    2b74:	87 70       	andi	r24, 0x07	; 7
    2b76:	88 6b       	ori	r24, 0xB8	; 184
   DATAPORT = pattern;   
    2b78:	85 bb       	out	0x15, r24	; 21
//#define CS_ACTIVE_LOW   1   //Define this if your GLCD CS
                              //is active low 

void trigger()
{
	CONTROLPORT |= EN;	//EN high
    2b7a:	97 9a       	sbi	0x12, 7	; 18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    2b7c:	8f 2d       	mov	r24, r15
    2b7e:	8a 95       	dec	r24
    2b80:	f1 f7       	brne	.-4      	; 0x2b7e <glcd_vclear+0x56>
   _delay_us(E_DELAY);
   CONTROLPORT &= ~EN;	//EN low
    2b82:	97 98       	cbi	0x12, 7	; 18
    2b84:	8f 2d       	mov	r24, r15
    2b86:	8a 95       	dec	r24
    2b88:	f1 f7       	brne	.-4      	; 0x2b86 <glcd_vclear+0x5e>
{       

   goto_col(i%128);            
   goto_row(i/128); 
   cnt=(int)(i/128);  
   if(color==1)  
    2b8a:	81 e0       	ldi	r24, 0x01	; 1
    2b8c:	e8 16       	cp	r14, r24
    2b8e:	21 f4       	brne	.+8      	; 0x2b98 <glcd_vclear+0x70>
    goto_row(y);
}  
//----------------------
void glcd_write(byte b)
{
	CONTROLPORT |= DI;	//DI high --> data
    2b90:	95 9a       	sbi	0x12, 5	; 18
	CONTROLPORT &= ~RW;	//RW low --> write
    2b92:	96 98       	cbi	0x12, 6	; 18
	DATAPORT = b;    	//put data on data port
    2b94:	a5 ba       	out	0x15, r10	; 21
    2b96:	03 c0       	rjmp	.+6      	; 0x2b9e <glcd_vclear+0x76>
    goto_row(y);
}  
//----------------------
void glcd_write(byte b)
{
	CONTROLPORT |= DI;	//DI high --> data
    2b98:	95 9a       	sbi	0x12, 5	; 18
	CONTROLPORT &= ~RW;	//RW low --> write
    2b9a:	96 98       	cbi	0x12, 6	; 18
	DATAPORT = b;    	//put data on data port
    2b9c:	15 ba       	out	0x15, r1	; 21
    2b9e:	8b 2d       	mov	r24, r11
    2ba0:	8a 95       	dec	r24
    2ba2:	f1 f7       	brne	.-4      	; 0x2ba0 <glcd_vclear+0x78>
//#define CS_ACTIVE_LOW   1   //Define this if your GLCD CS
                              //is active low 

void trigger()
{
	CONTROLPORT |= EN;	//EN high
    2ba4:	97 9a       	sbi	0x12, 7	; 18
    2ba6:	8f 2d       	mov	r24, r15
    2ba8:	8a 95       	dec	r24
    2baa:	f1 f7       	brne	.-4      	; 0x2ba8 <glcd_vclear+0x80>
   _delay_us(E_DELAY);
   CONTROLPORT &= ~EN;	//EN low
    2bac:	97 98       	cbi	0x12, 7	; 18
    2bae:	8f 2d       	mov	r24, r15
    2bb0:	8a 95       	dec	r24
    2bb2:	f1 f7       	brne	.-4      	; 0x2bb0 <glcd_vclear+0x88>
   cnt=(int)(i/128);  
   if(color==1)  
   glcd_write(0xff); 
   else 
   glcd_write(0x00); 
   if(cnt>cnt_prev)
    2bb4:	02 17       	cp	r16, r18
    2bb6:	13 07       	cpc	r17, r19
    2bb8:	14 f0       	brlt	.+4      	; 0x2bbe <glcd_vclear+0x96>
    2bba:	98 01       	movw	r18, r16
    2bbc:	07 c0       	rjmp	.+14     	; 0x2bcc <glcd_vclear+0xa4>
    2bbe:	80 ed       	ldi	r24, 0xD0	; 208
    2bc0:	97 e0       	ldi	r25, 0x07	; 7
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    2bc2:	f6 01       	movw	r30, r12
    2bc4:	31 97       	sbiw	r30, 0x01	; 1
    2bc6:	f1 f7       	brne	.-4      	; 0x2bc4 <glcd_vclear+0x9c>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2bc8:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2bca:	d9 f7       	brne	.-10     	; 0x2bc2 <glcd_vclear+0x9a>
void glcd_vclear(uint8_t color)
//clears screen with vertical wipe-in effect 
{
int i,cnt=0,cnt_prev=0;

for(i=0;i<1024;i++)
    2bcc:	21 96       	adiw	r28, 0x01	; 1
    2bce:	84 e0       	ldi	r24, 0x04	; 4
    2bd0:	c0 30       	cpi	r28, 0x00	; 0
    2bd2:	d8 07       	cpc	r29, r24
    2bd4:	11 f0       	breq	.+4      	; 0x2bda <glcd_vclear+0xb2>
    2bd6:	89 01       	movw	r16, r18
    2bd8:	c0 cf       	rjmp	.-128    	; 0x2b5a <glcd_vclear+0x32>
   else 
   glcd_write(0x00); 
   if(cnt>cnt_prev)
   {_delay_ms(200);cnt_prev=cnt;}                              
}   
}
    2bda:	df 91       	pop	r29
    2bdc:	cf 91       	pop	r28
    2bde:	1f 91       	pop	r17
    2be0:	0f 91       	pop	r16
    2be2:	ff 90       	pop	r15
    2be4:	ef 90       	pop	r14
    2be6:	df 90       	pop	r13
    2be8:	cf 90       	pop	r12
    2bea:	bf 90       	pop	r11
    2bec:	af 90       	pop	r10
    2bee:	08 95       	ret

00002bf0 <write_rf_setting>:
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
    2bf0:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
    2bf2:	b6 99       	sbic	0x16, 6	; 22
    2bf4:	fe cf       	rjmp	.-4      	; 0x2bf2 <write_rf_setting+0x2>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2bf6:	8b e0       	ldi	r24, 0x0B	; 11
    2bf8:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2bfa:	77 9b       	sbis	0x0e, 7	; 14
    2bfc:	fe cf       	rjmp	.-4      	; 0x2bfa <write_rf_setting+0xa>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2bfe:	86 e0       	ldi	r24, 0x06	; 6
    2c00:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2c02:	77 9b       	sbis	0x0e, 7	; 14
    2c04:	fe cf       	rjmp	.-4      	; 0x2c02 <write_rf_setting+0x12>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
    2c06:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
    2c08:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
    2c0a:	b6 99       	sbic	0x16, 6	; 22
    2c0c:	fe cf       	rjmp	.-4      	; 0x2c0a <write_rf_setting+0x1a>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2c0e:	8c e0       	ldi	r24, 0x0C	; 12
    2c10:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2c12:	77 9b       	sbis	0x0e, 7	; 14
    2c14:	fe cf       	rjmp	.-4      	; 0x2c12 <write_rf_setting+0x22>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2c16:	1f b8       	out	0x0f, r1	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2c18:	77 9b       	sbis	0x0e, 7	; 14
    2c1a:	fe cf       	rjmp	.-4      	; 0x2c18 <write_rf_setting+0x28>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
    2c1c:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
    2c1e:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
    2c20:	b6 99       	sbic	0x16, 6	; 22
    2c22:	fe cf       	rjmp	.-4      	; 0x2c20 <write_rf_setting+0x30>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2c24:	8d e0       	ldi	r24, 0x0D	; 13
    2c26:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2c28:	77 9b       	sbis	0x0e, 7	; 14
    2c2a:	fe cf       	rjmp	.-4      	; 0x2c28 <write_rf_setting+0x38>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2c2c:	8d e5       	ldi	r24, 0x5D	; 93
    2c2e:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2c30:	77 9b       	sbis	0x0e, 7	; 14
    2c32:	fe cf       	rjmp	.-4      	; 0x2c30 <write_rf_setting+0x40>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
    2c34:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
    2c36:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
    2c38:	b6 99       	sbic	0x16, 6	; 22
    2c3a:	fe cf       	rjmp	.-4      	; 0x2c38 <write_rf_setting+0x48>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2c3c:	8e e0       	ldi	r24, 0x0E	; 14
    2c3e:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2c40:	77 9b       	sbis	0x0e, 7	; 14
    2c42:	fe cf       	rjmp	.-4      	; 0x2c40 <write_rf_setting+0x50>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2c44:	83 e9       	ldi	r24, 0x93	; 147
    2c46:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2c48:	77 9b       	sbis	0x0e, 7	; 14
    2c4a:	fe cf       	rjmp	.-4      	; 0x2c48 <write_rf_setting+0x58>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
    2c4c:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
    2c4e:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
    2c50:	b6 99       	sbic	0x16, 6	; 22
    2c52:	fe cf       	rjmp	.-4      	; 0x2c50 <write_rf_setting+0x60>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2c54:	8f e0       	ldi	r24, 0x0F	; 15
    2c56:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2c58:	77 9b       	sbis	0x0e, 7	; 14
    2c5a:	fe cf       	rjmp	.-4      	; 0x2c58 <write_rf_setting+0x68>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2c5c:	81 eb       	ldi	r24, 0xB1	; 177
    2c5e:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2c60:	77 9b       	sbis	0x0e, 7	; 14
    2c62:	fe cf       	rjmp	.-4      	; 0x2c60 <write_rf_setting+0x70>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
    2c64:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
    2c66:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
    2c68:	b6 99       	sbic	0x16, 6	; 22
    2c6a:	fe cf       	rjmp	.-4      	; 0x2c68 <write_rf_setting+0x78>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2c6c:	80 e1       	ldi	r24, 0x10	; 16
    2c6e:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2c70:	77 9b       	sbis	0x0e, 7	; 14
    2c72:	fe cf       	rjmp	.-4      	; 0x2c70 <write_rf_setting+0x80>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2c74:	8d e2       	ldi	r24, 0x2D	; 45
    2c76:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2c78:	77 9b       	sbis	0x0e, 7	; 14
    2c7a:	fe cf       	rjmp	.-4      	; 0x2c78 <write_rf_setting+0x88>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
    2c7c:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
    2c7e:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
    2c80:	b6 99       	sbic	0x16, 6	; 22
    2c82:	fe cf       	rjmp	.-4      	; 0x2c80 <write_rf_setting+0x90>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2c84:	81 e1       	ldi	r24, 0x11	; 17
    2c86:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2c88:	77 9b       	sbis	0x0e, 7	; 14
    2c8a:	fe cf       	rjmp	.-4      	; 0x2c88 <write_rf_setting+0x98>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2c8c:	8b e3       	ldi	r24, 0x3B	; 59
    2c8e:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2c90:	77 9b       	sbis	0x0e, 7	; 14
    2c92:	fe cf       	rjmp	.-4      	; 0x2c90 <write_rf_setting+0xa0>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
    2c94:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
    2c96:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
    2c98:	b6 99       	sbic	0x16, 6	; 22
    2c9a:	fe cf       	rjmp	.-4      	; 0x2c98 <write_rf_setting+0xa8>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2c9c:	82 e1       	ldi	r24, 0x12	; 18
    2c9e:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2ca0:	77 9b       	sbis	0x0e, 7	; 14
    2ca2:	fe cf       	rjmp	.-4      	; 0x2ca0 <write_rf_setting+0xb0>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2ca4:	83 e7       	ldi	r24, 0x73	; 115
    2ca6:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2ca8:	77 9b       	sbis	0x0e, 7	; 14
    2caa:	fe cf       	rjmp	.-4      	; 0x2ca8 <write_rf_setting+0xb8>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
    2cac:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
    2cae:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
    2cb0:	b6 99       	sbic	0x16, 6	; 22
    2cb2:	fe cf       	rjmp	.-4      	; 0x2cb0 <write_rf_setting+0xc0>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2cb4:	83 e1       	ldi	r24, 0x13	; 19
    2cb6:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2cb8:	77 9b       	sbis	0x0e, 7	; 14
    2cba:	fe cf       	rjmp	.-4      	; 0x2cb8 <write_rf_setting+0xc8>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2cbc:	82 e2       	ldi	r24, 0x22	; 34
    2cbe:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2cc0:	77 9b       	sbis	0x0e, 7	; 14
    2cc2:	fe cf       	rjmp	.-4      	; 0x2cc0 <write_rf_setting+0xd0>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
    2cc4:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
    2cc6:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
    2cc8:	b6 99       	sbic	0x16, 6	; 22
    2cca:	fe cf       	rjmp	.-4      	; 0x2cc8 <write_rf_setting+0xd8>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2ccc:	84 e1       	ldi	r24, 0x14	; 20
    2cce:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2cd0:	77 9b       	sbis	0x0e, 7	; 14
    2cd2:	fe cf       	rjmp	.-4      	; 0x2cd0 <write_rf_setting+0xe0>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2cd4:	88 ef       	ldi	r24, 0xF8	; 248
    2cd6:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2cd8:	77 9b       	sbis	0x0e, 7	; 14
    2cda:	fe cf       	rjmp	.-4      	; 0x2cd8 <write_rf_setting+0xe8>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
    2cdc:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
    2cde:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
    2ce0:	b6 99       	sbic	0x16, 6	; 22
    2ce2:	fe cf       	rjmp	.-4      	; 0x2ce0 <write_rf_setting+0xf0>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2ce4:	8a e0       	ldi	r24, 0x0A	; 10
    2ce6:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2ce8:	77 9b       	sbis	0x0e, 7	; 14
    2cea:	fe cf       	rjmp	.-4      	; 0x2ce8 <write_rf_setting+0xf8>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2cec:	83 e0       	ldi	r24, 0x03	; 3
    2cee:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2cf0:	77 9b       	sbis	0x0e, 7	; 14
    2cf2:	fe cf       	rjmp	.-4      	; 0x2cf0 <write_rf_setting+0x100>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
    2cf4:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
    2cf6:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
    2cf8:	b6 99       	sbic	0x16, 6	; 22
    2cfa:	fe cf       	rjmp	.-4      	; 0x2cf8 <write_rf_setting+0x108>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2cfc:	85 e1       	ldi	r24, 0x15	; 21
    2cfe:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2d00:	77 9b       	sbis	0x0e, 7	; 14
    2d02:	fe cf       	rjmp	.-4      	; 0x2d00 <write_rf_setting+0x110>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2d04:	1f b8       	out	0x0f, r1	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2d06:	77 9b       	sbis	0x0e, 7	; 14
    2d08:	fe cf       	rjmp	.-4      	; 0x2d06 <write_rf_setting+0x116>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
    2d0a:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
    2d0c:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
    2d0e:	b6 99       	sbic	0x16, 6	; 22
    2d10:	fe cf       	rjmp	.-4      	; 0x2d0e <write_rf_setting+0x11e>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2d12:	81 e2       	ldi	r24, 0x21	; 33
    2d14:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2d16:	77 9b       	sbis	0x0e, 7	; 14
    2d18:	fe cf       	rjmp	.-4      	; 0x2d16 <write_rf_setting+0x126>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2d1a:	86 eb       	ldi	r24, 0xB6	; 182
    2d1c:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2d1e:	77 9b       	sbis	0x0e, 7	; 14
    2d20:	fe cf       	rjmp	.-4      	; 0x2d1e <write_rf_setting+0x12e>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
    2d22:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
    2d24:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
    2d26:	b6 99       	sbic	0x16, 6	; 22
    2d28:	fe cf       	rjmp	.-4      	; 0x2d26 <write_rf_setting+0x136>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2d2a:	82 e2       	ldi	r24, 0x22	; 34
    2d2c:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2d2e:	77 9b       	sbis	0x0e, 7	; 14
    2d30:	fe cf       	rjmp	.-4      	; 0x2d2e <write_rf_setting+0x13e>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2d32:	80 e1       	ldi	r24, 0x10	; 16
    2d34:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2d36:	77 9b       	sbis	0x0e, 7	; 14
    2d38:	fe cf       	rjmp	.-4      	; 0x2d36 <write_rf_setting+0x146>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
    2d3a:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
    2d3c:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
    2d3e:	b6 99       	sbic	0x16, 6	; 22
    2d40:	fe cf       	rjmp	.-4      	; 0x2d3e <write_rf_setting+0x14e>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2d42:	88 e1       	ldi	r24, 0x18	; 24
    2d44:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2d46:	77 9b       	sbis	0x0e, 7	; 14
    2d48:	fe cf       	rjmp	.-4      	; 0x2d46 <write_rf_setting+0x156>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2d4a:	88 e1       	ldi	r24, 0x18	; 24
    2d4c:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2d4e:	77 9b       	sbis	0x0e, 7	; 14
    2d50:	fe cf       	rjmp	.-4      	; 0x2d4e <write_rf_setting+0x15e>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
    2d52:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
    2d54:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
    2d56:	b6 99       	sbic	0x16, 6	; 22
    2d58:	fe cf       	rjmp	.-4      	; 0x2d56 <write_rf_setting+0x166>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2d5a:	89 e1       	ldi	r24, 0x19	; 25
    2d5c:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2d5e:	77 9b       	sbis	0x0e, 7	; 14
    2d60:	fe cf       	rjmp	.-4      	; 0x2d5e <write_rf_setting+0x16e>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2d62:	8d e1       	ldi	r24, 0x1D	; 29
    2d64:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2d66:	77 9b       	sbis	0x0e, 7	; 14
    2d68:	fe cf       	rjmp	.-4      	; 0x2d66 <write_rf_setting+0x176>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
    2d6a:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
    2d6c:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
    2d6e:	b6 99       	sbic	0x16, 6	; 22
    2d70:	fe cf       	rjmp	.-4      	; 0x2d6e <write_rf_setting+0x17e>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2d72:	8a e1       	ldi	r24, 0x1A	; 26
    2d74:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2d76:	77 9b       	sbis	0x0e, 7	; 14
    2d78:	fe cf       	rjmp	.-4      	; 0x2d76 <write_rf_setting+0x186>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2d7a:	8c e1       	ldi	r24, 0x1C	; 28
    2d7c:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2d7e:	77 9b       	sbis	0x0e, 7	; 14
    2d80:	fe cf       	rjmp	.-4      	; 0x2d7e <write_rf_setting+0x18e>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
    2d82:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
    2d84:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
    2d86:	b6 99       	sbic	0x16, 6	; 22
    2d88:	fe cf       	rjmp	.-4      	; 0x2d86 <write_rf_setting+0x196>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2d8a:	8b e1       	ldi	r24, 0x1B	; 27
    2d8c:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2d8e:	77 9b       	sbis	0x0e, 7	; 14
    2d90:	fe cf       	rjmp	.-4      	; 0x2d8e <write_rf_setting+0x19e>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2d92:	87 ec       	ldi	r24, 0xC7	; 199
    2d94:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2d96:	77 9b       	sbis	0x0e, 7	; 14
    2d98:	fe cf       	rjmp	.-4      	; 0x2d96 <write_rf_setting+0x1a6>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
    2d9a:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
    2d9c:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
    2d9e:	b6 99       	sbic	0x16, 6	; 22
    2da0:	fe cf       	rjmp	.-4      	; 0x2d9e <write_rf_setting+0x1ae>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2da2:	8c e1       	ldi	r24, 0x1C	; 28
    2da4:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2da6:	77 9b       	sbis	0x0e, 7	; 14
    2da8:	fe cf       	rjmp	.-4      	; 0x2da6 <write_rf_setting+0x1b6>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2daa:	1f b8       	out	0x0f, r1	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2dac:	77 9b       	sbis	0x0e, 7	; 14
    2dae:	fe cf       	rjmp	.-4      	; 0x2dac <write_rf_setting+0x1bc>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
    2db0:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
    2db2:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
    2db4:	b6 99       	sbic	0x16, 6	; 22
    2db6:	fe cf       	rjmp	.-4      	; 0x2db4 <write_rf_setting+0x1c4>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2db8:	8d e1       	ldi	r24, 0x1D	; 29
    2dba:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2dbc:	77 9b       	sbis	0x0e, 7	; 14
    2dbe:	fe cf       	rjmp	.-4      	; 0x2dbc <write_rf_setting+0x1cc>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2dc0:	82 eb       	ldi	r24, 0xB2	; 178
    2dc2:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2dc4:	77 9b       	sbis	0x0e, 7	; 14
    2dc6:	fe cf       	rjmp	.-4      	; 0x2dc4 <write_rf_setting+0x1d4>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
    2dc8:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
    2dca:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
    2dcc:	b6 99       	sbic	0x16, 6	; 22
    2dce:	fe cf       	rjmp	.-4      	; 0x2dcc <write_rf_setting+0x1dc>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2dd0:	83 e2       	ldi	r24, 0x23	; 35
    2dd2:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2dd4:	77 9b       	sbis	0x0e, 7	; 14
    2dd6:	fe cf       	rjmp	.-4      	; 0x2dd4 <write_rf_setting+0x1e4>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2dd8:	8a ee       	ldi	r24, 0xEA	; 234
    2dda:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2ddc:	77 9b       	sbis	0x0e, 7	; 14
    2dde:	fe cf       	rjmp	.-4      	; 0x2ddc <write_rf_setting+0x1ec>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
    2de0:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
    2de2:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
    2de4:	b6 99       	sbic	0x16, 6	; 22
    2de6:	fe cf       	rjmp	.-4      	; 0x2de4 <write_rf_setting+0x1f4>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2de8:	84 e2       	ldi	r24, 0x24	; 36
    2dea:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2dec:	77 9b       	sbis	0x0e, 7	; 14
    2dee:	fe cf       	rjmp	.-4      	; 0x2dec <write_rf_setting+0x1fc>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2df0:	8a e0       	ldi	r24, 0x0A	; 10
    2df2:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2df4:	77 9b       	sbis	0x0e, 7	; 14
    2df6:	fe cf       	rjmp	.-4      	; 0x2df4 <write_rf_setting+0x204>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
    2df8:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
    2dfa:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
    2dfc:	b6 99       	sbic	0x16, 6	; 22
    2dfe:	fe cf       	rjmp	.-4      	; 0x2dfc <write_rf_setting+0x20c>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2e00:	85 e2       	ldi	r24, 0x25	; 37
    2e02:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2e04:	77 9b       	sbis	0x0e, 7	; 14
    2e06:	fe cf       	rjmp	.-4      	; 0x2e04 <write_rf_setting+0x214>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2e08:	1f b8       	out	0x0f, r1	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2e0a:	77 9b       	sbis	0x0e, 7	; 14
    2e0c:	fe cf       	rjmp	.-4      	; 0x2e0a <write_rf_setting+0x21a>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
    2e0e:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
    2e10:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
    2e12:	b6 99       	sbic	0x16, 6	; 22
    2e14:	fe cf       	rjmp	.-4      	; 0x2e12 <write_rf_setting+0x222>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2e16:	86 e2       	ldi	r24, 0x26	; 38
    2e18:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2e1a:	77 9b       	sbis	0x0e, 7	; 14
    2e1c:	fe cf       	rjmp	.-4      	; 0x2e1a <write_rf_setting+0x22a>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2e1e:	81 e1       	ldi	r24, 0x11	; 17
    2e20:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2e22:	77 9b       	sbis	0x0e, 7	; 14
    2e24:	fe cf       	rjmp	.-4      	; 0x2e22 <write_rf_setting+0x232>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
    2e26:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
    2e28:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
    2e2a:	b6 99       	sbic	0x16, 6	; 22
    2e2c:	fe cf       	rjmp	.-4      	; 0x2e2a <write_rf_setting+0x23a>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2e2e:	89 e2       	ldi	r24, 0x29	; 41
    2e30:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2e32:	77 9b       	sbis	0x0e, 7	; 14
    2e34:	fe cf       	rjmp	.-4      	; 0x2e32 <write_rf_setting+0x242>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2e36:	89 e5       	ldi	r24, 0x59	; 89
    2e38:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2e3a:	77 9b       	sbis	0x0e, 7	; 14
    2e3c:	fe cf       	rjmp	.-4      	; 0x2e3a <write_rf_setting+0x24a>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
    2e3e:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
    2e40:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
    2e42:	b6 99       	sbic	0x16, 6	; 22
    2e44:	fe cf       	rjmp	.-4      	; 0x2e42 <write_rf_setting+0x252>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2e46:	8c e2       	ldi	r24, 0x2C	; 44
    2e48:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2e4a:	77 9b       	sbis	0x0e, 7	; 14
    2e4c:	fe cf       	rjmp	.-4      	; 0x2e4a <write_rf_setting+0x25a>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2e4e:	88 e8       	ldi	r24, 0x88	; 136
    2e50:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2e52:	77 9b       	sbis	0x0e, 7	; 14
    2e54:	fe cf       	rjmp	.-4      	; 0x2e52 <write_rf_setting+0x262>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
    2e56:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
    2e58:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
    2e5a:	b6 99       	sbic	0x16, 6	; 22
    2e5c:	fe cf       	rjmp	.-4      	; 0x2e5a <write_rf_setting+0x26a>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2e5e:	8d e2       	ldi	r24, 0x2D	; 45
    2e60:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2e62:	77 9b       	sbis	0x0e, 7	; 14
    2e64:	fe cf       	rjmp	.-4      	; 0x2e62 <write_rf_setting+0x272>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2e66:	81 e3       	ldi	r24, 0x31	; 49
    2e68:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2e6a:	77 9b       	sbis	0x0e, 7	; 14
    2e6c:	fe cf       	rjmp	.-4      	; 0x2e6a <write_rf_setting+0x27a>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
    2e6e:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
    2e70:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
    2e72:	b6 99       	sbic	0x16, 6	; 22
    2e74:	fe cf       	rjmp	.-4      	; 0x2e72 <write_rf_setting+0x282>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2e76:	8e e2       	ldi	r24, 0x2E	; 46
    2e78:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2e7a:	77 9b       	sbis	0x0e, 7	; 14
    2e7c:	fe cf       	rjmp	.-4      	; 0x2e7a <write_rf_setting+0x28a>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2e7e:	8b e0       	ldi	r24, 0x0B	; 11
    2e80:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2e82:	77 9b       	sbis	0x0e, 7	; 14
    2e84:	fe cf       	rjmp	.-4      	; 0x2e82 <write_rf_setting+0x292>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
    2e86:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
    2e88:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
    2e8a:	b6 99       	sbic	0x16, 6	; 22
    2e8c:	fe cf       	rjmp	.-4      	; 0x2e8a <write_rf_setting+0x29a>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2e8e:	83 e0       	ldi	r24, 0x03	; 3
    2e90:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2e92:	77 9b       	sbis	0x0e, 7	; 14
    2e94:	fe cf       	rjmp	.-4      	; 0x2e92 <write_rf_setting+0x2a2>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2e96:	87 e0       	ldi	r24, 0x07	; 7
    2e98:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2e9a:	77 9b       	sbis	0x0e, 7	; 14
    2e9c:	fe cf       	rjmp	.-4      	; 0x2e9a <write_rf_setting+0x2aa>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
    2e9e:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
    2ea0:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
    2ea2:	b6 99       	sbic	0x16, 6	; 22
    2ea4:	fe cf       	rjmp	.-4      	; 0x2ea2 <write_rf_setting+0x2b2>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2ea6:	1f b8       	out	0x0f, r1	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2ea8:	77 9b       	sbis	0x0e, 7	; 14
    2eaa:	fe cf       	rjmp	.-4      	; 0x2ea8 <write_rf_setting+0x2b8>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2eac:	86 e0       	ldi	r24, 0x06	; 6
    2eae:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2eb0:	77 9b       	sbis	0x0e, 7	; 14
    2eb2:	fe cf       	rjmp	.-4      	; 0x2eb0 <write_rf_setting+0x2c0>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
    2eb4:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
    2eb6:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
    2eb8:	b6 99       	sbic	0x16, 6	; 22
    2eba:	fe cf       	rjmp	.-4      	; 0x2eb8 <write_rf_setting+0x2c8>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2ebc:	82 e0       	ldi	r24, 0x02	; 2
    2ebe:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2ec0:	77 9b       	sbis	0x0e, 7	; 14
    2ec2:	fe cf       	rjmp	.-4      	; 0x2ec0 <write_rf_setting+0x2d0>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2ec4:	81 e0       	ldi	r24, 0x01	; 1
    2ec6:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2ec8:	77 9b       	sbis	0x0e, 7	; 14
    2eca:	fe cf       	rjmp	.-4      	; 0x2ec8 <write_rf_setting+0x2d8>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
    2ecc:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
    2ece:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
    2ed0:	b6 99       	sbic	0x16, 6	; 22
    2ed2:	fe cf       	rjmp	.-4      	; 0x2ed0 <write_rf_setting+0x2e0>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2ed4:	87 e0       	ldi	r24, 0x07	; 7
    2ed6:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2ed8:	77 9b       	sbis	0x0e, 7	; 14
    2eda:	fe cf       	rjmp	.-4      	; 0x2ed8 <write_rf_setting+0x2e8>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2edc:	84 e0       	ldi	r24, 0x04	; 4
    2ede:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2ee0:	77 9b       	sbis	0x0e, 7	; 14
    2ee2:	fe cf       	rjmp	.-4      	; 0x2ee0 <write_rf_setting+0x2f0>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
    2ee4:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
    2ee6:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
    2ee8:	b6 99       	sbic	0x16, 6	; 22
    2eea:	fe cf       	rjmp	.-4      	; 0x2ee8 <write_rf_setting+0x2f8>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2eec:	88 e0       	ldi	r24, 0x08	; 8
    2eee:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2ef0:	77 9b       	sbis	0x0e, 7	; 14
    2ef2:	fe cf       	rjmp	.-4      	; 0x2ef0 <write_rf_setting+0x300>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2ef4:	85 e0       	ldi	r24, 0x05	; 5
    2ef6:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2ef8:	77 9b       	sbis	0x0e, 7	; 14
    2efa:	fe cf       	rjmp	.-4      	; 0x2ef8 <write_rf_setting+0x308>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
    2efc:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
    2efe:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
    2f00:	b6 99       	sbic	0x16, 6	; 22
    2f02:	fe cf       	rjmp	.-4      	; 0x2f00 <write_rf_setting+0x310>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2f04:	89 e0       	ldi	r24, 0x09	; 9
    2f06:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2f08:	77 9b       	sbis	0x0e, 7	; 14
    2f0a:	fe cf       	rjmp	.-4      	; 0x2f08 <write_rf_setting+0x318>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2f0c:	1f b8       	out	0x0f, r1	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2f0e:	77 9b       	sbis	0x0e, 7	; 14
    2f10:	fe cf       	rjmp	.-4      	; 0x2f0e <write_rf_setting+0x31e>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
    2f12:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
    2f14:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
    2f16:	b6 99       	sbic	0x16, 6	; 22
    2f18:	fe cf       	rjmp	.-4      	; 0x2f16 <write_rf_setting+0x326>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2f1a:	86 e0       	ldi	r24, 0x06	; 6
    2f1c:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2f1e:	77 9b       	sbis	0x0e, 7	; 14
    2f20:	fe cf       	rjmp	.-4      	; 0x2f1e <write_rf_setting+0x32e>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2f22:	8f ef       	ldi	r24, 0xFF	; 255
    2f24:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2f26:	77 9b       	sbis	0x0e, 7	; 14
    2f28:	fe cf       	rjmp	.-4      	; 0x2f26 <write_rf_setting+0x336>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
    2f2a:	c3 9a       	sbi	0x18, 3	; 24
	 halRfWriteReg(PKTCTRL0   ,0x05);
	 halRfWriteReg(ADDR       ,0x00);
	 halRfWriteReg(PKTLEN     ,0xFF);


}
    2f2c:	08 95       	ret

00002f2e <set_channel>:


void set_channel(uint8_t ch)   //transmitter/receiver channel number
{
    2f2e:	98 2f       	mov	r25, r24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
    2f30:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
    2f32:	b6 99       	sbic	0x16, 6	; 22
    2f34:	fe cf       	rjmp	.-4      	; 0x2f32 <set_channel+0x4>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2f36:	8a e0       	ldi	r24, 0x0A	; 10
    2f38:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2f3a:	77 9b       	sbis	0x0e, 7	; 14
    2f3c:	fe cf       	rjmp	.-4      	; 0x2f3a <set_channel+0xc>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2f3e:	9f b9       	out	0x0f, r25	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2f40:	77 9b       	sbis	0x0e, 7	; 14
    2f42:	fe cf       	rjmp	.-4      	; 0x2f40 <set_channel+0x12>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
    2f44:	c3 9a       	sbi	0x18, 3	; 24


void set_channel(uint8_t ch)   //transmitter/receiver channel number
{
halRfWriteReg(CHANNR     , ch);
}
    2f46:	08 95       	ret

00002f48 <set_address>:


void set_address(uint8_t add)   //transmitter/receiver address
{
    2f48:	98 2f       	mov	r25, r24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
    2f4a:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
    2f4c:	b6 99       	sbic	0x16, 6	; 22
    2f4e:	fe cf       	rjmp	.-4      	; 0x2f4c <set_address+0x4>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2f50:	89 e0       	ldi	r24, 0x09	; 9
    2f52:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2f54:	77 9b       	sbis	0x0e, 7	; 14
    2f56:	fe cf       	rjmp	.-4      	; 0x2f54 <set_address+0xc>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2f58:	9f b9       	out	0x0f, r25	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2f5a:	77 9b       	sbis	0x0e, 7	; 14
    2f5c:	fe cf       	rjmp	.-4      	; 0x2f5a <set_address+0x12>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
    2f5e:	c3 9a       	sbi	0x18, 3	; 24


void set_address(uint8_t add)   //transmitter/receiver address
{
halRfWriteReg(ADDR     , add);
}
    2f60:	08 95       	ret

00002f62 <initTimer0>:
		
}

void initTimer0(){
	/* clkI/O/64 (From prescaler) */
	TCCR0 = (0<<CS02)|(1<<CS01)|(1<<CS00);
    2f62:	83 e0       	ldi	r24, 0x03	; 3
    2f64:	83 bf       	out	0x33, r24	; 51
	TIMSK = 0;
    2f66:	19 be       	out	0x39, r1	; 57
}
    2f68:	08 95       	ret

00002f6a <SPI_MasterInit>:


void SPI_MasterInit(void)
{
	/* Set MOSI and SCK output, all others input */
	sbi(SPI_DDR, DD_CS);	//cs
    2f6a:	bb 9a       	sbi	0x17, 3	; 23
	sbi(SPI_DDR, DD_SS);	//ss
    2f6c:	bc 9a       	sbi	0x17, 4	; 23
	sbi(SPI_DDR, DD_MOSI);	//mosi
    2f6e:	bd 9a       	sbi	0x17, 5	; 23
	cbi(SPI_DDR, DD_MISO);	//miso
    2f70:	be 98       	cbi	0x17, 6	; 23
	sbi(SPI_DDR, DD_SCK);	//sck
    2f72:	bf 9a       	sbi	0x17, 7	; 23
	
	/*	Enable SPI, Master, set clock rate 
		10 is fck/64	*/
	SPCR = (1<<SPE)|(1<<MSTR)|(0<<SPR1)|(0<<SPR0);	
    2f74:	80 e5       	ldi	r24, 0x50	; 80
    2f76:	8d b9       	out	0x0d, r24	; 13
	SPSR |= (0<<SPI2X);
    2f78:	8e b1       	in	r24, 0x0e	; 14
    2f7a:	8e b9       	out	0x0e, r24	; 14

}
    2f7c:	08 95       	ret

00002f7e <SPI_MasterTransmit>:
void SPI_MasterTransmit(char cData)
{
	cbi(SPI_PORT, DD_CS);
    2f7e:	c3 98       	cbi	0x18, 3	; 24

	/* Start transmission */
	SPDR = cData;
    2f80:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2f82:	77 9b       	sbis	0x0e, 7	; 14
    2f84:	fe cf       	rjmp	.-4      	; 0x2f82 <SPI_MasterTransmit+0x4>

	sbi(SPI_PORT, DD_CS);
    2f86:	c3 9a       	sbi	0x18, 3	; 24
}
    2f88:	08 95       	ret

00002f8a <SPI_SlaveInit>:

void SPI_SlaveInit(void)
{
	/* Set MISO output, all others input */
	cbi(SPI_DDR, DD_SS);	//ss
    2f8a:	bc 98       	cbi	0x17, 4	; 23
	cbi(SPI_DDR, DD_MOSI);	//mosi
    2f8c:	bd 98       	cbi	0x17, 5	; 23
	sbi(SPI_DDR, DD_MISO);	//miso
    2f8e:	be 9a       	sbi	0x17, 6	; 23
	cbi(SPI_DDR, DD_SCK);	//sck
    2f90:	bf 98       	cbi	0x17, 7	; 23
	
	/* Enable SPI */
	SPCR = (1<<SPE);
    2f92:	80 e4       	ldi	r24, 0x40	; 64
    2f94:	8d b9       	out	0x0d, r24	; 13
}
    2f96:	08 95       	ret

00002f98 <SPI_SlaveReceive>:
char SPI_SlaveReceive(void)
{
	/* Wait for reception complete */
	while(!(SPSR & (1<<SPIF)))
    2f98:	77 9b       	sbis	0x0e, 7	; 14
    2f9a:	fe cf       	rjmp	.-4      	; 0x2f98 <SPI_SlaveReceive>
	;
	/* Return data register */
	return SPDR;
    2f9c:	8f b1       	in	r24, 0x0f	; 15
}
    2f9e:	08 95       	ret

00002fa0 <SPI_write>:


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2fa0:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2fa2:	77 9b       	sbis	0x0e, 7	; 14
    2fa4:	fe cf       	rjmp	.-4      	; 0x2fa2 <SPI_write+0x2>
}
    2fa6:	08 95       	ret

00002fa8 <SPI_transfer_byte>:

BYTE SPI_transfer_byte(BYTE addr)
{
	SPDR = addr;
    2fa8:	8f b9       	out	0x0f, r24	; 15

	/* Wait for reception complete */
	while(!(SPSR & (1<<SPIF)));
    2faa:	77 9b       	sbis	0x0e, 7	; 14
    2fac:	fe cf       	rjmp	.-4      	; 0x2faa <SPI_transfer_byte+0x2>
	
	/* Return data register */
	return SPDR;
    2fae:	8f b1       	in	r24, 0x0f	; 15
}
    2fb0:	08 95       	ret

00002fb2 <SPI_read>:
//
//=======================================================================
BYTE SPI_read()
{
	//Wait for reception complete 
	while(!(SPSR & (1<<SPIF)));
    2fb2:	77 9b       	sbis	0x0e, 7	; 14
    2fb4:	fe cf       	rjmp	.-4      	; 0x2fb2 <SPI_read>
	
	// Return data register 
	return SPDR;
    2fb6:	8f b1       	in	r24, 0x0f	; 15
}
    2fb8:	08 95       	ret

00002fba <read_reg>:
//          Value of the accessed CC2500 register.
//-------------------------------------------------------------------------------------------------------
BYTE read_reg(BYTE addr) 
{
	unsigned char value;
	cbi(SPI_PORT, P_CSn);
    2fba:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
    2fbc:	b6 99       	sbic	0x16, 6	; 22
    2fbe:	fe cf       	rjmp	.-4      	; 0x2fbc <read_reg+0x2>
//	cbi(SPI_PORT, P_SCLK);
	addr|=READ_SINGLE;
    2fc0:	80 68       	ori	r24, 0x80	; 128


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2fc2:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2fc4:	77 9b       	sbis	0x0e, 7	; 14
    2fc6:	fe cf       	rjmp	.-4      	; 0x2fc4 <read_reg+0xa>
}

BYTE SPI_transfer_byte(BYTE addr)
{
	SPDR = addr;
    2fc8:	8f b9       	out	0x0f, r24	; 15

	/* Wait for reception complete */
	while(!(SPSR & (1<<SPIF)));
    2fca:	77 9b       	sbis	0x0e, 7	; 14
    2fcc:	fe cf       	rjmp	.-4      	; 0x2fca <read_reg+0x10>
	
	/* Return data register */
	return SPDR;
    2fce:	8f b1       	in	r24, 0x0f	; 15
//	cbi(SPI_PORT, P_SCLK);
	addr|=READ_SINGLE;
	SPI_write(addr);
	
	value = SPI_transfer_byte(addr);
	sbi(SPI_PORT, P_CSn);
    2fd0:	c3 9a       	sbi	0x18, 3	; 24
//	cbi(SPI_PORT, P_SCLK);
//	cbi(SPI_PORT, P_SI);
	return value;
}
    2fd2:	08 95       	ret

00002fd4 <read_status>:
//          Value of the accessed CC2500 status register.
//-------------------------------------------------------------------------------------------------------
BYTE read_status(BYTE addr) 
{
	unsigned char value;
	cbi(SPI_PORT, P_CSn);
    2fd4:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
    2fd6:	b6 99       	sbic	0x16, 6	; 22
    2fd8:	fe cf       	rjmp	.-4      	; 0x2fd6 <read_status+0x2>
//	cbi(SPI_PORT, P_SCLK);
	addr|=READ_BURST;
    2fda:	80 6c       	ori	r24, 0xC0	; 192


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2fdc:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2fde:	77 9b       	sbis	0x0e, 7	; 14
    2fe0:	fe cf       	rjmp	.-4      	; 0x2fde <read_status+0xa>
}

BYTE SPI_transfer_byte(BYTE addr)
{
	SPDR = addr;
    2fe2:	8f b9       	out	0x0f, r24	; 15

	/* Wait for reception complete */
	while(!(SPSR & (1<<SPIF)));
    2fe4:	77 9b       	sbis	0x0e, 7	; 14
    2fe6:	fe cf       	rjmp	.-4      	; 0x2fe4 <read_status+0x10>
	
	/* Return data register */
	return SPDR;
    2fe8:	8f b1       	in	r24, 0x0f	; 15
	addr|=READ_BURST;
	SPI_write(addr);

	value = SPI_transfer_byte(addr);

	sbi(SPI_PORT, P_CSn);
    2fea:	c3 9a       	sbi	0x18, 3	; 24
//	cbi(SPI_PORT, P_SCLK);
//	cbi(SPI_PORT, P_SI);
	return value;
}// read_status
    2fec:	08 95       	ret

00002fee <halRfWriteReg>:
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
    2fee:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
    2ff0:	b6 99       	sbic	0x16, 6	; 22
    2ff2:	fe cf       	rjmp	.-4      	; 0x2ff0 <halRfWriteReg+0x2>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
    2ff4:	8f 77       	andi	r24, 0x7F	; 127


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2ff6:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2ff8:	77 9b       	sbis	0x0e, 7	; 14
    2ffa:	fe cf       	rjmp	.-4      	; 0x2ff8 <halRfWriteReg+0xa>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    2ffc:	6f b9       	out	0x0f, r22	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    2ffe:	77 9b       	sbis	0x0e, 7	; 14
    3000:	fe cf       	rjmp	.-4      	; 0x2ffe <halRfWriteReg+0x10>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
    3002:	c3 9a       	sbi	0x18, 3	; 24

}// halRfWriteReg
    3004:	08 95       	ret

00003006 <read_burst_reg>:
//          Number of bytes to be written to the subsequent CC2500 registers.
//-------------------------------------------------------------------------------------------------------
void read_burst_reg(BYTE addr, BYTE *buffer, BYTE count) 
{
	unsigned char j,value;
	cbi(SPI_PORT, P_CSn);
    3006:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
    3008:	b6 99       	sbic	0x16, 6	; 22
    300a:	fe cf       	rjmp	.-4      	; 0x3008 <read_burst_reg+0x2>
 //	cbi(SPI_PORT, P_SCLK);
	addr|=READ_BURST;
    300c:	58 2f       	mov	r21, r24
    300e:	50 6c       	ori	r21, 0xC0	; 192


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    3010:	5f b9       	out	0x0f, r21	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    3012:	77 9b       	sbis	0x0e, 7	; 14
    3014:	fe cf       	rjmp	.-4      	; 0x3012 <read_burst_reg+0xc>
    3016:	fb 01       	movw	r30, r22
    3018:	90 e0       	ldi	r25, 0x00	; 0
    301a:	06 c0       	rjmp	.+12     	; 0x3028 <read_burst_reg+0x22>
}

BYTE SPI_transfer_byte(BYTE addr)
{
	SPDR = addr;
    301c:	5f b9       	out	0x0f, r21	; 15

	/* Wait for reception complete */
	while(!(SPSR & (1<<SPIF)));
    301e:	77 9b       	sbis	0x0e, 7	; 14
    3020:	fe cf       	rjmp	.-4      	; 0x301e <read_burst_reg+0x18>
	
	/* Return data register */
	return SPDR;
    3022:	8f b1       	in	r24, 0x0f	; 15
	addr|=READ_BURST;
	SPI_write(addr);
	for(j=0;j<count;j++) 
	{
	  value = SPI_transfer_byte(addr);
	  buffer[j]=value;
    3024:	81 93       	st	Z+, r24
	cbi(SPI_PORT, P_CSn);
	while(bit_is_set(PINB, P_SO));
 //	cbi(SPI_PORT, P_SCLK);
	addr|=READ_BURST;
	SPI_write(addr);
	for(j=0;j<count;j++) 
    3026:	9f 5f       	subi	r25, 0xFF	; 255
    3028:	94 17       	cp	r25, r20
    302a:	c0 f3       	brcs	.-16     	; 0x301c <read_burst_reg+0x16>
	{
	  value = SPI_transfer_byte(addr);
	  buffer[j]=value;
	}
	sbi(SPI_PORT, P_CSn);
    302c:	c3 9a       	sbi	0x18, 3	; 24
}// read_burst_reg
    302e:	08 95       	ret

00003030 <write_burst_reg>:
//          Number of bytes to be written to the subsequent CC2500 registers.   
//-------------------------------------------------------------------------------------------------------
void write_burst_reg(BYTE addr, BYTE *buffer, BYTE count)
{
	unsigned char i,j,value;
	cbi(SPI_PORT, P_CSn);
    3030:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
    3032:	b6 99       	sbic	0x16, 6	; 22
    3034:	fe cf       	rjmp	.-4      	; 0x3032 <write_burst_reg+0x2>
	addr|=WRITE_BURST;
    3036:	80 64       	ori	r24, 0x40	; 64


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    3038:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    303a:	77 9b       	sbis	0x0e, 7	; 14
    303c:	fe cf       	rjmp	.-4      	; 0x303a <write_burst_reg+0xa>
    303e:	fb 01       	movw	r30, r22
    3040:	90 e0       	ldi	r25, 0x00	; 0
    3042:	06 c0       	rjmp	.+12     	; 0x3050 <write_burst_reg+0x20>
	cbi(SPI_PORT, P_CSn);
	while(bit_is_set(PINB, P_SO));
	addr|=WRITE_BURST;
	SPI_write(addr);
	for(j=0;j<count;j++) {
	  value=buffer[j];
    3044:	80 81       	ld	r24, Z


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    3046:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    3048:	77 9b       	sbis	0x0e, 7	; 14
    304a:	fe cf       	rjmp	.-4      	; 0x3048 <write_burst_reg+0x18>
	unsigned char i,j,value;
	cbi(SPI_PORT, P_CSn);
	while(bit_is_set(PINB, P_SO));
	addr|=WRITE_BURST;
	SPI_write(addr);
	for(j=0;j<count;j++) {
    304c:	9f 5f       	subi	r25, 0xFF	; 255
    304e:	31 96       	adiw	r30, 0x01	; 1
    3050:	94 17       	cp	r25, r20
    3052:	c0 f3       	brcs	.-16     	; 0x3044 <write_burst_reg+0x14>
	  value=buffer[j];
	  SPI_write(value);
	  for(i=0;i<10;i++);
	}
	sbi(SPI_PORT, P_CSn);
    3054:	c3 9a       	sbi	0x18, 3	; 24
}// write_burst_reg
    3056:	08 95       	ret

00003058 <strobe>:
//      BYTE strobe
//          Strobe command
//-------------------------------------------------------------------------------------------------------
void strobe(BYTE strobe) 
{
	cbi(SPI_PORT, P_CSn);
    3058:	c3 98       	cbi	0x18, 3	; 24
	
	while(bit_is_set(PINB, P_SO));
    305a:	b6 99       	sbic	0x16, 6	; 22
    305c:	fe cf       	rjmp	.-4      	; 0x305a <strobe+0x2>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    305e:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    3060:	77 9b       	sbis	0x0e, 7	; 14
    3062:	fe cf       	rjmp	.-4      	; 0x3060 <strobe+0x8>
{
	cbi(SPI_PORT, P_CSn);
	
	while(bit_is_set(PINB, P_SO));
	SPI_write(strobe);
	sbi(SPI_PORT, P_CSn);
    3064:	c3 9a       	sbi	0x18, 3	; 24

}// strobe
    3066:	08 95       	ret

00003068 <send_pkt>:
//      UINT8 size
//          The size of the txBuffer
//-------------------------------------------------------------------------------------------------------

void send_pkt(BYTE *txBuffer, UINT8 size) 
{
    3068:	0f 93       	push	r16
    306a:	1f 93       	push	r17
    306c:	9c 01       	movw	r18, r24
    306e:	46 2f       	mov	r20, r22
//      BYTE strobe
//          Strobe command
//-------------------------------------------------------------------------------------------------------
void strobe(BYTE strobe) 
{
	cbi(SPI_PORT, P_CSn);
    3070:	c3 98       	cbi	0x18, 3	; 24
	
	while(bit_is_set(PINB, P_SO));
    3072:	b6 99       	sbic	0x16, 6	; 22
    3074:	fe cf       	rjmp	.-4      	; 0x3072 <send_pkt+0xa>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    3076:	8b e3       	ldi	r24, 0x3B	; 59
    3078:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    307a:	77 9b       	sbis	0x0e, 7	; 14
    307c:	fe cf       	rjmp	.-4      	; 0x307a <send_pkt+0x12>
{
	cbi(SPI_PORT, P_CSn);
	
	while(bit_is_set(PINB, P_SO));
	SPI_write(strobe);
	sbi(SPI_PORT, P_CSn);
    307e:	c3 9a       	sbi	0x18, 3	; 24
    3080:	00 e4       	ldi	r16, 0x40	; 64
    3082:	1c e9       	ldi	r17, 0x9C	; 156
    3084:	f8 01       	movw	r30, r16
    3086:	31 97       	sbiw	r30, 0x01	; 1
    3088:	f1 f7       	brne	.-4      	; 0x3086 <send_pkt+0x1e>

void send_pkt(BYTE *txBuffer, UINT8 size) 
{
	strobe(SFTX);
	_delay_ms(10);
	write_burst_reg(TXFIFO, txBuffer, size);
    308a:	8f e3       	ldi	r24, 0x3F	; 63
    308c:	b9 01       	movw	r22, r18
    308e:	0e 94 18 18 	call	0x3030	; 0x3030 <write_burst_reg>
    3092:	c8 01       	movw	r24, r16
    3094:	01 97       	sbiw	r24, 0x01	; 1
    3096:	f1 f7       	brne	.-4      	; 0x3094 <send_pkt+0x2c>
//      BYTE strobe
//          Strobe command
//-------------------------------------------------------------------------------------------------------
void strobe(BYTE strobe) 
{
	cbi(SPI_PORT, P_CSn);
    3098:	c3 98       	cbi	0x18, 3	; 24
	
	while(bit_is_set(PINB, P_SO));
    309a:	b6 99       	sbic	0x16, 6	; 22
    309c:	fe cf       	rjmp	.-4      	; 0x309a <send_pkt+0x32>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    309e:	85 e3       	ldi	r24, 0x35	; 53
    30a0:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    30a2:	77 9b       	sbis	0x0e, 7	; 14
    30a4:	fe cf       	rjmp	.-4      	; 0x30a2 <send_pkt+0x3a>
{
	cbi(SPI_PORT, P_CSn);
	
	while(bit_is_set(PINB, P_SO));
	SPI_write(strobe);
	sbi(SPI_PORT, P_CSn);
    30a6:	c3 9a       	sbi	0x18, 3	; 24
    30a8:	80 e4       	ldi	r24, 0x40	; 64
    30aa:	9c e9       	ldi	r25, 0x9C	; 156
    30ac:	01 97       	sbiw	r24, 0x01	; 1
    30ae:	f1 f7       	brne	.-4      	; 0x30ac <send_pkt+0x44>
	write_burst_reg(TXFIFO, txBuffer, size);
	_delay_ms(10);
	strobe(STX);
	_delay_ms(10);

	TCNT0=0;
    30b0:	12 be       	out	0x32, r1	; 50
    30b2:	03 c0       	rjmp	.+6      	; 0x30ba <send_pkt+0x52>
	while((read_status(TXBYTES)&0x7F)!=0x00)	
	{
		
		if(TCNT0 == 255){ return; }
    30b4:	82 b7       	in	r24, 0x32	; 50
    30b6:	8f 3f       	cpi	r24, 0xFF	; 255
    30b8:	41 f0       	breq	.+16     	; 0x30ca <send_pkt+0x62>
	_delay_ms(10);
	strobe(STX);
	_delay_ms(10);

	TCNT0=0;
	while((read_status(TXBYTES)&0x7F)!=0x00)	
    30ba:	8a e3       	ldi	r24, 0x3A	; 58
    30bc:	0e 94 ea 17 	call	0x2fd4	; 0x2fd4 <read_status>
    30c0:	90 e0       	ldi	r25, 0x00	; 0
    30c2:	8f 77       	andi	r24, 0x7F	; 127
    30c4:	90 70       	andi	r25, 0x00	; 0
    30c6:	89 2b       	or	r24, r25
    30c8:	a9 f7       	brne	.-22     	; 0x30b4 <send_pkt+0x4c>
		if(TCNT0 == 255){ return; }
			
	}

	return ;
}// send_pkt*/
    30ca:	1f 91       	pop	r17
    30cc:	0f 91       	pop	r16
    30ce:	08 95       	ret

000030d0 <data_tx>:
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
    30d0:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
    30d2:	b6 99       	sbic	0x16, 6	; 22
    30d4:	fe cf       	rjmp	.-4      	; 0x30d2 <data_tx+0x2>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    30d6:	8e e3       	ldi	r24, 0x3E	; 62
    30d8:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    30da:	77 9b       	sbis	0x0e, 7	; 14
    30dc:	fe cf       	rjmp	.-4      	; 0x30da <data_tx+0xa>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    30de:	8f ef       	ldi	r24, 0xFF	; 255
    30e0:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    30e2:	77 9b       	sbis	0x0e, 7	; 14
    30e4:	fe cf       	rjmp	.-4      	; 0x30e2 <data_tx+0x12>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
    30e6:	c3 9a       	sbi	0x18, 3	; 24
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
    30e8:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
    30ea:	b6 99       	sbic	0x16, 6	; 22
    30ec:	fe cf       	rjmp	.-4      	; 0x30ea <data_tx+0x1a>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    30ee:	82 e2       	ldi	r24, 0x22	; 34
    30f0:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    30f2:	77 9b       	sbis	0x0e, 7	; 14
    30f4:	fe cf       	rjmp	.-4      	; 0x30f2 <data_tx+0x22>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    30f6:	80 e1       	ldi	r24, 0x10	; 16
    30f8:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    30fa:	77 9b       	sbis	0x0e, 7	; 14
    30fc:	fe cf       	rjmp	.-4      	; 0x30fa <data_tx+0x2a>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
    30fe:	c3 9a       	sbi	0x18, 3	; 24
    3100:	8a ef       	ldi	r24, 0xFA	; 250
    3102:	90 e0       	ldi	r25, 0x00	; 0
    3104:	20 e9       	ldi	r18, 0x90	; 144
    3106:	31 e0       	ldi	r19, 0x01	; 1
    3108:	f9 01       	movw	r30, r18
    310a:	31 97       	sbiw	r30, 0x01	; 1
    310c:	f1 f7       	brne	.-4      	; 0x310a <data_tx+0x3a>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    310e:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3110:	d9 f7       	brne	.-10     	; 0x3108 <data_tx+0x38>
{   
        halRfWriteReg(PATABLE,0xFF);
	halRfWriteReg(FREND0, 0x10);
	_delay_ms(25);	

    txBuffer[0]= pkt_len; //packet length
    3112:	85 e0       	ldi	r24, 0x05	; 5
    3114:	80 93 c5 04 	sts	0x04C5, r24

   	send_pkt(txBuffer, sizeof(txBuffer));
    3118:	85 ec       	ldi	r24, 0xC5	; 197
    311a:	94 e0       	ldi	r25, 0x04	; 4
    311c:	66 e0       	ldi	r22, 0x06	; 6
    311e:	0e 94 34 18 	call	0x3068	; 0x3068 <send_pkt>
//	_delay_ms(25);	
}
    3122:	08 95       	ret

00003124 <receive_pkt>:
//      BOOL
//          TRUE:   CRC OK
//          FALSE:  CRC NOT OK
//-------------------------------------------------------------------------------------------------------
BYTE receive_pkt(BYTE *rxBuffer, UINT8 length) 
{
    3124:	1f 93       	push	r17
    3126:	cf 93       	push	r28
    3128:	df 93       	push	r29
    312a:	ec 01       	movw	r28, r24
    312c:	16 2f       	mov	r17, r22
    BYTE status=0;
    UINT8 packetLength;
	status = read_status(RXBYTES);
    312e:	8b e3       	ldi	r24, 0x3B	; 59
    3130:	0e 94 ea 17 	call	0x2fd4	; 0x2fd4 <read_status>
	
	if((status & 0x7F)==0x00) 
    3134:	90 e0       	ldi	r25, 0x00	; 0
    3136:	8f 77       	andi	r24, 0x7F	; 127
    3138:	90 70       	andi	r25, 0x00	; 0
    313a:	89 2b       	or	r24, r25
    313c:	69 f4       	brne	.+26     	; 0x3158 <receive_pkt+0x34>
	{
		
		if(read_status(MARCSTATE)!=0x0D) strobe(SRX);
    313e:	85 e3       	ldi	r24, 0x35	; 53
    3140:	0e 94 ea 17 	call	0x2fd4	; 0x2fd4 <read_status>
    3144:	8d 30       	cpi	r24, 0x0D	; 13
    3146:	b9 f1       	breq	.+110    	; 0x31b6 <receive_pkt+0x92>
//      BYTE strobe
//          Strobe command
//-------------------------------------------------------------------------------------------------------
void strobe(BYTE strobe) 
{
	cbi(SPI_PORT, P_CSn);
    3148:	c3 98       	cbi	0x18, 3	; 24
	
	while(bit_is_set(PINB, P_SO));
    314a:	b6 99       	sbic	0x16, 6	; 22
    314c:	fe cf       	rjmp	.-4      	; 0x314a <receive_pkt+0x26>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    314e:	84 e3       	ldi	r24, 0x34	; 52
    3150:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    3152:	77 9b       	sbis	0x0e, 7	; 14
    3154:	fe cf       	rjmp	.-4      	; 0x3152 <receive_pkt+0x2e>
    3156:	2e c0       	rjmp	.+92     	; 0x31b4 <receive_pkt+0x90>
		
		if(read_status(MARCSTATE)!=0x0D) strobe(SRX);
		return 0;
	}
	
	TCNT0=0;
    3158:	12 be       	out	0x32, r1	; 50
    315a:	0b c0       	rjmp	.+22     	; 0x3172 <receive_pkt+0x4e>
	while((read_status(MARCSTATE)&0x1f)!=0x01) 
	{
		
		if(TCNT0 == 255)
    315c:	82 b7       	in	r24, 0x32	; 50
    315e:	8f 3f       	cpi	r24, 0xFF	; 255
    3160:	41 f4       	brne	.+16     	; 0x3172 <receive_pkt+0x4e>
//      BYTE strobe
//          Strobe command
//-------------------------------------------------------------------------------------------------------
void strobe(BYTE strobe) 
{
	cbi(SPI_PORT, P_CSn);
    3162:	c3 98       	cbi	0x18, 3	; 24
	
	while(bit_is_set(PINB, P_SO));
    3164:	b6 99       	sbic	0x16, 6	; 22
    3166:	fe cf       	rjmp	.-4      	; 0x3164 <receive_pkt+0x40>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    3168:	8a e3       	ldi	r24, 0x3A	; 58
    316a:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    316c:	77 9b       	sbis	0x0e, 7	; 14
    316e:	fe cf       	rjmp	.-4      	; 0x316c <receive_pkt+0x48>
    3170:	21 c0       	rjmp	.+66     	; 0x31b4 <receive_pkt+0x90>
		if(read_status(MARCSTATE)!=0x0D) strobe(SRX);
		return 0;
	}
	
	TCNT0=0;
	while((read_status(MARCSTATE)&0x1f)!=0x01) 
    3172:	85 e3       	ldi	r24, 0x35	; 53
    3174:	0e 94 ea 17 	call	0x2fd4	; 0x2fd4 <read_status>
    3178:	8f 71       	andi	r24, 0x1F	; 31
    317a:	81 30       	cpi	r24, 0x01	; 1
    317c:	79 f7       	brne	.-34     	; 0x315c <receive_pkt+0x38>
			strobe(SFRX);
			return 0;
		}

	}
   packetLength = read_reg(RXFIFO);
    317e:	8f e3       	ldi	r24, 0x3F	; 63
    3180:	0e 94 dd 17 	call	0x2fba	; 0x2fba <read_reg>
    
    if (packetLength == length) {
    3184:	81 17       	cp	r24, r17
    3186:	79 f4       	brne	.+30     	; 0x31a6 <receive_pkt+0x82>
		read_burst_reg(RXFIFO, rxBuffer, packetLength); 
    3188:	8f e3       	ldi	r24, 0x3F	; 63
    318a:	be 01       	movw	r22, r28
    318c:	41 2f       	mov	r20, r17
    318e:	0e 94 03 18 	call	0x3006	; 0x3006 <read_burst_reg>
//      BYTE strobe
//          Strobe command
//-------------------------------------------------------------------------------------------------------
void strobe(BYTE strobe) 
{
	cbi(SPI_PORT, P_CSn);
    3192:	c3 98       	cbi	0x18, 3	; 24
	
	while(bit_is_set(PINB, P_SO));
    3194:	b6 99       	sbic	0x16, 6	; 22
    3196:	fe cf       	rjmp	.-4      	; 0x3194 <receive_pkt+0x70>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    3198:	8a e3       	ldi	r24, 0x3A	; 58
    319a:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    319c:	77 9b       	sbis	0x0e, 7	; 14
    319e:	fe cf       	rjmp	.-4      	; 0x319c <receive_pkt+0x78>
{
	cbi(SPI_PORT, P_CSn);
	
	while(bit_is_set(PINB, P_SO));
	SPI_write(strobe);
	sbi(SPI_PORT, P_CSn);
    31a0:	c3 9a       	sbi	0x18, 3	; 24
    31a2:	81 e0       	ldi	r24, 0x01	; 1
    31a4:	09 c0       	rjmp	.+18     	; 0x31b8 <receive_pkt+0x94>
//      BYTE strobe
//          Strobe command
//-------------------------------------------------------------------------------------------------------
void strobe(BYTE strobe) 
{
	cbi(SPI_PORT, P_CSn);
    31a6:	c3 98       	cbi	0x18, 3	; 24
	
	while(bit_is_set(PINB, P_SO));
    31a8:	b6 99       	sbic	0x16, 6	; 22
    31aa:	fe cf       	rjmp	.-4      	; 0x31a8 <receive_pkt+0x84>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    31ac:	8a e3       	ldi	r24, 0x3A	; 58
    31ae:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    31b0:	77 9b       	sbis	0x0e, 7	; 14
    31b2:	fe cf       	rjmp	.-4      	; 0x31b0 <receive_pkt+0x8c>
{
	cbi(SPI_PORT, P_CSn);
	
	while(bit_is_set(PINB, P_SO));
	SPI_write(strobe);
	sbi(SPI_PORT, P_CSn);
    31b4:	c3 9a       	sbi	0x18, 3	; 24
    31b6:	80 e0       	ldi	r24, 0x00	; 0
        return 1;//(status & CRC_OK);
    } else {
		strobe(SFRX);
       return 0;
    }  
}// receive_pkt
    31b8:	df 91       	pop	r29
    31ba:	cf 91       	pop	r28
    31bc:	1f 91       	pop	r17
    31be:	08 95       	ret

000031c0 <data_rx>:

unsigned char data_rx(void)
{	
	//unsigned char	length;
	//length = sizeof(rxBuffer);
    if (receive_pkt(rxBuffer, pkt_len))	
    31c0:	8e eb       	ldi	r24, 0xBE	; 190
    31c2:	94 e0       	ldi	r25, 0x04	; 4
    31c4:	65 e0       	ldi	r22, 0x05	; 5
    31c6:	0e 94 92 18 	call	0x3124	; 0x3124 <receive_pkt>
    31ca:	81 11       	cpse	r24, r1
    31cc:	81 e0       	ldi	r24, 0x01	; 1
		return 1;
	else
		return 0;
		
}
    31ce:	08 95       	ret

000031d0 <POWER_UP_RESET_CC2500>:
//      BYTE strobe
//          Strobe command
//-------------------------------------------------------------------------------------------------------
void strobe(BYTE strobe) 
{
	cbi(SPI_PORT, P_CSn);
    31d0:	c3 98       	cbi	0x18, 3	; 24
	
	while(bit_is_set(PINB, P_SO));
    31d2:	b6 99       	sbic	0x16, 6	; 22
    31d4:	fe cf       	rjmp	.-4      	; 0x31d2 <POWER_UP_RESET_CC2500+0x2>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    31d6:	86 e3       	ldi	r24, 0x36	; 54
    31d8:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    31da:	77 9b       	sbis	0x0e, 7	; 14
    31dc:	fe cf       	rjmp	.-4      	; 0x31da <POWER_UP_RESET_CC2500+0xa>
{
	cbi(SPI_PORT, P_CSn);
	
	while(bit_is_set(PINB, P_SO));
	SPI_write(strobe);
	sbi(SPI_PORT, P_CSn);
    31de:	c3 9a       	sbi	0x18, 3	; 24
//
//------------------------------------------------------------
void POWER_UP_RESET_CC2500() {
	
	strobe(SIDLE);
	sbi(SPI_PORT, P_CSn);
    31e0:	c3 9a       	sbi	0x18, 3	; 24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    31e2:	8a e1       	ldi	r24, 0x1A	; 26
    31e4:	8a 95       	dec	r24
    31e6:	f1 f7       	brne	.-4      	; 0x31e4 <POWER_UP_RESET_CC2500+0x14>
	_delay_us(5);
	cbi(SPI_PORT, P_CSn);
    31e8:	c3 98       	cbi	0x18, 3	; 24
    31ea:	85 e3       	ldi	r24, 0x35	; 53
    31ec:	8a 95       	dec	r24
    31ee:	f1 f7       	brne	.-4      	; 0x31ec <POWER_UP_RESET_CC2500+0x1c>
	_delay_us(10);  	 
	sbi(SPI_PORT, P_CSn);
    31f0:	c3 9a       	sbi	0x18, 3	; 24
    31f2:	85 ed       	ldi	r24, 0xD5	; 213
    31f4:	8a 95       	dec	r24
    31f6:	f1 f7       	brne	.-4      	; 0x31f4 <POWER_UP_RESET_CC2500+0x24>
	_delay_us(40);
	cbi(SPI_PORT, P_CSn);
    31f8:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
    31fa:	b6 99       	sbic	0x16, 6	; 22
    31fc:	fe cf       	rjmp	.-4      	; 0x31fa <POWER_UP_RESET_CC2500+0x2a>
//      BYTE strobe
//          Strobe command
//-------------------------------------------------------------------------------------------------------
void strobe(BYTE strobe) 
{
	cbi(SPI_PORT, P_CSn);
    31fe:	c3 98       	cbi	0x18, 3	; 24
	
	while(bit_is_set(PINB, P_SO));
    3200:	b6 99       	sbic	0x16, 6	; 22
    3202:	fe cf       	rjmp	.-4      	; 0x3200 <POWER_UP_RESET_CC2500+0x30>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    3204:	80 e3       	ldi	r24, 0x30	; 48
    3206:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    3208:	77 9b       	sbis	0x0e, 7	; 14
    320a:	fe cf       	rjmp	.-4      	; 0x3208 <POWER_UP_RESET_CC2500+0x38>
{
	cbi(SPI_PORT, P_CSn);
	
	while(bit_is_set(PINB, P_SO));
	SPI_write(strobe);
	sbi(SPI_PORT, P_CSn);
    320c:	c3 9a       	sbi	0x18, 3	; 24
	sbi(SPI_PORT, P_CSn);
	_delay_us(40);
	cbi(SPI_PORT, P_CSn);
	while(bit_is_set(PINB, P_SO));
	strobe(SRES);
	sbi(SPI_PORT, P_CSn);
    320e:	c3 9a       	sbi	0x18, 3	; 24
//	cbi(SPI_PORT, P_SCLK);
//	cbi(SPI_PORT, P_SI);
}
    3210:	08 95       	ret

00003212 <cc2500_init>:
		
}

void initTimer0(){
	/* clkI/O/64 (From prescaler) */
	TCCR0 = (0<<CS02)|(1<<CS01)|(1<<CS00);
    3212:	83 e0       	ldi	r24, 0x03	; 3
    3214:	83 bf       	out	0x33, r24	; 51
	TIMSK = 0;
    3216:	19 be       	out	0x39, r1	; 57


void SPI_MasterInit(void)
{
	/* Set MOSI and SCK output, all others input */
	sbi(SPI_DDR, DD_CS);	//cs
    3218:	bb 9a       	sbi	0x17, 3	; 23
	sbi(SPI_DDR, DD_SS);	//ss
    321a:	bc 9a       	sbi	0x17, 4	; 23
	sbi(SPI_DDR, DD_MOSI);	//mosi
    321c:	bd 9a       	sbi	0x17, 5	; 23
	cbi(SPI_DDR, DD_MISO);	//miso
    321e:	be 98       	cbi	0x17, 6	; 23
	sbi(SPI_DDR, DD_SCK);	//sck
    3220:	bf 9a       	sbi	0x17, 7	; 23
	
	/*	Enable SPI, Master, set clock rate 
		10 is fck/64	*/
	SPCR = (1<<SPE)|(1<<MSTR)|(0<<SPR1)|(0<<SPR0);	
    3222:	80 e5       	ldi	r24, 0x50	; 80
    3224:	8d b9       	out	0x0d, r24	; 13
	SPSR |= (0<<SPI2X);
    3226:	8e b1       	in	r24, 0x0e	; 14
    3228:	8e b9       	out	0x0e, r24	; 14

void cc2500_init()   // initialize the CC2500 chip and SPI
{
        initTimer0();
        SPI_MasterInit();	
	POWER_UP_RESET_CC2500();
    322a:	0e 94 e8 18 	call	0x31d0	; 0x31d0 <POWER_UP_RESET_CC2500>
	write_rf_setting();
    322e:	0e 94 f8 15 	call	0x2bf0	; 0x2bf0 <write_rf_setting>
//      BYTE value
//          Value to be written to the specified CC2500 register.
//-------------------------------------------------------------------------------------------------------
void halRfWriteReg(BYTE addr, BYTE value) 
{
	cbi(SPI_PORT, P_CSn);
    3232:	c3 98       	cbi	0x18, 3	; 24
	while(bit_is_set(PINB, P_SO));
    3234:	b6 99       	sbic	0x16, 6	; 22
    3236:	fe cf       	rjmp	.-4      	; 0x3234 <cc2500_init+0x22>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    3238:	8e e3       	ldi	r24, 0x3E	; 62
    323a:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    323c:	77 9b       	sbis	0x0e, 7	; 14
    323e:	fe cf       	rjmp	.-4      	; 0x323c <cc2500_init+0x2a>


void SPI_write(BYTE cData)
{
	/* Start transmission */
	SPDR = cData;
    3240:	8f ef       	ldi	r24, 0xFF	; 255
    3242:	8f b9       	out	0x0f, r24	; 15
	
	/* Wait for transmission complete */
	while(!(SPSR & (1<<SPIF)));
    3244:	77 9b       	sbis	0x0e, 7	; 14
    3246:	fe cf       	rjmp	.-4      	; 0x3244 <cc2500_init+0x32>
//	cbi(SPI_PORT, P_SCLK);
	addr&=0x7F;
	SPI_write(addr);
	SPI_write(value);
//	cbi(SPI_PORT, P_SI);
	sbi(SPI_PORT, P_CSn);
    3248:	c3 9a       	sbi	0x18, 3	; 24
        SPI_MasterInit();	
	POWER_UP_RESET_CC2500();
	write_rf_setting();
	//write_burst_reg(PATABLE, paTable, sizeof(paTable));
	halRfWriteReg(PATABLE,0xFF);// 1 dbm output power
}
    324a:	08 95       	ret

0000324c <wake>:



void wake()
{
        rfstate=read_status(MARCSTATE);	//check sleep state and other
    324c:	85 e3       	ldi	r24, 0x35	; 53
    324e:	0e 94 ea 17 	call	0x2fd4	; 0x2fd4 <read_status>
    3252:	80 93 bc 04 	sts	0x04BC, r24
		if((rfstate& 0x1f)==0x00)
    3256:	90 e0       	ldi	r25, 0x00	; 0
    3258:	8f 71       	andi	r24, 0x1F	; 31
    325a:	90 70       	andi	r25, 0x00	; 0
    325c:	89 2b       	or	r24, r25
    325e:	21 f4       	brne	.+8      	; 0x3268 <wake+0x1c>
		{
	
			POWER_UP_RESET_CC2500();
    3260:	0e 94 e8 18 	call	0x31d0	; 0x31d0 <POWER_UP_RESET_CC2500>
			write_rf_setting();
    3264:	0e 94 f8 15 	call	0x2bf0	; 0x2bf0 <write_rf_setting>
    3268:	08 95       	ret

0000326a <init_adc>:


void init_adc()                 //initialize the ADC of the microcontroller
                                //call this function first at the beginning
{
ADMUX=(1<<REFS0);              //Aref joined to AVcc
    326a:	80 e4       	ldi	r24, 0x40	; 64
    326c:	87 b9       	out	0x07, r24	; 7
ADCSRA = _BV(ADEN) | _BV(ADPS0);
    326e:	81 e8       	ldi	r24, 0x81	; 129
    3270:	86 b9       	out	0x06, r24	; 6
}
    3272:	08 95       	ret

00003274 <disab_adc>:

void disab_adc()
{
ADCSRA=0x00;
    3274:	16 b8       	out	0x06, r1	; 6
ADMUX=0x00;
    3276:	17 b8       	out	0x07, r1	; 7
}
    3278:	08 95       	ret

0000327a <read_adc>:
   //Select ADC Channel ch must be 0-7 (corresponds to the flex sensors...)
   //flex sensors from channel 0-4
   //acccelerometer from channel 5-7
   
   ch=ch&0b00000111;
   ADMUX|=ch;
    327a:	97 b1       	in	r25, 0x07	; 7
    327c:	87 70       	andi	r24, 0x07	; 7
    327e:	89 2b       	or	r24, r25
    3280:	87 b9       	out	0x07, r24	; 7

   //Start Single conversion
   ADCSRA|=(1<<ADSC);
    3282:	36 9a       	sbi	0x06, 6	; 6

   //Wait for conversion to complete
   while(!(ADCSRA & (1<<ADIF)));
    3284:	34 9b       	sbis	0x06, 4	; 6
    3286:	fe cf       	rjmp	.-4      	; 0x3284 <read_adc+0xa>

   //Clear ADIF by writing one to it
   ADCSRA|=(1<<ADIF);
    3288:	34 9a       	sbi	0x06, 4	; 6

   return(ADC);
    328a:	24 b1       	in	r18, 0x04	; 4
    328c:	35 b1       	in	r19, 0x05	; 5
}
    328e:	c9 01       	movw	r24, r18
    3290:	08 95       	ret

00003292 <read_batt>:
//IMPORTANT: please start the storage table from address 50 onwards
//I'll be using the initial 0-49 for flags and other data
//26 characters x 5 values = 130 address spaces used in total

void read_batt()
{
    3292:	ef 92       	push	r14
    3294:	ff 92       	push	r15
    3296:	0f 93       	push	r16
    3298:	1f 93       	push	r17


void init_adc()                 //initialize the ADC of the microcontroller
                                //call this function first at the beginning
{
ADMUX=(1<<REFS0);              //Aref joined to AVcc
    329a:	80 e4       	ldi	r24, 0x40	; 64
    329c:	87 b9       	out	0x07, r24	; 7
ADCSRA = _BV(ADEN) | _BV(ADPS0);
    329e:	81 e8       	ldi	r24, 0x81	; 129
    32a0:	86 b9       	out	0x06, r24	; 6
   //Select ADC Channel ch must be 0-7 (corresponds to the flex sensors...)
   //flex sensors from channel 0-4
   //acccelerometer from channel 5-7
   
   ch=ch&0b00000111;
   ADMUX|=ch;
    32a2:	87 b1       	in	r24, 0x07	; 7
    32a4:	87 60       	ori	r24, 0x07	; 7
    32a6:	87 b9       	out	0x07, r24	; 7

   //Start Single conversion
   ADCSRA|=(1<<ADSC);
    32a8:	36 9a       	sbi	0x06, 6	; 6

   //Wait for conversion to complete
   while(!(ADCSRA & (1<<ADIF)));
    32aa:	34 9b       	sbis	0x06, 4	; 6
    32ac:	fe cf       	rjmp	.-4      	; 0x32aa <read_batt+0x18>

   //Clear ADIF by writing one to it
   ADCSRA|=(1<<ADIF);
    32ae:	34 9a       	sbi	0x06, 4	; 6

   return(ADC);
    32b0:	64 b1       	in	r22, 0x04	; 4
    32b2:	75 b1       	in	r23, 0x05	; 5
float vin = 0.0;

init_adc();
value = read_adc(7);
vout= (value * 5.0)/1024.0;
vin = vout / (R2/(R1+R2)); //voltage to be displayed
    32b4:	88 27       	eor	r24, r24
    32b6:	77 fd       	sbrc	r23, 7
    32b8:	80 95       	com	r24
    32ba:	98 2f       	mov	r25, r24
    32bc:	0e 94 40 31 	call	0x6280	; 0x6280 <__floatsisf>
    32c0:	20 e0       	ldi	r18, 0x00	; 0
    32c2:	30 e0       	ldi	r19, 0x00	; 0
    32c4:	40 ea       	ldi	r20, 0xA0	; 160
    32c6:	50 e4       	ldi	r21, 0x40	; 64
    32c8:	0e 94 0a 2f 	call	0x5e14	; 0x5e14 <__mulsf3>
    32cc:	20 e0       	ldi	r18, 0x00	; 0
    32ce:	30 e0       	ldi	r19, 0x00	; 0
    32d0:	40 e8       	ldi	r20, 0x80	; 128
    32d2:	5a e3       	ldi	r21, 0x3A	; 58
    32d4:	0e 94 0a 2f 	call	0x5e14	; 0x5e14 <__mulsf3>
    32d8:	2f eb       	ldi	r18, 0xBF	; 191
    32da:	3e ed       	ldi	r19, 0xDE	; 222
    32dc:	47 e3       	ldi	r20, 0x37	; 55
    32de:	5d e3       	ldi	r21, 0x3D	; 61
    32e0:	0e 94 04 30 	call	0x6008	; 0x6008 <__divsf3>
    32e4:	7b 01       	movw	r14, r22
    32e6:	8c 01       	movw	r16, r24

if(vin < 9.3){glcd_putchar(1,112,0);}
    32e8:	2d ec       	ldi	r18, 0xCD	; 205
    32ea:	3c ec       	ldi	r19, 0xCC	; 204
    32ec:	44 e1       	ldi	r20, 0x14	; 20
    32ee:	51 e4       	ldi	r21, 0x41	; 65
    32f0:	0e 94 10 31 	call	0x6220	; 0x6220 <__ltsf2>
    32f4:	88 23       	and	r24, r24
    32f6:	44 f4       	brge	.+16     	; 0x3308 <read_batt+0x76>
    32f8:	81 e0       	ldi	r24, 0x01	; 1
    32fa:	90 e0       	ldi	r25, 0x00	; 0
    32fc:	60 e7       	ldi	r22, 0x70	; 112
    32fe:	70 e0       	ldi	r23, 0x00	; 0
    3300:	40 e0       	ldi	r20, 0x00	; 0
    3302:	50 e0       	ldi	r21, 0x00	; 0
    3304:	0e 94 fc 13 	call	0x27f8	; 0x27f8 <glcd_putchar>
if(vin > 9.9){glcd_putchar(2,112,0);}
    3308:	c8 01       	movw	r24, r16
    330a:	b7 01       	movw	r22, r14
    330c:	26 e6       	ldi	r18, 0x66	; 102
    330e:	36 e6       	ldi	r19, 0x66	; 102
    3310:	4e e1       	ldi	r20, 0x1E	; 30
    3312:	51 e4       	ldi	r21, 0x41	; 65
    3314:	0e 94 b0 30 	call	0x6160	; 0x6160 <__gtsf2>
    3318:	18 16       	cp	r1, r24
    331a:	44 f4       	brge	.+16     	; 0x332c <read_batt+0x9a>
    331c:	82 e0       	ldi	r24, 0x02	; 2
    331e:	90 e0       	ldi	r25, 0x00	; 0
    3320:	60 e7       	ldi	r22, 0x70	; 112
    3322:	70 e0       	ldi	r23, 0x00	; 0
    3324:	40 e0       	ldi	r20, 0x00	; 0
    3326:	50 e0       	ldi	r21, 0x00	; 0
    3328:	0e 94 fc 13 	call	0x27f8	; 0x27f8 <glcd_putchar>
if(vin > 10.3){glcd_putchar(3,112,0);}
    332c:	c8 01       	movw	r24, r16
    332e:	b7 01       	movw	r22, r14
    3330:	2d ec       	ldi	r18, 0xCD	; 205
    3332:	3c ec       	ldi	r19, 0xCC	; 204
    3334:	44 e2       	ldi	r20, 0x24	; 36
    3336:	51 e4       	ldi	r21, 0x41	; 65
    3338:	0e 94 b0 30 	call	0x6160	; 0x6160 <__gtsf2>
    333c:	18 16       	cp	r1, r24
    333e:	44 f4       	brge	.+16     	; 0x3350 <read_batt+0xbe>
    3340:	83 e0       	ldi	r24, 0x03	; 3
    3342:	90 e0       	ldi	r25, 0x00	; 0
    3344:	60 e7       	ldi	r22, 0x70	; 112
    3346:	70 e0       	ldi	r23, 0x00	; 0
    3348:	40 e0       	ldi	r20, 0x00	; 0
    334a:	50 e0       	ldi	r21, 0x00	; 0
    334c:	0e 94 fc 13 	call	0x27f8	; 0x27f8 <glcd_putchar>
if(vin > 11.1){glcd_putchar(4,112,0);}
    3350:	c8 01       	movw	r24, r16
    3352:	b7 01       	movw	r22, r14
    3354:	2a e9       	ldi	r18, 0x9A	; 154
    3356:	39 e9       	ldi	r19, 0x99	; 153
    3358:	41 e3       	ldi	r20, 0x31	; 49
    335a:	51 e4       	ldi	r21, 0x41	; 65
    335c:	0e 94 b0 30 	call	0x6160	; 0x6160 <__gtsf2>
    3360:	18 16       	cp	r1, r24
    3362:	44 f4       	brge	.+16     	; 0x3374 <read_batt+0xe2>
    3364:	84 e0       	ldi	r24, 0x04	; 4
    3366:	90 e0       	ldi	r25, 0x00	; 0
    3368:	60 e7       	ldi	r22, 0x70	; 112
    336a:	70 e0       	ldi	r23, 0x00	; 0
    336c:	40 e0       	ldi	r20, 0x00	; 0
    336e:	50 e0       	ldi	r21, 0x00	; 0
    3370:	0e 94 fc 13 	call	0x27f8	; 0x27f8 <glcd_putchar>
if(vin > 12.4){glcd_putchar(5,112,0);}
    3374:	c8 01       	movw	r24, r16
    3376:	b7 01       	movw	r22, r14
    3378:	26 e6       	ldi	r18, 0x66	; 102
    337a:	36 e6       	ldi	r19, 0x66	; 102
    337c:	46 e4       	ldi	r20, 0x46	; 70
    337e:	51 e4       	ldi	r21, 0x41	; 65
    3380:	0e 94 b0 30 	call	0x6160	; 0x6160 <__gtsf2>
    3384:	18 16       	cp	r1, r24
    3386:	44 f4       	brge	.+16     	; 0x3398 <read_batt+0x106>
    3388:	85 e0       	ldi	r24, 0x05	; 5
    338a:	90 e0       	ldi	r25, 0x00	; 0
    338c:	60 e7       	ldi	r22, 0x70	; 112
    338e:	70 e0       	ldi	r23, 0x00	; 0
    3390:	40 e0       	ldi	r20, 0x00	; 0
    3392:	50 e0       	ldi	r21, 0x00	; 0
    3394:	0e 94 fc 13 	call	0x27f8	; 0x27f8 <glcd_putchar>
if(vin > 13.0){glcd_putchar(6,112,0);}
    3398:	c8 01       	movw	r24, r16
    339a:	b7 01       	movw	r22, r14
    339c:	20 e0       	ldi	r18, 0x00	; 0
    339e:	30 e0       	ldi	r19, 0x00	; 0
    33a0:	40 e5       	ldi	r20, 0x50	; 80
    33a2:	51 e4       	ldi	r21, 0x41	; 65
    33a4:	0e 94 b0 30 	call	0x6160	; 0x6160 <__gtsf2>
    33a8:	18 16       	cp	r1, r24
    33aa:	44 f4       	brge	.+16     	; 0x33bc <read_batt+0x12a>
    33ac:	86 e0       	ldi	r24, 0x06	; 6
    33ae:	90 e0       	ldi	r25, 0x00	; 0
    33b0:	60 e7       	ldi	r22, 0x70	; 112
    33b2:	70 e0       	ldi	r23, 0x00	; 0
    33b4:	40 e0       	ldi	r20, 0x00	; 0
    33b6:	50 e0       	ldi	r21, 0x00	; 0
    33b8:	0e 94 fc 13 	call	0x27f8	; 0x27f8 <glcd_putchar>
ADCSRA = _BV(ADEN) | _BV(ADPS0);
}

void disab_adc()
{
ADCSRA=0x00;
    33bc:	16 b8       	out	0x06, r1	; 6
ADMUX=0x00;
    33be:	17 b8       	out	0x07, r1	; 7
if(vin > 11.1){glcd_putchar(4,112,0);}
if(vin > 12.4){glcd_putchar(5,112,0);}
if(vin > 13.0){glcd_putchar(6,112,0);}

disab_adc();
}
    33c0:	1f 91       	pop	r17
    33c2:	0f 91       	pop	r16
    33c4:	ff 90       	pop	r15
    33c6:	ef 90       	pop	r14
    33c8:	08 95       	ret

000033ca <e_read>:

uint8_t e_read(int address)
{   
    33ca:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    33cc:	e1 99       	sbic	0x1c, 1	; 28
    33ce:	fe cf       	rjmp	.-4      	; 0x33cc <e_read+0x2>
#if E2END <= 0xFF
    EEARL = (uint8_t)__p;
#else
    EEAR = (uint16_t)__p;
    33d0:	3f bb       	out	0x1f, r19	; 31
    33d2:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    33d4:	e0 9a       	sbi	0x1c, 0	; 28
    33d6:	8d b3       	in	r24, 0x1d	; 29
       //returns value(0-255) from the address given
       //address value from 0-1023 for ATmega 32

	return eeprom_read_byte((unsigned char *) address);
}
    33d8:	08 95       	ret

000033da <e_write>:

void e_write(int address, uint8_t value)  //value from 0-255
{   
    33da:	9c 01       	movw	r18, r24
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    33dc:	e1 99       	sbic	0x1c, 1	; 28
    33de:	fe cf       	rjmp	.-4      	; 0x33dc <e_write+0x2>
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    33e0:	3f bb       	out	0x1f, r19	; 31
    33e2:	2e bb       	out	0x1e, r18	; 30
#endif
    EEDR = __value;
    33e4:	6d bb       	out	0x1d, r22	; 29

    __asm__ __volatile__ (
    33e6:	0f b6       	in	r0, 0x3f	; 63
    33e8:	f8 94       	cli
    33ea:	e2 9a       	sbi	0x1c, 2	; 28
    33ec:	e1 9a       	sbi	0x1c, 1	; 28
    33ee:	0f be       	out	0x3f, r0	; 63
       //writes a value(0-255) to the given address
       //address value from 0-1023 for ATmega 32
 
	eeprom_write_byte((unsigned char *) address, value);
}
    33f0:	08 95       	ret

000033f2 <key_read>:
  //constant polling is required to read the keys
  //use a character variable to store the key value returned by the function

uint8_t row=0,cntr,col=0;

keypad_DDR=0x00;
    33f2:	11 ba       	out	0x11, r1	; 17
keypad_PORT=0x0F;
    33f4:	8f e0       	ldi	r24, 0x0F	; 15
    33f6:	82 bb       	out	0x12, r24	; 18
    33f8:	20 e0       	ldi	r18, 0x00	; 0
    33fa:	44 e0       	ldi	r20, 0x04	; 4
    33fc:	50 e0       	ldi	r21, 0x00	; 0

for(cntr=4;cntr<8;cntr++)
{
keypad_DDR=(1 << cntr);
    33fe:	61 e0       	ldi	r22, 0x01	; 1
    3400:	70 e0       	ldi	r23, 0x00	; 0
    3402:	cb 01       	movw	r24, r22
    3404:	04 2e       	mov	r0, r20
    3406:	02 c0       	rjmp	.+4      	; 0x340c <key_read+0x1a>
    3408:	88 0f       	add	r24, r24
    340a:	99 1f       	adc	r25, r25
    340c:	0a 94       	dec	r0
    340e:	e2 f7       	brpl	.-8      	; 0x3408 <key_read+0x16>
    3410:	81 bb       	out	0x11, r24	; 17
row=keypad_PIN;
    3412:	80 b3       	in	r24, 0x10	; 16

if(row==0b00001110) {row=1;break;}
    3414:	8e 30       	cpi	r24, 0x0E	; 14
    3416:	e1 f0       	breq	.+56     	; 0x3450 <key_read+0x5e>
else if(row==0b00001101) {row=2;break;}
    3418:	8d 30       	cpi	r24, 0x0D	; 13
    341a:	41 f1       	breq	.+80     	; 0x346c <key_read+0x7a>
else if(row==0b00001011) {row=3;break;}
    341c:	8b 30       	cpi	r24, 0x0B	; 11
    341e:	b1 f1       	breq	.+108    	; 0x348c <key_read+0x9a>
else if(row==0b00000111) {row=4;break;}
    3420:	87 30       	cpi	r24, 0x07	; 7
    3422:	09 f4       	brne	.+2      	; 0x3426 <key_read+0x34>
    3424:	43 c0       	rjmp	.+134    	; 0x34ac <key_read+0xba>
++col;
    3426:	2f 5f       	subi	r18, 0xFF	; 255
    3428:	4f 5f       	subi	r20, 0xFF	; 255
    342a:	5f 4f       	sbci	r21, 0xFF	; 255
uint8_t row=0,cntr,col=0;

keypad_DDR=0x00;
keypad_PORT=0x0F;

for(cntr=4;cntr<8;cntr++)
    342c:	24 30       	cpi	r18, 0x04	; 4
    342e:	49 f7       	brne	.-46     	; 0x3402 <key_read+0x10>
else if(row==0b00001011) {row=3;break;}
else if(row==0b00000111) {row=4;break;}
++col;
}

switch(row)
    3430:	82 30       	cpi	r24, 0x02	; 2
    3432:	09 f4       	brne	.+2      	; 0x3436 <key_read+0x44>
    3434:	4b c0       	rjmp	.+150    	; 0x34cc <key_read+0xda>
    3436:	83 30       	cpi	r24, 0x03	; 3
    3438:	18 f4       	brcc	.+6      	; 0x3440 <key_read+0x4e>
    343a:	81 30       	cpi	r24, 0x01	; 1
    343c:	39 f4       	brne	.+14     	; 0x344c <key_read+0x5a>
    343e:	46 c0       	rjmp	.+140    	; 0x34cc <key_read+0xda>
    3440:	83 30       	cpi	r24, 0x03	; 3
    3442:	09 f4       	brne	.+2      	; 0x3446 <key_read+0x54>
    3444:	43 c0       	rjmp	.+134    	; 0x34cc <key_read+0xda>
    3446:	84 30       	cpi	r24, 0x04	; 4
    3448:	09 f4       	brne	.+2      	; 0x344c <key_read+0x5a>
    344a:	40 c0       	rjmp	.+128    	; 0x34cc <key_read+0xda>
    344c:	8f e2       	ldi	r24, 0x2F	; 47
    344e:	08 95       	ret
{
case 1: if(col==1){return'*';}
    3450:	21 30       	cpi	r18, 0x01	; 1
    3452:	e9 f1       	breq	.+122    	; 0x34ce <key_read+0xdc>
        if(col==2){return'0';}
    3454:	22 30       	cpi	r18, 0x02	; 2
    3456:	11 f4       	brne	.+4      	; 0x345c <key_read+0x6a>
    3458:	80 e3       	ldi	r24, 0x30	; 48
    345a:	08 95       	ret
        if(col==3){return'#';}
    345c:	23 30       	cpi	r18, 0x03	; 3
    345e:	11 f4       	brne	.+4      	; 0x3464 <key_read+0x72>
    3460:	83 e2       	ldi	r24, 0x23	; 35
    3462:	08 95       	ret
	    if(col==0){return'D';}
    3464:	22 23       	and	r18, r18
    3466:	91 f5       	brne	.+100    	; 0x34cc <key_read+0xda>
    3468:	84 e4       	ldi	r24, 0x44	; 68
    346a:	08 95       	ret
	    break;

case 2: if(col==1){return'7';}
    346c:	21 30       	cpi	r18, 0x01	; 1
    346e:	11 f4       	brne	.+4      	; 0x3474 <key_read+0x82>
    3470:	87 e3       	ldi	r24, 0x37	; 55
    3472:	08 95       	ret
        if(col==2){return'8';}
    3474:	22 30       	cpi	r18, 0x02	; 2
    3476:	11 f4       	brne	.+4      	; 0x347c <key_read+0x8a>
    3478:	88 e3       	ldi	r24, 0x38	; 56
    347a:	08 95       	ret
	    if(col==3){return'9';}
    347c:	23 30       	cpi	r18, 0x03	; 3
    347e:	11 f4       	brne	.+4      	; 0x3484 <key_read+0x92>
    3480:	89 e3       	ldi	r24, 0x39	; 57
    3482:	08 95       	ret
	    if(col==0){return'C';}
    3484:	22 23       	and	r18, r18
    3486:	11 f5       	brne	.+68     	; 0x34cc <key_read+0xda>
    3488:	83 e4       	ldi	r24, 0x43	; 67
    348a:	08 95       	ret
	    break;

case 3: if(col==1){return'4';}
    348c:	21 30       	cpi	r18, 0x01	; 1
    348e:	11 f4       	brne	.+4      	; 0x3494 <key_read+0xa2>
    3490:	84 e3       	ldi	r24, 0x34	; 52
    3492:	08 95       	ret
        if(col==2){return'5';}
    3494:	22 30       	cpi	r18, 0x02	; 2
    3496:	11 f4       	brne	.+4      	; 0x349c <key_read+0xaa>
    3498:	85 e3       	ldi	r24, 0x35	; 53
    349a:	08 95       	ret
	    if(col==3){return'6';}
    349c:	23 30       	cpi	r18, 0x03	; 3
    349e:	11 f4       	brne	.+4      	; 0x34a4 <key_read+0xb2>
    34a0:	86 e3       	ldi	r24, 0x36	; 54
    34a2:	08 95       	ret
	    if(col==0){return'B';}
    34a4:	22 23       	and	r18, r18
    34a6:	91 f4       	brne	.+36     	; 0x34cc <key_read+0xda>
    34a8:	82 e4       	ldi	r24, 0x42	; 66
    34aa:	08 95       	ret
	    break;

case 4: if(col==1){return'1';}
    34ac:	21 30       	cpi	r18, 0x01	; 1
    34ae:	11 f4       	brne	.+4      	; 0x34b4 <key_read+0xc2>
    34b0:	81 e3       	ldi	r24, 0x31	; 49
    34b2:	08 95       	ret
        if(col==2){return'2';}
    34b4:	22 30       	cpi	r18, 0x02	; 2
    34b6:	11 f4       	brne	.+4      	; 0x34bc <key_read+0xca>
    34b8:	82 e3       	ldi	r24, 0x32	; 50
    34ba:	08 95       	ret
	    if(col==3){return'3';}
    34bc:	23 30       	cpi	r18, 0x03	; 3
    34be:	11 f4       	brne	.+4      	; 0x34c4 <key_read+0xd2>
    34c0:	83 e3       	ldi	r24, 0x33	; 51
    34c2:	08 95       	ret
	    if(col==0){return'A';}
    34c4:	22 23       	and	r18, r18
    34c6:	11 f4       	brne	.+4      	; 0x34cc <key_read+0xda>
    34c8:	81 e4       	ldi	r24, 0x41	; 65
    34ca:	08 95       	ret
    34cc:	08 95       	ret

default: return '/';
         break;

}
}
    34ce:	8a e2       	ldi	r24, 0x2A	; 42
    34d0:	08 95       	ret

000034d2 <init_disp>:
return 0;
}


void init_disp()
{
    34d2:	ef ec       	ldi	r30, 0xCF	; 207
    34d4:	f4 e0       	ldi	r31, 0x04	; 4
uint8_t cntr;
for(cntr=0;cntr<max_char;cntr++){disp[cntr]=0;}
    34d6:	11 92       	st	Z+, r1
    34d8:	85 e0       	ldi	r24, 0x05	; 5
    34da:	ef 33       	cpi	r30, 0x3F	; 63
    34dc:	f8 07       	cpc	r31, r24
    34de:	d9 f7       	brne	.-10     	; 0x34d6 <init_disp+0x4>
}
    34e0:	08 95       	ret

000034e2 <y_movep>:
glcd_puts(" 4) Clear Memory",0,5);
}


void y_movep(uint16_t d)
{
    34e2:	2f 92       	push	r2
    34e4:	3f 92       	push	r3
    34e6:	4f 92       	push	r4
    34e8:	5f 92       	push	r5
    34ea:	6f 92       	push	r6
    34ec:	7f 92       	push	r7
    34ee:	8f 92       	push	r8
    34f0:	9f 92       	push	r9
    34f2:	af 92       	push	r10
    34f4:	bf 92       	push	r11
    34f6:	cf 92       	push	r12
    34f8:	df 92       	push	r13
    34fa:	ef 92       	push	r14
    34fc:	ff 92       	push	r15
    34fe:	0f 93       	push	r16
    3500:	1f 93       	push	r17
cbi(PORTA,5);
    3502:	dd 98       	cbi	0x1b, 5	; 27
cbi(PORTA,6);
    3504:	de 98       	cbi	0x1b, 6	; 27
_delay_us(d);
    3506:	a0 e0       	ldi	r26, 0x00	; 0
    3508:	b0 e0       	ldi	r27, 0x00	; 0
    350a:	bc 01       	movw	r22, r24
    350c:	cd 01       	movw	r24, r26
    350e:	0e 94 f2 31 	call	0x63e4	; 0x63e4 <__floatunsisf>
    3512:	1b 01       	movw	r2, r22
    3514:	2c 01       	movw	r4, r24
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    3516:	2b ea       	ldi	r18, 0xAB	; 171
    3518:	3a ea       	ldi	r19, 0xAA	; 170
    351a:	4a ea       	ldi	r20, 0xAA	; 170
    351c:	50 e4       	ldi	r21, 0x40	; 64
    351e:	0e 94 0a 2f 	call	0x5e14	; 0x5e14 <__mulsf3>
    3522:	5b 01       	movw	r10, r22
    3524:	6c 01       	movw	r12, r24
	if (__tmp < 1.0)
    3526:	20 e0       	ldi	r18, 0x00	; 0
    3528:	30 e0       	ldi	r19, 0x00	; 0
    352a:	40 e8       	ldi	r20, 0x80	; 128
    352c:	5f e3       	ldi	r21, 0x3F	; 63
    352e:	0e 94 10 31 	call	0x6220	; 0x6220 <__ltsf2>
    3532:	88 23       	and	r24, r24
    3534:	14 f4       	brge	.+4      	; 0x353a <y_movep+0x58>
    3536:	61 e0       	ldi	r22, 0x01	; 1
    3538:	54 c0       	rjmp	.+168    	; 0x35e2 <y_movep+0x100>
		__ticks = 1;
	else if (__tmp > 255)
    353a:	c6 01       	movw	r24, r12
    353c:	b5 01       	movw	r22, r10
    353e:	20 e0       	ldi	r18, 0x00	; 0
    3540:	30 e0       	ldi	r19, 0x00	; 0
    3542:	4f e7       	ldi	r20, 0x7F	; 127
    3544:	53 e4       	ldi	r21, 0x43	; 67
    3546:	0e 94 b0 30 	call	0x6160	; 0x6160 <__gtsf2>
    354a:	18 16       	cp	r1, r24
    354c:	0c f0       	brlt	.+2      	; 0x3550 <y_movep+0x6e>
    354e:	45 c0       	rjmp	.+138    	; 0x35da <y_movep+0xf8>
	{
		_delay_ms(__us / 1000.0);
    3550:	c2 01       	movw	r24, r4
    3552:	b1 01       	movw	r22, r2
    3554:	20 e0       	ldi	r18, 0x00	; 0
    3556:	30 e0       	ldi	r19, 0x00	; 0
    3558:	4a e7       	ldi	r20, 0x7A	; 122
    355a:	54 e4       	ldi	r21, 0x44	; 68
    355c:	0e 94 04 30 	call	0x6008	; 0x6008 <__divsf3>
    3560:	3b 01       	movw	r6, r22
    3562:	4c 01       	movw	r8, r24
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3564:	20 e0       	ldi	r18, 0x00	; 0
    3566:	30 e0       	ldi	r19, 0x00	; 0
    3568:	4a e7       	ldi	r20, 0x7A	; 122
    356a:	55 e4       	ldi	r21, 0x45	; 69
    356c:	0e 94 0a 2f 	call	0x5e14	; 0x5e14 <__mulsf3>
    3570:	7b 01       	movw	r14, r22
    3572:	8c 01       	movw	r16, r24
	if (__tmp < 1.0)
    3574:	20 e0       	ldi	r18, 0x00	; 0
    3576:	30 e0       	ldi	r19, 0x00	; 0
    3578:	40 e8       	ldi	r20, 0x80	; 128
    357a:	5f e3       	ldi	r21, 0x3F	; 63
    357c:	0e 94 10 31 	call	0x6220	; 0x6220 <__ltsf2>
    3580:	88 23       	and	r24, r24
    3582:	1c f4       	brge	.+6      	; 0x358a <y_movep+0xa8>
    3584:	61 e0       	ldi	r22, 0x01	; 1
    3586:	70 e0       	ldi	r23, 0x00	; 0
    3588:	24 c0       	rjmp	.+72     	; 0x35d2 <y_movep+0xf0>
		__ticks = 1;
	else if (__tmp > 65535)
    358a:	c8 01       	movw	r24, r16
    358c:	b7 01       	movw	r22, r14
    358e:	20 e0       	ldi	r18, 0x00	; 0
    3590:	3f ef       	ldi	r19, 0xFF	; 255
    3592:	4f e7       	ldi	r20, 0x7F	; 127
    3594:	57 e4       	ldi	r21, 0x47	; 71
    3596:	0e 94 b0 30 	call	0x6160	; 0x6160 <__gtsf2>
    359a:	18 16       	cp	r1, r24
    359c:	b4 f4       	brge	.+44     	; 0x35ca <y_movep+0xe8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    359e:	c4 01       	movw	r24, r8
    35a0:	b3 01       	movw	r22, r6
    35a2:	20 e0       	ldi	r18, 0x00	; 0
    35a4:	30 e0       	ldi	r19, 0x00	; 0
    35a6:	40 e2       	ldi	r20, 0x20	; 32
    35a8:	51 e4       	ldi	r21, 0x41	; 65
    35aa:	0e 94 0a 2f 	call	0x5e14	; 0x5e14 <__mulsf3>
    35ae:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    35b2:	80 e9       	ldi	r24, 0x90	; 144
    35b4:	91 e0       	ldi	r25, 0x01	; 1
    35b6:	05 c0       	rjmp	.+10     	; 0x35c2 <y_movep+0xe0>
    35b8:	fc 01       	movw	r30, r24
    35ba:	31 97       	sbiw	r30, 0x01	; 1
    35bc:	f1 f7       	brne	.-4      	; 0x35ba <y_movep+0xd8>
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    35be:	61 50       	subi	r22, 0x01	; 1
    35c0:	70 40       	sbci	r23, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    35c2:	61 15       	cp	r22, r1
    35c4:	71 05       	cpc	r23, r1
    35c6:	c1 f7       	brne	.-16     	; 0x35b8 <y_movep+0xd6>
    35c8:	0e c0       	rjmp	.+28     	; 0x35e6 <y_movep+0x104>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    35ca:	c8 01       	movw	r24, r16
    35cc:	b7 01       	movw	r22, r14
    35ce:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    35d2:	cb 01       	movw	r24, r22
    35d4:	01 97       	sbiw	r24, 0x01	; 1
    35d6:	f1 f7       	brne	.-4      	; 0x35d4 <y_movep+0xf2>
    35d8:	06 c0       	rjmp	.+12     	; 0x35e6 <y_movep+0x104>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    35da:	c6 01       	movw	r24, r12
    35dc:	b5 01       	movw	r22, r10
    35de:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    35e2:	6a 95       	dec	r22
    35e4:	f1 f7       	brne	.-4      	; 0x35e2 <y_movep+0x100>
sbi(PORTA,5);
    35e6:	dd 9a       	sbi	0x1b, 5	; 27
cbi(PORTA,6);
    35e8:	de 98       	cbi	0x1b, 6	; 27
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
	if (__tmp < 1.0)
    35ea:	c6 01       	movw	r24, r12
    35ec:	b5 01       	movw	r22, r10
    35ee:	20 e0       	ldi	r18, 0x00	; 0
    35f0:	30 e0       	ldi	r19, 0x00	; 0
    35f2:	40 e8       	ldi	r20, 0x80	; 128
    35f4:	5f e3       	ldi	r21, 0x3F	; 63
    35f6:	0e 94 10 31 	call	0x6220	; 0x6220 <__ltsf2>
    35fa:	88 23       	and	r24, r24
    35fc:	14 f4       	brge	.+4      	; 0x3602 <y_movep+0x120>
    35fe:	61 e0       	ldi	r22, 0x01	; 1
    3600:	54 c0       	rjmp	.+168    	; 0x36aa <y_movep+0x1c8>
		__ticks = 1;
	else if (__tmp > 255)
    3602:	c6 01       	movw	r24, r12
    3604:	b5 01       	movw	r22, r10
    3606:	20 e0       	ldi	r18, 0x00	; 0
    3608:	30 e0       	ldi	r19, 0x00	; 0
    360a:	4f e7       	ldi	r20, 0x7F	; 127
    360c:	53 e4       	ldi	r21, 0x43	; 67
    360e:	0e 94 b0 30 	call	0x6160	; 0x6160 <__gtsf2>
    3612:	18 16       	cp	r1, r24
    3614:	0c f0       	brlt	.+2      	; 0x3618 <y_movep+0x136>
    3616:	45 c0       	rjmp	.+138    	; 0x36a2 <y_movep+0x1c0>
	{
		_delay_ms(__us / 1000.0);
    3618:	c2 01       	movw	r24, r4
    361a:	b1 01       	movw	r22, r2
    361c:	20 e0       	ldi	r18, 0x00	; 0
    361e:	30 e0       	ldi	r19, 0x00	; 0
    3620:	4a e7       	ldi	r20, 0x7A	; 122
    3622:	54 e4       	ldi	r21, 0x44	; 68
    3624:	0e 94 04 30 	call	0x6008	; 0x6008 <__divsf3>
    3628:	3b 01       	movw	r6, r22
    362a:	4c 01       	movw	r8, r24
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    362c:	20 e0       	ldi	r18, 0x00	; 0
    362e:	30 e0       	ldi	r19, 0x00	; 0
    3630:	4a e7       	ldi	r20, 0x7A	; 122
    3632:	55 e4       	ldi	r21, 0x45	; 69
    3634:	0e 94 0a 2f 	call	0x5e14	; 0x5e14 <__mulsf3>
    3638:	7b 01       	movw	r14, r22
    363a:	8c 01       	movw	r16, r24
	if (__tmp < 1.0)
    363c:	20 e0       	ldi	r18, 0x00	; 0
    363e:	30 e0       	ldi	r19, 0x00	; 0
    3640:	40 e8       	ldi	r20, 0x80	; 128
    3642:	5f e3       	ldi	r21, 0x3F	; 63
    3644:	0e 94 10 31 	call	0x6220	; 0x6220 <__ltsf2>
    3648:	88 23       	and	r24, r24
    364a:	1c f4       	brge	.+6      	; 0x3652 <y_movep+0x170>
    364c:	61 e0       	ldi	r22, 0x01	; 1
    364e:	70 e0       	ldi	r23, 0x00	; 0
    3650:	24 c0       	rjmp	.+72     	; 0x369a <y_movep+0x1b8>
		__ticks = 1;
	else if (__tmp > 65535)
    3652:	c8 01       	movw	r24, r16
    3654:	b7 01       	movw	r22, r14
    3656:	20 e0       	ldi	r18, 0x00	; 0
    3658:	3f ef       	ldi	r19, 0xFF	; 255
    365a:	4f e7       	ldi	r20, 0x7F	; 127
    365c:	57 e4       	ldi	r21, 0x47	; 71
    365e:	0e 94 b0 30 	call	0x6160	; 0x6160 <__gtsf2>
    3662:	18 16       	cp	r1, r24
    3664:	b4 f4       	brge	.+44     	; 0x3692 <y_movep+0x1b0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3666:	c4 01       	movw	r24, r8
    3668:	b3 01       	movw	r22, r6
    366a:	20 e0       	ldi	r18, 0x00	; 0
    366c:	30 e0       	ldi	r19, 0x00	; 0
    366e:	40 e2       	ldi	r20, 0x20	; 32
    3670:	51 e4       	ldi	r21, 0x41	; 65
    3672:	0e 94 0a 2f 	call	0x5e14	; 0x5e14 <__mulsf3>
    3676:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    367a:	80 e9       	ldi	r24, 0x90	; 144
    367c:	91 e0       	ldi	r25, 0x01	; 1
    367e:	05 c0       	rjmp	.+10     	; 0x368a <y_movep+0x1a8>
    3680:	fc 01       	movw	r30, r24
    3682:	31 97       	sbiw	r30, 0x01	; 1
    3684:	f1 f7       	brne	.-4      	; 0x3682 <y_movep+0x1a0>
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3686:	61 50       	subi	r22, 0x01	; 1
    3688:	70 40       	sbci	r23, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    368a:	61 15       	cp	r22, r1
    368c:	71 05       	cpc	r23, r1
    368e:	c1 f7       	brne	.-16     	; 0x3680 <y_movep+0x19e>
    3690:	0e c0       	rjmp	.+28     	; 0x36ae <y_movep+0x1cc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3692:	c8 01       	movw	r24, r16
    3694:	b7 01       	movw	r22, r14
    3696:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    369a:	cb 01       	movw	r24, r22
    369c:	01 97       	sbiw	r24, 0x01	; 1
    369e:	f1 f7       	brne	.-4      	; 0x369c <y_movep+0x1ba>
    36a0:	06 c0       	rjmp	.+12     	; 0x36ae <y_movep+0x1cc>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    36a2:	c6 01       	movw	r24, r12
    36a4:	b5 01       	movw	r22, r10
    36a6:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    36aa:	6a 95       	dec	r22
    36ac:	f1 f7       	brne	.-4      	; 0x36aa <y_movep+0x1c8>
_delay_us(d);
sbi(PORTA,5);
    36ae:	dd 9a       	sbi	0x1b, 5	; 27
sbi(PORTA,6);
    36b0:	de 9a       	sbi	0x1b, 6	; 27
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
	if (__tmp < 1.0)
    36b2:	c6 01       	movw	r24, r12
    36b4:	b5 01       	movw	r22, r10
    36b6:	20 e0       	ldi	r18, 0x00	; 0
    36b8:	30 e0       	ldi	r19, 0x00	; 0
    36ba:	40 e8       	ldi	r20, 0x80	; 128
    36bc:	5f e3       	ldi	r21, 0x3F	; 63
    36be:	0e 94 10 31 	call	0x6220	; 0x6220 <__ltsf2>
    36c2:	88 23       	and	r24, r24
    36c4:	14 f4       	brge	.+4      	; 0x36ca <y_movep+0x1e8>
    36c6:	61 e0       	ldi	r22, 0x01	; 1
    36c8:	54 c0       	rjmp	.+168    	; 0x3772 <y_movep+0x290>
		__ticks = 1;
	else if (__tmp > 255)
    36ca:	c6 01       	movw	r24, r12
    36cc:	b5 01       	movw	r22, r10
    36ce:	20 e0       	ldi	r18, 0x00	; 0
    36d0:	30 e0       	ldi	r19, 0x00	; 0
    36d2:	4f e7       	ldi	r20, 0x7F	; 127
    36d4:	53 e4       	ldi	r21, 0x43	; 67
    36d6:	0e 94 b0 30 	call	0x6160	; 0x6160 <__gtsf2>
    36da:	18 16       	cp	r1, r24
    36dc:	0c f0       	brlt	.+2      	; 0x36e0 <y_movep+0x1fe>
    36de:	45 c0       	rjmp	.+138    	; 0x376a <y_movep+0x288>
	{
		_delay_ms(__us / 1000.0);
    36e0:	c2 01       	movw	r24, r4
    36e2:	b1 01       	movw	r22, r2
    36e4:	20 e0       	ldi	r18, 0x00	; 0
    36e6:	30 e0       	ldi	r19, 0x00	; 0
    36e8:	4a e7       	ldi	r20, 0x7A	; 122
    36ea:	54 e4       	ldi	r21, 0x44	; 68
    36ec:	0e 94 04 30 	call	0x6008	; 0x6008 <__divsf3>
    36f0:	3b 01       	movw	r6, r22
    36f2:	4c 01       	movw	r8, r24
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    36f4:	20 e0       	ldi	r18, 0x00	; 0
    36f6:	30 e0       	ldi	r19, 0x00	; 0
    36f8:	4a e7       	ldi	r20, 0x7A	; 122
    36fa:	55 e4       	ldi	r21, 0x45	; 69
    36fc:	0e 94 0a 2f 	call	0x5e14	; 0x5e14 <__mulsf3>
    3700:	7b 01       	movw	r14, r22
    3702:	8c 01       	movw	r16, r24
	if (__tmp < 1.0)
    3704:	20 e0       	ldi	r18, 0x00	; 0
    3706:	30 e0       	ldi	r19, 0x00	; 0
    3708:	40 e8       	ldi	r20, 0x80	; 128
    370a:	5f e3       	ldi	r21, 0x3F	; 63
    370c:	0e 94 10 31 	call	0x6220	; 0x6220 <__ltsf2>
    3710:	88 23       	and	r24, r24
    3712:	1c f4       	brge	.+6      	; 0x371a <y_movep+0x238>
    3714:	61 e0       	ldi	r22, 0x01	; 1
    3716:	70 e0       	ldi	r23, 0x00	; 0
    3718:	24 c0       	rjmp	.+72     	; 0x3762 <y_movep+0x280>
		__ticks = 1;
	else if (__tmp > 65535)
    371a:	c8 01       	movw	r24, r16
    371c:	b7 01       	movw	r22, r14
    371e:	20 e0       	ldi	r18, 0x00	; 0
    3720:	3f ef       	ldi	r19, 0xFF	; 255
    3722:	4f e7       	ldi	r20, 0x7F	; 127
    3724:	57 e4       	ldi	r21, 0x47	; 71
    3726:	0e 94 b0 30 	call	0x6160	; 0x6160 <__gtsf2>
    372a:	18 16       	cp	r1, r24
    372c:	b4 f4       	brge	.+44     	; 0x375a <y_movep+0x278>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    372e:	c4 01       	movw	r24, r8
    3730:	b3 01       	movw	r22, r6
    3732:	20 e0       	ldi	r18, 0x00	; 0
    3734:	30 e0       	ldi	r19, 0x00	; 0
    3736:	40 e2       	ldi	r20, 0x20	; 32
    3738:	51 e4       	ldi	r21, 0x41	; 65
    373a:	0e 94 0a 2f 	call	0x5e14	; 0x5e14 <__mulsf3>
    373e:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3742:	80 e9       	ldi	r24, 0x90	; 144
    3744:	91 e0       	ldi	r25, 0x01	; 1
    3746:	05 c0       	rjmp	.+10     	; 0x3752 <y_movep+0x270>
    3748:	fc 01       	movw	r30, r24
    374a:	31 97       	sbiw	r30, 0x01	; 1
    374c:	f1 f7       	brne	.-4      	; 0x374a <y_movep+0x268>
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    374e:	61 50       	subi	r22, 0x01	; 1
    3750:	70 40       	sbci	r23, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3752:	61 15       	cp	r22, r1
    3754:	71 05       	cpc	r23, r1
    3756:	c1 f7       	brne	.-16     	; 0x3748 <y_movep+0x266>
    3758:	0e c0       	rjmp	.+28     	; 0x3776 <y_movep+0x294>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    375a:	c8 01       	movw	r24, r16
    375c:	b7 01       	movw	r22, r14
    375e:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    3762:	cb 01       	movw	r24, r22
    3764:	01 97       	sbiw	r24, 0x01	; 1
    3766:	f1 f7       	brne	.-4      	; 0x3764 <y_movep+0x282>
    3768:	06 c0       	rjmp	.+12     	; 0x3776 <y_movep+0x294>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    376a:	c6 01       	movw	r24, r12
    376c:	b5 01       	movw	r22, r10
    376e:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3772:	6a 95       	dec	r22
    3774:	f1 f7       	brne	.-4      	; 0x3772 <y_movep+0x290>
_delay_us(d);
cbi(PORTA,5);
    3776:	dd 98       	cbi	0x1b, 5	; 27
sbi(PORTA,6);
    3778:	de 9a       	sbi	0x1b, 6	; 27
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
	if (__tmp < 1.0)
    377a:	c6 01       	movw	r24, r12
    377c:	b5 01       	movw	r22, r10
    377e:	20 e0       	ldi	r18, 0x00	; 0
    3780:	30 e0       	ldi	r19, 0x00	; 0
    3782:	40 e8       	ldi	r20, 0x80	; 128
    3784:	5f e3       	ldi	r21, 0x3F	; 63
    3786:	0e 94 10 31 	call	0x6220	; 0x6220 <__ltsf2>
    378a:	88 23       	and	r24, r24
    378c:	14 f4       	brge	.+4      	; 0x3792 <y_movep+0x2b0>
    378e:	61 e0       	ldi	r22, 0x01	; 1
    3790:	54 c0       	rjmp	.+168    	; 0x383a <y_movep+0x358>
		__ticks = 1;
	else if (__tmp > 255)
    3792:	c6 01       	movw	r24, r12
    3794:	b5 01       	movw	r22, r10
    3796:	20 e0       	ldi	r18, 0x00	; 0
    3798:	30 e0       	ldi	r19, 0x00	; 0
    379a:	4f e7       	ldi	r20, 0x7F	; 127
    379c:	53 e4       	ldi	r21, 0x43	; 67
    379e:	0e 94 b0 30 	call	0x6160	; 0x6160 <__gtsf2>
    37a2:	18 16       	cp	r1, r24
    37a4:	0c f0       	brlt	.+2      	; 0x37a8 <y_movep+0x2c6>
    37a6:	45 c0       	rjmp	.+138    	; 0x3832 <y_movep+0x350>
	{
		_delay_ms(__us / 1000.0);
    37a8:	c2 01       	movw	r24, r4
    37aa:	b1 01       	movw	r22, r2
    37ac:	20 e0       	ldi	r18, 0x00	; 0
    37ae:	30 e0       	ldi	r19, 0x00	; 0
    37b0:	4a e7       	ldi	r20, 0x7A	; 122
    37b2:	54 e4       	ldi	r21, 0x44	; 68
    37b4:	0e 94 04 30 	call	0x6008	; 0x6008 <__divsf3>
    37b8:	5b 01       	movw	r10, r22
    37ba:	6c 01       	movw	r12, r24
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    37bc:	20 e0       	ldi	r18, 0x00	; 0
    37be:	30 e0       	ldi	r19, 0x00	; 0
    37c0:	4a e7       	ldi	r20, 0x7A	; 122
    37c2:	55 e4       	ldi	r21, 0x45	; 69
    37c4:	0e 94 0a 2f 	call	0x5e14	; 0x5e14 <__mulsf3>
    37c8:	7b 01       	movw	r14, r22
    37ca:	8c 01       	movw	r16, r24
	if (__tmp < 1.0)
    37cc:	20 e0       	ldi	r18, 0x00	; 0
    37ce:	30 e0       	ldi	r19, 0x00	; 0
    37d0:	40 e8       	ldi	r20, 0x80	; 128
    37d2:	5f e3       	ldi	r21, 0x3F	; 63
    37d4:	0e 94 10 31 	call	0x6220	; 0x6220 <__ltsf2>
    37d8:	88 23       	and	r24, r24
    37da:	1c f4       	brge	.+6      	; 0x37e2 <y_movep+0x300>
    37dc:	61 e0       	ldi	r22, 0x01	; 1
    37de:	70 e0       	ldi	r23, 0x00	; 0
    37e0:	24 c0       	rjmp	.+72     	; 0x382a <y_movep+0x348>
		__ticks = 1;
	else if (__tmp > 65535)
    37e2:	c8 01       	movw	r24, r16
    37e4:	b7 01       	movw	r22, r14
    37e6:	20 e0       	ldi	r18, 0x00	; 0
    37e8:	3f ef       	ldi	r19, 0xFF	; 255
    37ea:	4f e7       	ldi	r20, 0x7F	; 127
    37ec:	57 e4       	ldi	r21, 0x47	; 71
    37ee:	0e 94 b0 30 	call	0x6160	; 0x6160 <__gtsf2>
    37f2:	18 16       	cp	r1, r24
    37f4:	b4 f4       	brge	.+44     	; 0x3822 <y_movep+0x340>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    37f6:	c6 01       	movw	r24, r12
    37f8:	b5 01       	movw	r22, r10
    37fa:	20 e0       	ldi	r18, 0x00	; 0
    37fc:	30 e0       	ldi	r19, 0x00	; 0
    37fe:	40 e2       	ldi	r20, 0x20	; 32
    3800:	51 e4       	ldi	r21, 0x41	; 65
    3802:	0e 94 0a 2f 	call	0x5e14	; 0x5e14 <__mulsf3>
    3806:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    380a:	80 e9       	ldi	r24, 0x90	; 144
    380c:	91 e0       	ldi	r25, 0x01	; 1
    380e:	05 c0       	rjmp	.+10     	; 0x381a <y_movep+0x338>
    3810:	fc 01       	movw	r30, r24
    3812:	31 97       	sbiw	r30, 0x01	; 1
    3814:	f1 f7       	brne	.-4      	; 0x3812 <y_movep+0x330>
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3816:	61 50       	subi	r22, 0x01	; 1
    3818:	70 40       	sbci	r23, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    381a:	61 15       	cp	r22, r1
    381c:	71 05       	cpc	r23, r1
    381e:	c1 f7       	brne	.-16     	; 0x3810 <y_movep+0x32e>
    3820:	0e c0       	rjmp	.+28     	; 0x383e <y_movep+0x35c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3822:	c8 01       	movw	r24, r16
    3824:	b7 01       	movw	r22, r14
    3826:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    382a:	cb 01       	movw	r24, r22
    382c:	01 97       	sbiw	r24, 0x01	; 1
    382e:	f1 f7       	brne	.-4      	; 0x382c <y_movep+0x34a>
    3830:	06 c0       	rjmp	.+12     	; 0x383e <y_movep+0x35c>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3832:	c6 01       	movw	r24, r12
    3834:	b5 01       	movw	r22, r10
    3836:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    383a:	6a 95       	dec	r22
    383c:	f1 f7       	brne	.-4      	; 0x383a <y_movep+0x358>
_delay_us(d);
}
    383e:	1f 91       	pop	r17
    3840:	0f 91       	pop	r16
    3842:	ff 90       	pop	r15
    3844:	ef 90       	pop	r14
    3846:	df 90       	pop	r13
    3848:	cf 90       	pop	r12
    384a:	bf 90       	pop	r11
    384c:	af 90       	pop	r10
    384e:	9f 90       	pop	r9
    3850:	8f 90       	pop	r8
    3852:	7f 90       	pop	r7
    3854:	6f 90       	pop	r6
    3856:	5f 90       	pop	r5
    3858:	4f 90       	pop	r4
    385a:	3f 90       	pop	r3
    385c:	2f 90       	pop	r2
    385e:	08 95       	ret

00003860 <y_moven>:

void y_moven(uint16_t d)
{
    3860:	2f 92       	push	r2
    3862:	3f 92       	push	r3
    3864:	4f 92       	push	r4
    3866:	5f 92       	push	r5
    3868:	6f 92       	push	r6
    386a:	7f 92       	push	r7
    386c:	8f 92       	push	r8
    386e:	9f 92       	push	r9
    3870:	af 92       	push	r10
    3872:	bf 92       	push	r11
    3874:	cf 92       	push	r12
    3876:	df 92       	push	r13
    3878:	ef 92       	push	r14
    387a:	ff 92       	push	r15
    387c:	0f 93       	push	r16
    387e:	1f 93       	push	r17
cbi(PORTA,5);
    3880:	dd 98       	cbi	0x1b, 5	; 27
sbi(PORTA,6);
    3882:	de 9a       	sbi	0x1b, 6	; 27
_delay_us(d);
    3884:	a0 e0       	ldi	r26, 0x00	; 0
    3886:	b0 e0       	ldi	r27, 0x00	; 0
    3888:	bc 01       	movw	r22, r24
    388a:	cd 01       	movw	r24, r26
    388c:	0e 94 f2 31 	call	0x63e4	; 0x63e4 <__floatunsisf>
    3890:	1b 01       	movw	r2, r22
    3892:	2c 01       	movw	r4, r24
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    3894:	2b ea       	ldi	r18, 0xAB	; 171
    3896:	3a ea       	ldi	r19, 0xAA	; 170
    3898:	4a ea       	ldi	r20, 0xAA	; 170
    389a:	50 e4       	ldi	r21, 0x40	; 64
    389c:	0e 94 0a 2f 	call	0x5e14	; 0x5e14 <__mulsf3>
    38a0:	5b 01       	movw	r10, r22
    38a2:	6c 01       	movw	r12, r24
	if (__tmp < 1.0)
    38a4:	20 e0       	ldi	r18, 0x00	; 0
    38a6:	30 e0       	ldi	r19, 0x00	; 0
    38a8:	40 e8       	ldi	r20, 0x80	; 128
    38aa:	5f e3       	ldi	r21, 0x3F	; 63
    38ac:	0e 94 10 31 	call	0x6220	; 0x6220 <__ltsf2>
    38b0:	88 23       	and	r24, r24
    38b2:	14 f4       	brge	.+4      	; 0x38b8 <y_moven+0x58>
    38b4:	61 e0       	ldi	r22, 0x01	; 1
    38b6:	54 c0       	rjmp	.+168    	; 0x3960 <y_moven+0x100>
		__ticks = 1;
	else if (__tmp > 255)
    38b8:	c6 01       	movw	r24, r12
    38ba:	b5 01       	movw	r22, r10
    38bc:	20 e0       	ldi	r18, 0x00	; 0
    38be:	30 e0       	ldi	r19, 0x00	; 0
    38c0:	4f e7       	ldi	r20, 0x7F	; 127
    38c2:	53 e4       	ldi	r21, 0x43	; 67
    38c4:	0e 94 b0 30 	call	0x6160	; 0x6160 <__gtsf2>
    38c8:	18 16       	cp	r1, r24
    38ca:	0c f0       	brlt	.+2      	; 0x38ce <y_moven+0x6e>
    38cc:	45 c0       	rjmp	.+138    	; 0x3958 <y_moven+0xf8>
	{
		_delay_ms(__us / 1000.0);
    38ce:	c2 01       	movw	r24, r4
    38d0:	b1 01       	movw	r22, r2
    38d2:	20 e0       	ldi	r18, 0x00	; 0
    38d4:	30 e0       	ldi	r19, 0x00	; 0
    38d6:	4a e7       	ldi	r20, 0x7A	; 122
    38d8:	54 e4       	ldi	r21, 0x44	; 68
    38da:	0e 94 04 30 	call	0x6008	; 0x6008 <__divsf3>
    38de:	3b 01       	movw	r6, r22
    38e0:	4c 01       	movw	r8, r24
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    38e2:	20 e0       	ldi	r18, 0x00	; 0
    38e4:	30 e0       	ldi	r19, 0x00	; 0
    38e6:	4a e7       	ldi	r20, 0x7A	; 122
    38e8:	55 e4       	ldi	r21, 0x45	; 69
    38ea:	0e 94 0a 2f 	call	0x5e14	; 0x5e14 <__mulsf3>
    38ee:	7b 01       	movw	r14, r22
    38f0:	8c 01       	movw	r16, r24
	if (__tmp < 1.0)
    38f2:	20 e0       	ldi	r18, 0x00	; 0
    38f4:	30 e0       	ldi	r19, 0x00	; 0
    38f6:	40 e8       	ldi	r20, 0x80	; 128
    38f8:	5f e3       	ldi	r21, 0x3F	; 63
    38fa:	0e 94 10 31 	call	0x6220	; 0x6220 <__ltsf2>
    38fe:	88 23       	and	r24, r24
    3900:	1c f4       	brge	.+6      	; 0x3908 <y_moven+0xa8>
    3902:	61 e0       	ldi	r22, 0x01	; 1
    3904:	70 e0       	ldi	r23, 0x00	; 0
    3906:	24 c0       	rjmp	.+72     	; 0x3950 <y_moven+0xf0>
		__ticks = 1;
	else if (__tmp > 65535)
    3908:	c8 01       	movw	r24, r16
    390a:	b7 01       	movw	r22, r14
    390c:	20 e0       	ldi	r18, 0x00	; 0
    390e:	3f ef       	ldi	r19, 0xFF	; 255
    3910:	4f e7       	ldi	r20, 0x7F	; 127
    3912:	57 e4       	ldi	r21, 0x47	; 71
    3914:	0e 94 b0 30 	call	0x6160	; 0x6160 <__gtsf2>
    3918:	18 16       	cp	r1, r24
    391a:	b4 f4       	brge	.+44     	; 0x3948 <y_moven+0xe8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    391c:	c4 01       	movw	r24, r8
    391e:	b3 01       	movw	r22, r6
    3920:	20 e0       	ldi	r18, 0x00	; 0
    3922:	30 e0       	ldi	r19, 0x00	; 0
    3924:	40 e2       	ldi	r20, 0x20	; 32
    3926:	51 e4       	ldi	r21, 0x41	; 65
    3928:	0e 94 0a 2f 	call	0x5e14	; 0x5e14 <__mulsf3>
    392c:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3930:	80 e9       	ldi	r24, 0x90	; 144
    3932:	91 e0       	ldi	r25, 0x01	; 1
    3934:	05 c0       	rjmp	.+10     	; 0x3940 <y_moven+0xe0>
    3936:	fc 01       	movw	r30, r24
    3938:	31 97       	sbiw	r30, 0x01	; 1
    393a:	f1 f7       	brne	.-4      	; 0x3938 <y_moven+0xd8>
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    393c:	61 50       	subi	r22, 0x01	; 1
    393e:	70 40       	sbci	r23, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3940:	61 15       	cp	r22, r1
    3942:	71 05       	cpc	r23, r1
    3944:	c1 f7       	brne	.-16     	; 0x3936 <y_moven+0xd6>
    3946:	0e c0       	rjmp	.+28     	; 0x3964 <y_moven+0x104>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3948:	c8 01       	movw	r24, r16
    394a:	b7 01       	movw	r22, r14
    394c:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    3950:	cb 01       	movw	r24, r22
    3952:	01 97       	sbiw	r24, 0x01	; 1
    3954:	f1 f7       	brne	.-4      	; 0x3952 <y_moven+0xf2>
    3956:	06 c0       	rjmp	.+12     	; 0x3964 <y_moven+0x104>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3958:	c6 01       	movw	r24, r12
    395a:	b5 01       	movw	r22, r10
    395c:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3960:	6a 95       	dec	r22
    3962:	f1 f7       	brne	.-4      	; 0x3960 <y_moven+0x100>
sbi(PORTA,5);
    3964:	dd 9a       	sbi	0x1b, 5	; 27
sbi(PORTA,6);
    3966:	de 9a       	sbi	0x1b, 6	; 27
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
	if (__tmp < 1.0)
    3968:	c6 01       	movw	r24, r12
    396a:	b5 01       	movw	r22, r10
    396c:	20 e0       	ldi	r18, 0x00	; 0
    396e:	30 e0       	ldi	r19, 0x00	; 0
    3970:	40 e8       	ldi	r20, 0x80	; 128
    3972:	5f e3       	ldi	r21, 0x3F	; 63
    3974:	0e 94 10 31 	call	0x6220	; 0x6220 <__ltsf2>
    3978:	88 23       	and	r24, r24
    397a:	14 f4       	brge	.+4      	; 0x3980 <y_moven+0x120>
    397c:	61 e0       	ldi	r22, 0x01	; 1
    397e:	54 c0       	rjmp	.+168    	; 0x3a28 <y_moven+0x1c8>
		__ticks = 1;
	else if (__tmp > 255)
    3980:	c6 01       	movw	r24, r12
    3982:	b5 01       	movw	r22, r10
    3984:	20 e0       	ldi	r18, 0x00	; 0
    3986:	30 e0       	ldi	r19, 0x00	; 0
    3988:	4f e7       	ldi	r20, 0x7F	; 127
    398a:	53 e4       	ldi	r21, 0x43	; 67
    398c:	0e 94 b0 30 	call	0x6160	; 0x6160 <__gtsf2>
    3990:	18 16       	cp	r1, r24
    3992:	0c f0       	brlt	.+2      	; 0x3996 <y_moven+0x136>
    3994:	45 c0       	rjmp	.+138    	; 0x3a20 <y_moven+0x1c0>
	{
		_delay_ms(__us / 1000.0);
    3996:	c2 01       	movw	r24, r4
    3998:	b1 01       	movw	r22, r2
    399a:	20 e0       	ldi	r18, 0x00	; 0
    399c:	30 e0       	ldi	r19, 0x00	; 0
    399e:	4a e7       	ldi	r20, 0x7A	; 122
    39a0:	54 e4       	ldi	r21, 0x44	; 68
    39a2:	0e 94 04 30 	call	0x6008	; 0x6008 <__divsf3>
    39a6:	3b 01       	movw	r6, r22
    39a8:	4c 01       	movw	r8, r24
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    39aa:	20 e0       	ldi	r18, 0x00	; 0
    39ac:	30 e0       	ldi	r19, 0x00	; 0
    39ae:	4a e7       	ldi	r20, 0x7A	; 122
    39b0:	55 e4       	ldi	r21, 0x45	; 69
    39b2:	0e 94 0a 2f 	call	0x5e14	; 0x5e14 <__mulsf3>
    39b6:	7b 01       	movw	r14, r22
    39b8:	8c 01       	movw	r16, r24
	if (__tmp < 1.0)
    39ba:	20 e0       	ldi	r18, 0x00	; 0
    39bc:	30 e0       	ldi	r19, 0x00	; 0
    39be:	40 e8       	ldi	r20, 0x80	; 128
    39c0:	5f e3       	ldi	r21, 0x3F	; 63
    39c2:	0e 94 10 31 	call	0x6220	; 0x6220 <__ltsf2>
    39c6:	88 23       	and	r24, r24
    39c8:	1c f4       	brge	.+6      	; 0x39d0 <y_moven+0x170>
    39ca:	61 e0       	ldi	r22, 0x01	; 1
    39cc:	70 e0       	ldi	r23, 0x00	; 0
    39ce:	24 c0       	rjmp	.+72     	; 0x3a18 <y_moven+0x1b8>
		__ticks = 1;
	else if (__tmp > 65535)
    39d0:	c8 01       	movw	r24, r16
    39d2:	b7 01       	movw	r22, r14
    39d4:	20 e0       	ldi	r18, 0x00	; 0
    39d6:	3f ef       	ldi	r19, 0xFF	; 255
    39d8:	4f e7       	ldi	r20, 0x7F	; 127
    39da:	57 e4       	ldi	r21, 0x47	; 71
    39dc:	0e 94 b0 30 	call	0x6160	; 0x6160 <__gtsf2>
    39e0:	18 16       	cp	r1, r24
    39e2:	b4 f4       	brge	.+44     	; 0x3a10 <y_moven+0x1b0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    39e4:	c4 01       	movw	r24, r8
    39e6:	b3 01       	movw	r22, r6
    39e8:	20 e0       	ldi	r18, 0x00	; 0
    39ea:	30 e0       	ldi	r19, 0x00	; 0
    39ec:	40 e2       	ldi	r20, 0x20	; 32
    39ee:	51 e4       	ldi	r21, 0x41	; 65
    39f0:	0e 94 0a 2f 	call	0x5e14	; 0x5e14 <__mulsf3>
    39f4:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    39f8:	80 e9       	ldi	r24, 0x90	; 144
    39fa:	91 e0       	ldi	r25, 0x01	; 1
    39fc:	05 c0       	rjmp	.+10     	; 0x3a08 <y_moven+0x1a8>
    39fe:	fc 01       	movw	r30, r24
    3a00:	31 97       	sbiw	r30, 0x01	; 1
    3a02:	f1 f7       	brne	.-4      	; 0x3a00 <y_moven+0x1a0>
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3a04:	61 50       	subi	r22, 0x01	; 1
    3a06:	70 40       	sbci	r23, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3a08:	61 15       	cp	r22, r1
    3a0a:	71 05       	cpc	r23, r1
    3a0c:	c1 f7       	brne	.-16     	; 0x39fe <y_moven+0x19e>
    3a0e:	0e c0       	rjmp	.+28     	; 0x3a2c <y_moven+0x1cc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3a10:	c8 01       	movw	r24, r16
    3a12:	b7 01       	movw	r22, r14
    3a14:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    3a18:	cb 01       	movw	r24, r22
    3a1a:	01 97       	sbiw	r24, 0x01	; 1
    3a1c:	f1 f7       	brne	.-4      	; 0x3a1a <y_moven+0x1ba>
    3a1e:	06 c0       	rjmp	.+12     	; 0x3a2c <y_moven+0x1cc>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3a20:	c6 01       	movw	r24, r12
    3a22:	b5 01       	movw	r22, r10
    3a24:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3a28:	6a 95       	dec	r22
    3a2a:	f1 f7       	brne	.-4      	; 0x3a28 <y_moven+0x1c8>
_delay_us(d);
sbi(PORTA,5);
    3a2c:	dd 9a       	sbi	0x1b, 5	; 27
cbi(PORTA,6);
    3a2e:	de 98       	cbi	0x1b, 6	; 27
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
	if (__tmp < 1.0)
    3a30:	c6 01       	movw	r24, r12
    3a32:	b5 01       	movw	r22, r10
    3a34:	20 e0       	ldi	r18, 0x00	; 0
    3a36:	30 e0       	ldi	r19, 0x00	; 0
    3a38:	40 e8       	ldi	r20, 0x80	; 128
    3a3a:	5f e3       	ldi	r21, 0x3F	; 63
    3a3c:	0e 94 10 31 	call	0x6220	; 0x6220 <__ltsf2>
    3a40:	88 23       	and	r24, r24
    3a42:	14 f4       	brge	.+4      	; 0x3a48 <y_moven+0x1e8>
    3a44:	61 e0       	ldi	r22, 0x01	; 1
    3a46:	54 c0       	rjmp	.+168    	; 0x3af0 <y_moven+0x290>
		__ticks = 1;
	else if (__tmp > 255)
    3a48:	c6 01       	movw	r24, r12
    3a4a:	b5 01       	movw	r22, r10
    3a4c:	20 e0       	ldi	r18, 0x00	; 0
    3a4e:	30 e0       	ldi	r19, 0x00	; 0
    3a50:	4f e7       	ldi	r20, 0x7F	; 127
    3a52:	53 e4       	ldi	r21, 0x43	; 67
    3a54:	0e 94 b0 30 	call	0x6160	; 0x6160 <__gtsf2>
    3a58:	18 16       	cp	r1, r24
    3a5a:	0c f0       	brlt	.+2      	; 0x3a5e <y_moven+0x1fe>
    3a5c:	45 c0       	rjmp	.+138    	; 0x3ae8 <y_moven+0x288>
	{
		_delay_ms(__us / 1000.0);
    3a5e:	c2 01       	movw	r24, r4
    3a60:	b1 01       	movw	r22, r2
    3a62:	20 e0       	ldi	r18, 0x00	; 0
    3a64:	30 e0       	ldi	r19, 0x00	; 0
    3a66:	4a e7       	ldi	r20, 0x7A	; 122
    3a68:	54 e4       	ldi	r21, 0x44	; 68
    3a6a:	0e 94 04 30 	call	0x6008	; 0x6008 <__divsf3>
    3a6e:	3b 01       	movw	r6, r22
    3a70:	4c 01       	movw	r8, r24
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3a72:	20 e0       	ldi	r18, 0x00	; 0
    3a74:	30 e0       	ldi	r19, 0x00	; 0
    3a76:	4a e7       	ldi	r20, 0x7A	; 122
    3a78:	55 e4       	ldi	r21, 0x45	; 69
    3a7a:	0e 94 0a 2f 	call	0x5e14	; 0x5e14 <__mulsf3>
    3a7e:	7b 01       	movw	r14, r22
    3a80:	8c 01       	movw	r16, r24
	if (__tmp < 1.0)
    3a82:	20 e0       	ldi	r18, 0x00	; 0
    3a84:	30 e0       	ldi	r19, 0x00	; 0
    3a86:	40 e8       	ldi	r20, 0x80	; 128
    3a88:	5f e3       	ldi	r21, 0x3F	; 63
    3a8a:	0e 94 10 31 	call	0x6220	; 0x6220 <__ltsf2>
    3a8e:	88 23       	and	r24, r24
    3a90:	1c f4       	brge	.+6      	; 0x3a98 <y_moven+0x238>
    3a92:	61 e0       	ldi	r22, 0x01	; 1
    3a94:	70 e0       	ldi	r23, 0x00	; 0
    3a96:	24 c0       	rjmp	.+72     	; 0x3ae0 <y_moven+0x280>
		__ticks = 1;
	else if (__tmp > 65535)
    3a98:	c8 01       	movw	r24, r16
    3a9a:	b7 01       	movw	r22, r14
    3a9c:	20 e0       	ldi	r18, 0x00	; 0
    3a9e:	3f ef       	ldi	r19, 0xFF	; 255
    3aa0:	4f e7       	ldi	r20, 0x7F	; 127
    3aa2:	57 e4       	ldi	r21, 0x47	; 71
    3aa4:	0e 94 b0 30 	call	0x6160	; 0x6160 <__gtsf2>
    3aa8:	18 16       	cp	r1, r24
    3aaa:	b4 f4       	brge	.+44     	; 0x3ad8 <y_moven+0x278>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3aac:	c4 01       	movw	r24, r8
    3aae:	b3 01       	movw	r22, r6
    3ab0:	20 e0       	ldi	r18, 0x00	; 0
    3ab2:	30 e0       	ldi	r19, 0x00	; 0
    3ab4:	40 e2       	ldi	r20, 0x20	; 32
    3ab6:	51 e4       	ldi	r21, 0x41	; 65
    3ab8:	0e 94 0a 2f 	call	0x5e14	; 0x5e14 <__mulsf3>
    3abc:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3ac0:	80 e9       	ldi	r24, 0x90	; 144
    3ac2:	91 e0       	ldi	r25, 0x01	; 1
    3ac4:	05 c0       	rjmp	.+10     	; 0x3ad0 <y_moven+0x270>
    3ac6:	fc 01       	movw	r30, r24
    3ac8:	31 97       	sbiw	r30, 0x01	; 1
    3aca:	f1 f7       	brne	.-4      	; 0x3ac8 <y_moven+0x268>
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3acc:	61 50       	subi	r22, 0x01	; 1
    3ace:	70 40       	sbci	r23, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3ad0:	61 15       	cp	r22, r1
    3ad2:	71 05       	cpc	r23, r1
    3ad4:	c1 f7       	brne	.-16     	; 0x3ac6 <y_moven+0x266>
    3ad6:	0e c0       	rjmp	.+28     	; 0x3af4 <y_moven+0x294>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3ad8:	c8 01       	movw	r24, r16
    3ada:	b7 01       	movw	r22, r14
    3adc:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    3ae0:	cb 01       	movw	r24, r22
    3ae2:	01 97       	sbiw	r24, 0x01	; 1
    3ae4:	f1 f7       	brne	.-4      	; 0x3ae2 <y_moven+0x282>
    3ae6:	06 c0       	rjmp	.+12     	; 0x3af4 <y_moven+0x294>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3ae8:	c6 01       	movw	r24, r12
    3aea:	b5 01       	movw	r22, r10
    3aec:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3af0:	6a 95       	dec	r22
    3af2:	f1 f7       	brne	.-4      	; 0x3af0 <y_moven+0x290>
_delay_us(d);
cbi(PORTA,5);
    3af4:	dd 98       	cbi	0x1b, 5	; 27
cbi(PORTA,6);
    3af6:	de 98       	cbi	0x1b, 6	; 27
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
	if (__tmp < 1.0)
    3af8:	c6 01       	movw	r24, r12
    3afa:	b5 01       	movw	r22, r10
    3afc:	20 e0       	ldi	r18, 0x00	; 0
    3afe:	30 e0       	ldi	r19, 0x00	; 0
    3b00:	40 e8       	ldi	r20, 0x80	; 128
    3b02:	5f e3       	ldi	r21, 0x3F	; 63
    3b04:	0e 94 10 31 	call	0x6220	; 0x6220 <__ltsf2>
    3b08:	88 23       	and	r24, r24
    3b0a:	14 f4       	brge	.+4      	; 0x3b10 <y_moven+0x2b0>
    3b0c:	61 e0       	ldi	r22, 0x01	; 1
    3b0e:	54 c0       	rjmp	.+168    	; 0x3bb8 <y_moven+0x358>
		__ticks = 1;
	else if (__tmp > 255)
    3b10:	c6 01       	movw	r24, r12
    3b12:	b5 01       	movw	r22, r10
    3b14:	20 e0       	ldi	r18, 0x00	; 0
    3b16:	30 e0       	ldi	r19, 0x00	; 0
    3b18:	4f e7       	ldi	r20, 0x7F	; 127
    3b1a:	53 e4       	ldi	r21, 0x43	; 67
    3b1c:	0e 94 b0 30 	call	0x6160	; 0x6160 <__gtsf2>
    3b20:	18 16       	cp	r1, r24
    3b22:	0c f0       	brlt	.+2      	; 0x3b26 <y_moven+0x2c6>
    3b24:	45 c0       	rjmp	.+138    	; 0x3bb0 <y_moven+0x350>
	{
		_delay_ms(__us / 1000.0);
    3b26:	c2 01       	movw	r24, r4
    3b28:	b1 01       	movw	r22, r2
    3b2a:	20 e0       	ldi	r18, 0x00	; 0
    3b2c:	30 e0       	ldi	r19, 0x00	; 0
    3b2e:	4a e7       	ldi	r20, 0x7A	; 122
    3b30:	54 e4       	ldi	r21, 0x44	; 68
    3b32:	0e 94 04 30 	call	0x6008	; 0x6008 <__divsf3>
    3b36:	5b 01       	movw	r10, r22
    3b38:	6c 01       	movw	r12, r24
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3b3a:	20 e0       	ldi	r18, 0x00	; 0
    3b3c:	30 e0       	ldi	r19, 0x00	; 0
    3b3e:	4a e7       	ldi	r20, 0x7A	; 122
    3b40:	55 e4       	ldi	r21, 0x45	; 69
    3b42:	0e 94 0a 2f 	call	0x5e14	; 0x5e14 <__mulsf3>
    3b46:	7b 01       	movw	r14, r22
    3b48:	8c 01       	movw	r16, r24
	if (__tmp < 1.0)
    3b4a:	20 e0       	ldi	r18, 0x00	; 0
    3b4c:	30 e0       	ldi	r19, 0x00	; 0
    3b4e:	40 e8       	ldi	r20, 0x80	; 128
    3b50:	5f e3       	ldi	r21, 0x3F	; 63
    3b52:	0e 94 10 31 	call	0x6220	; 0x6220 <__ltsf2>
    3b56:	88 23       	and	r24, r24
    3b58:	1c f4       	brge	.+6      	; 0x3b60 <y_moven+0x300>
    3b5a:	61 e0       	ldi	r22, 0x01	; 1
    3b5c:	70 e0       	ldi	r23, 0x00	; 0
    3b5e:	24 c0       	rjmp	.+72     	; 0x3ba8 <y_moven+0x348>
		__ticks = 1;
	else if (__tmp > 65535)
    3b60:	c8 01       	movw	r24, r16
    3b62:	b7 01       	movw	r22, r14
    3b64:	20 e0       	ldi	r18, 0x00	; 0
    3b66:	3f ef       	ldi	r19, 0xFF	; 255
    3b68:	4f e7       	ldi	r20, 0x7F	; 127
    3b6a:	57 e4       	ldi	r21, 0x47	; 71
    3b6c:	0e 94 b0 30 	call	0x6160	; 0x6160 <__gtsf2>
    3b70:	18 16       	cp	r1, r24
    3b72:	b4 f4       	brge	.+44     	; 0x3ba0 <y_moven+0x340>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3b74:	c6 01       	movw	r24, r12
    3b76:	b5 01       	movw	r22, r10
    3b78:	20 e0       	ldi	r18, 0x00	; 0
    3b7a:	30 e0       	ldi	r19, 0x00	; 0
    3b7c:	40 e2       	ldi	r20, 0x20	; 32
    3b7e:	51 e4       	ldi	r21, 0x41	; 65
    3b80:	0e 94 0a 2f 	call	0x5e14	; 0x5e14 <__mulsf3>
    3b84:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3b88:	80 e9       	ldi	r24, 0x90	; 144
    3b8a:	91 e0       	ldi	r25, 0x01	; 1
    3b8c:	05 c0       	rjmp	.+10     	; 0x3b98 <y_moven+0x338>
    3b8e:	fc 01       	movw	r30, r24
    3b90:	31 97       	sbiw	r30, 0x01	; 1
    3b92:	f1 f7       	brne	.-4      	; 0x3b90 <y_moven+0x330>
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3b94:	61 50       	subi	r22, 0x01	; 1
    3b96:	70 40       	sbci	r23, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3b98:	61 15       	cp	r22, r1
    3b9a:	71 05       	cpc	r23, r1
    3b9c:	c1 f7       	brne	.-16     	; 0x3b8e <y_moven+0x32e>
    3b9e:	0e c0       	rjmp	.+28     	; 0x3bbc <y_moven+0x35c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3ba0:	c8 01       	movw	r24, r16
    3ba2:	b7 01       	movw	r22, r14
    3ba4:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    3ba8:	cb 01       	movw	r24, r22
    3baa:	01 97       	sbiw	r24, 0x01	; 1
    3bac:	f1 f7       	brne	.-4      	; 0x3baa <y_moven+0x34a>
    3bae:	06 c0       	rjmp	.+12     	; 0x3bbc <y_moven+0x35c>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3bb0:	c6 01       	movw	r24, r12
    3bb2:	b5 01       	movw	r22, r10
    3bb4:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3bb8:	6a 95       	dec	r22
    3bba:	f1 f7       	brne	.-4      	; 0x3bb8 <y_moven+0x358>
_delay_us(d);
}
    3bbc:	1f 91       	pop	r17
    3bbe:	0f 91       	pop	r16
    3bc0:	ff 90       	pop	r15
    3bc2:	ef 90       	pop	r14
    3bc4:	df 90       	pop	r13
    3bc6:	cf 90       	pop	r12
    3bc8:	bf 90       	pop	r11
    3bca:	af 90       	pop	r10
    3bcc:	9f 90       	pop	r9
    3bce:	8f 90       	pop	r8
    3bd0:	7f 90       	pop	r7
    3bd2:	6f 90       	pop	r6
    3bd4:	5f 90       	pop	r5
    3bd6:	4f 90       	pop	r4
    3bd8:	3f 90       	pop	r3
    3bda:	2f 90       	pop	r2
    3bdc:	08 95       	ret

00003bde <x_movep>:


void x_movep(uint16_t d)
{
    3bde:	2f 92       	push	r2
    3be0:	3f 92       	push	r3
    3be2:	4f 92       	push	r4
    3be4:	5f 92       	push	r5
    3be6:	6f 92       	push	r6
    3be8:	7f 92       	push	r7
    3bea:	8f 92       	push	r8
    3bec:	9f 92       	push	r9
    3bee:	af 92       	push	r10
    3bf0:	bf 92       	push	r11
    3bf2:	cf 92       	push	r12
    3bf4:	df 92       	push	r13
    3bf6:	ef 92       	push	r14
    3bf8:	ff 92       	push	r15
    3bfa:	0f 93       	push	r16
    3bfc:	1f 93       	push	r17
cbi(PORTA,3);
    3bfe:	db 98       	cbi	0x1b, 3	; 27
cbi(PORTA,4);
    3c00:	dc 98       	cbi	0x1b, 4	; 27
_delay_us(d);
    3c02:	a0 e0       	ldi	r26, 0x00	; 0
    3c04:	b0 e0       	ldi	r27, 0x00	; 0
    3c06:	bc 01       	movw	r22, r24
    3c08:	cd 01       	movw	r24, r26
    3c0a:	0e 94 f2 31 	call	0x63e4	; 0x63e4 <__floatunsisf>
    3c0e:	1b 01       	movw	r2, r22
    3c10:	2c 01       	movw	r4, r24
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    3c12:	2b ea       	ldi	r18, 0xAB	; 171
    3c14:	3a ea       	ldi	r19, 0xAA	; 170
    3c16:	4a ea       	ldi	r20, 0xAA	; 170
    3c18:	50 e4       	ldi	r21, 0x40	; 64
    3c1a:	0e 94 0a 2f 	call	0x5e14	; 0x5e14 <__mulsf3>
    3c1e:	5b 01       	movw	r10, r22
    3c20:	6c 01       	movw	r12, r24
	if (__tmp < 1.0)
    3c22:	20 e0       	ldi	r18, 0x00	; 0
    3c24:	30 e0       	ldi	r19, 0x00	; 0
    3c26:	40 e8       	ldi	r20, 0x80	; 128
    3c28:	5f e3       	ldi	r21, 0x3F	; 63
    3c2a:	0e 94 10 31 	call	0x6220	; 0x6220 <__ltsf2>
    3c2e:	88 23       	and	r24, r24
    3c30:	14 f4       	brge	.+4      	; 0x3c36 <x_movep+0x58>
    3c32:	61 e0       	ldi	r22, 0x01	; 1
    3c34:	54 c0       	rjmp	.+168    	; 0x3cde <x_movep+0x100>
		__ticks = 1;
	else if (__tmp > 255)
    3c36:	c6 01       	movw	r24, r12
    3c38:	b5 01       	movw	r22, r10
    3c3a:	20 e0       	ldi	r18, 0x00	; 0
    3c3c:	30 e0       	ldi	r19, 0x00	; 0
    3c3e:	4f e7       	ldi	r20, 0x7F	; 127
    3c40:	53 e4       	ldi	r21, 0x43	; 67
    3c42:	0e 94 b0 30 	call	0x6160	; 0x6160 <__gtsf2>
    3c46:	18 16       	cp	r1, r24
    3c48:	0c f0       	brlt	.+2      	; 0x3c4c <x_movep+0x6e>
    3c4a:	45 c0       	rjmp	.+138    	; 0x3cd6 <x_movep+0xf8>
	{
		_delay_ms(__us / 1000.0);
    3c4c:	c2 01       	movw	r24, r4
    3c4e:	b1 01       	movw	r22, r2
    3c50:	20 e0       	ldi	r18, 0x00	; 0
    3c52:	30 e0       	ldi	r19, 0x00	; 0
    3c54:	4a e7       	ldi	r20, 0x7A	; 122
    3c56:	54 e4       	ldi	r21, 0x44	; 68
    3c58:	0e 94 04 30 	call	0x6008	; 0x6008 <__divsf3>
    3c5c:	3b 01       	movw	r6, r22
    3c5e:	4c 01       	movw	r8, r24
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3c60:	20 e0       	ldi	r18, 0x00	; 0
    3c62:	30 e0       	ldi	r19, 0x00	; 0
    3c64:	4a e7       	ldi	r20, 0x7A	; 122
    3c66:	55 e4       	ldi	r21, 0x45	; 69
    3c68:	0e 94 0a 2f 	call	0x5e14	; 0x5e14 <__mulsf3>
    3c6c:	7b 01       	movw	r14, r22
    3c6e:	8c 01       	movw	r16, r24
	if (__tmp < 1.0)
    3c70:	20 e0       	ldi	r18, 0x00	; 0
    3c72:	30 e0       	ldi	r19, 0x00	; 0
    3c74:	40 e8       	ldi	r20, 0x80	; 128
    3c76:	5f e3       	ldi	r21, 0x3F	; 63
    3c78:	0e 94 10 31 	call	0x6220	; 0x6220 <__ltsf2>
    3c7c:	88 23       	and	r24, r24
    3c7e:	1c f4       	brge	.+6      	; 0x3c86 <x_movep+0xa8>
    3c80:	61 e0       	ldi	r22, 0x01	; 1
    3c82:	70 e0       	ldi	r23, 0x00	; 0
    3c84:	24 c0       	rjmp	.+72     	; 0x3cce <x_movep+0xf0>
		__ticks = 1;
	else if (__tmp > 65535)
    3c86:	c8 01       	movw	r24, r16
    3c88:	b7 01       	movw	r22, r14
    3c8a:	20 e0       	ldi	r18, 0x00	; 0
    3c8c:	3f ef       	ldi	r19, 0xFF	; 255
    3c8e:	4f e7       	ldi	r20, 0x7F	; 127
    3c90:	57 e4       	ldi	r21, 0x47	; 71
    3c92:	0e 94 b0 30 	call	0x6160	; 0x6160 <__gtsf2>
    3c96:	18 16       	cp	r1, r24
    3c98:	b4 f4       	brge	.+44     	; 0x3cc6 <x_movep+0xe8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3c9a:	c4 01       	movw	r24, r8
    3c9c:	b3 01       	movw	r22, r6
    3c9e:	20 e0       	ldi	r18, 0x00	; 0
    3ca0:	30 e0       	ldi	r19, 0x00	; 0
    3ca2:	40 e2       	ldi	r20, 0x20	; 32
    3ca4:	51 e4       	ldi	r21, 0x41	; 65
    3ca6:	0e 94 0a 2f 	call	0x5e14	; 0x5e14 <__mulsf3>
    3caa:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3cae:	80 e9       	ldi	r24, 0x90	; 144
    3cb0:	91 e0       	ldi	r25, 0x01	; 1
    3cb2:	05 c0       	rjmp	.+10     	; 0x3cbe <x_movep+0xe0>
    3cb4:	fc 01       	movw	r30, r24
    3cb6:	31 97       	sbiw	r30, 0x01	; 1
    3cb8:	f1 f7       	brne	.-4      	; 0x3cb6 <x_movep+0xd8>
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3cba:	61 50       	subi	r22, 0x01	; 1
    3cbc:	70 40       	sbci	r23, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3cbe:	61 15       	cp	r22, r1
    3cc0:	71 05       	cpc	r23, r1
    3cc2:	c1 f7       	brne	.-16     	; 0x3cb4 <x_movep+0xd6>
    3cc4:	0e c0       	rjmp	.+28     	; 0x3ce2 <x_movep+0x104>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3cc6:	c8 01       	movw	r24, r16
    3cc8:	b7 01       	movw	r22, r14
    3cca:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    3cce:	cb 01       	movw	r24, r22
    3cd0:	01 97       	sbiw	r24, 0x01	; 1
    3cd2:	f1 f7       	brne	.-4      	; 0x3cd0 <x_movep+0xf2>
    3cd4:	06 c0       	rjmp	.+12     	; 0x3ce2 <x_movep+0x104>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3cd6:	c6 01       	movw	r24, r12
    3cd8:	b5 01       	movw	r22, r10
    3cda:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3cde:	6a 95       	dec	r22
    3ce0:	f1 f7       	brne	.-4      	; 0x3cde <x_movep+0x100>
sbi(PORTA,3);
    3ce2:	db 9a       	sbi	0x1b, 3	; 27
cbi(PORTA,4);
    3ce4:	dc 98       	cbi	0x1b, 4	; 27
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
	if (__tmp < 1.0)
    3ce6:	c6 01       	movw	r24, r12
    3ce8:	b5 01       	movw	r22, r10
    3cea:	20 e0       	ldi	r18, 0x00	; 0
    3cec:	30 e0       	ldi	r19, 0x00	; 0
    3cee:	40 e8       	ldi	r20, 0x80	; 128
    3cf0:	5f e3       	ldi	r21, 0x3F	; 63
    3cf2:	0e 94 10 31 	call	0x6220	; 0x6220 <__ltsf2>
    3cf6:	88 23       	and	r24, r24
    3cf8:	14 f4       	brge	.+4      	; 0x3cfe <x_movep+0x120>
    3cfa:	61 e0       	ldi	r22, 0x01	; 1
    3cfc:	54 c0       	rjmp	.+168    	; 0x3da6 <x_movep+0x1c8>
		__ticks = 1;
	else if (__tmp > 255)
    3cfe:	c6 01       	movw	r24, r12
    3d00:	b5 01       	movw	r22, r10
    3d02:	20 e0       	ldi	r18, 0x00	; 0
    3d04:	30 e0       	ldi	r19, 0x00	; 0
    3d06:	4f e7       	ldi	r20, 0x7F	; 127
    3d08:	53 e4       	ldi	r21, 0x43	; 67
    3d0a:	0e 94 b0 30 	call	0x6160	; 0x6160 <__gtsf2>
    3d0e:	18 16       	cp	r1, r24
    3d10:	0c f0       	brlt	.+2      	; 0x3d14 <x_movep+0x136>
    3d12:	45 c0       	rjmp	.+138    	; 0x3d9e <x_movep+0x1c0>
	{
		_delay_ms(__us / 1000.0);
    3d14:	c2 01       	movw	r24, r4
    3d16:	b1 01       	movw	r22, r2
    3d18:	20 e0       	ldi	r18, 0x00	; 0
    3d1a:	30 e0       	ldi	r19, 0x00	; 0
    3d1c:	4a e7       	ldi	r20, 0x7A	; 122
    3d1e:	54 e4       	ldi	r21, 0x44	; 68
    3d20:	0e 94 04 30 	call	0x6008	; 0x6008 <__divsf3>
    3d24:	3b 01       	movw	r6, r22
    3d26:	4c 01       	movw	r8, r24
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3d28:	20 e0       	ldi	r18, 0x00	; 0
    3d2a:	30 e0       	ldi	r19, 0x00	; 0
    3d2c:	4a e7       	ldi	r20, 0x7A	; 122
    3d2e:	55 e4       	ldi	r21, 0x45	; 69
    3d30:	0e 94 0a 2f 	call	0x5e14	; 0x5e14 <__mulsf3>
    3d34:	7b 01       	movw	r14, r22
    3d36:	8c 01       	movw	r16, r24
	if (__tmp < 1.0)
    3d38:	20 e0       	ldi	r18, 0x00	; 0
    3d3a:	30 e0       	ldi	r19, 0x00	; 0
    3d3c:	40 e8       	ldi	r20, 0x80	; 128
    3d3e:	5f e3       	ldi	r21, 0x3F	; 63
    3d40:	0e 94 10 31 	call	0x6220	; 0x6220 <__ltsf2>
    3d44:	88 23       	and	r24, r24
    3d46:	1c f4       	brge	.+6      	; 0x3d4e <x_movep+0x170>
    3d48:	61 e0       	ldi	r22, 0x01	; 1
    3d4a:	70 e0       	ldi	r23, 0x00	; 0
    3d4c:	24 c0       	rjmp	.+72     	; 0x3d96 <x_movep+0x1b8>
		__ticks = 1;
	else if (__tmp > 65535)
    3d4e:	c8 01       	movw	r24, r16
    3d50:	b7 01       	movw	r22, r14
    3d52:	20 e0       	ldi	r18, 0x00	; 0
    3d54:	3f ef       	ldi	r19, 0xFF	; 255
    3d56:	4f e7       	ldi	r20, 0x7F	; 127
    3d58:	57 e4       	ldi	r21, 0x47	; 71
    3d5a:	0e 94 b0 30 	call	0x6160	; 0x6160 <__gtsf2>
    3d5e:	18 16       	cp	r1, r24
    3d60:	b4 f4       	brge	.+44     	; 0x3d8e <x_movep+0x1b0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3d62:	c4 01       	movw	r24, r8
    3d64:	b3 01       	movw	r22, r6
    3d66:	20 e0       	ldi	r18, 0x00	; 0
    3d68:	30 e0       	ldi	r19, 0x00	; 0
    3d6a:	40 e2       	ldi	r20, 0x20	; 32
    3d6c:	51 e4       	ldi	r21, 0x41	; 65
    3d6e:	0e 94 0a 2f 	call	0x5e14	; 0x5e14 <__mulsf3>
    3d72:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3d76:	80 e9       	ldi	r24, 0x90	; 144
    3d78:	91 e0       	ldi	r25, 0x01	; 1
    3d7a:	05 c0       	rjmp	.+10     	; 0x3d86 <x_movep+0x1a8>
    3d7c:	fc 01       	movw	r30, r24
    3d7e:	31 97       	sbiw	r30, 0x01	; 1
    3d80:	f1 f7       	brne	.-4      	; 0x3d7e <x_movep+0x1a0>
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3d82:	61 50       	subi	r22, 0x01	; 1
    3d84:	70 40       	sbci	r23, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3d86:	61 15       	cp	r22, r1
    3d88:	71 05       	cpc	r23, r1
    3d8a:	c1 f7       	brne	.-16     	; 0x3d7c <x_movep+0x19e>
    3d8c:	0e c0       	rjmp	.+28     	; 0x3daa <x_movep+0x1cc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3d8e:	c8 01       	movw	r24, r16
    3d90:	b7 01       	movw	r22, r14
    3d92:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    3d96:	cb 01       	movw	r24, r22
    3d98:	01 97       	sbiw	r24, 0x01	; 1
    3d9a:	f1 f7       	brne	.-4      	; 0x3d98 <x_movep+0x1ba>
    3d9c:	06 c0       	rjmp	.+12     	; 0x3daa <x_movep+0x1cc>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3d9e:	c6 01       	movw	r24, r12
    3da0:	b5 01       	movw	r22, r10
    3da2:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3da6:	6a 95       	dec	r22
    3da8:	f1 f7       	brne	.-4      	; 0x3da6 <x_movep+0x1c8>
_delay_us(d);
sbi(PORTA,3);
    3daa:	db 9a       	sbi	0x1b, 3	; 27
sbi(PORTA,4);
    3dac:	dc 9a       	sbi	0x1b, 4	; 27
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
	if (__tmp < 1.0)
    3dae:	c6 01       	movw	r24, r12
    3db0:	b5 01       	movw	r22, r10
    3db2:	20 e0       	ldi	r18, 0x00	; 0
    3db4:	30 e0       	ldi	r19, 0x00	; 0
    3db6:	40 e8       	ldi	r20, 0x80	; 128
    3db8:	5f e3       	ldi	r21, 0x3F	; 63
    3dba:	0e 94 10 31 	call	0x6220	; 0x6220 <__ltsf2>
    3dbe:	88 23       	and	r24, r24
    3dc0:	14 f4       	brge	.+4      	; 0x3dc6 <x_movep+0x1e8>
    3dc2:	61 e0       	ldi	r22, 0x01	; 1
    3dc4:	54 c0       	rjmp	.+168    	; 0x3e6e <x_movep+0x290>
		__ticks = 1;
	else if (__tmp > 255)
    3dc6:	c6 01       	movw	r24, r12
    3dc8:	b5 01       	movw	r22, r10
    3dca:	20 e0       	ldi	r18, 0x00	; 0
    3dcc:	30 e0       	ldi	r19, 0x00	; 0
    3dce:	4f e7       	ldi	r20, 0x7F	; 127
    3dd0:	53 e4       	ldi	r21, 0x43	; 67
    3dd2:	0e 94 b0 30 	call	0x6160	; 0x6160 <__gtsf2>
    3dd6:	18 16       	cp	r1, r24
    3dd8:	0c f0       	brlt	.+2      	; 0x3ddc <x_movep+0x1fe>
    3dda:	45 c0       	rjmp	.+138    	; 0x3e66 <x_movep+0x288>
	{
		_delay_ms(__us / 1000.0);
    3ddc:	c2 01       	movw	r24, r4
    3dde:	b1 01       	movw	r22, r2
    3de0:	20 e0       	ldi	r18, 0x00	; 0
    3de2:	30 e0       	ldi	r19, 0x00	; 0
    3de4:	4a e7       	ldi	r20, 0x7A	; 122
    3de6:	54 e4       	ldi	r21, 0x44	; 68
    3de8:	0e 94 04 30 	call	0x6008	; 0x6008 <__divsf3>
    3dec:	3b 01       	movw	r6, r22
    3dee:	4c 01       	movw	r8, r24
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3df0:	20 e0       	ldi	r18, 0x00	; 0
    3df2:	30 e0       	ldi	r19, 0x00	; 0
    3df4:	4a e7       	ldi	r20, 0x7A	; 122
    3df6:	55 e4       	ldi	r21, 0x45	; 69
    3df8:	0e 94 0a 2f 	call	0x5e14	; 0x5e14 <__mulsf3>
    3dfc:	7b 01       	movw	r14, r22
    3dfe:	8c 01       	movw	r16, r24
	if (__tmp < 1.0)
    3e00:	20 e0       	ldi	r18, 0x00	; 0
    3e02:	30 e0       	ldi	r19, 0x00	; 0
    3e04:	40 e8       	ldi	r20, 0x80	; 128
    3e06:	5f e3       	ldi	r21, 0x3F	; 63
    3e08:	0e 94 10 31 	call	0x6220	; 0x6220 <__ltsf2>
    3e0c:	88 23       	and	r24, r24
    3e0e:	1c f4       	brge	.+6      	; 0x3e16 <x_movep+0x238>
    3e10:	61 e0       	ldi	r22, 0x01	; 1
    3e12:	70 e0       	ldi	r23, 0x00	; 0
    3e14:	24 c0       	rjmp	.+72     	; 0x3e5e <x_movep+0x280>
		__ticks = 1;
	else if (__tmp > 65535)
    3e16:	c8 01       	movw	r24, r16
    3e18:	b7 01       	movw	r22, r14
    3e1a:	20 e0       	ldi	r18, 0x00	; 0
    3e1c:	3f ef       	ldi	r19, 0xFF	; 255
    3e1e:	4f e7       	ldi	r20, 0x7F	; 127
    3e20:	57 e4       	ldi	r21, 0x47	; 71
    3e22:	0e 94 b0 30 	call	0x6160	; 0x6160 <__gtsf2>
    3e26:	18 16       	cp	r1, r24
    3e28:	b4 f4       	brge	.+44     	; 0x3e56 <x_movep+0x278>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3e2a:	c4 01       	movw	r24, r8
    3e2c:	b3 01       	movw	r22, r6
    3e2e:	20 e0       	ldi	r18, 0x00	; 0
    3e30:	30 e0       	ldi	r19, 0x00	; 0
    3e32:	40 e2       	ldi	r20, 0x20	; 32
    3e34:	51 e4       	ldi	r21, 0x41	; 65
    3e36:	0e 94 0a 2f 	call	0x5e14	; 0x5e14 <__mulsf3>
    3e3a:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3e3e:	80 e9       	ldi	r24, 0x90	; 144
    3e40:	91 e0       	ldi	r25, 0x01	; 1
    3e42:	05 c0       	rjmp	.+10     	; 0x3e4e <x_movep+0x270>
    3e44:	fc 01       	movw	r30, r24
    3e46:	31 97       	sbiw	r30, 0x01	; 1
    3e48:	f1 f7       	brne	.-4      	; 0x3e46 <x_movep+0x268>
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3e4a:	61 50       	subi	r22, 0x01	; 1
    3e4c:	70 40       	sbci	r23, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3e4e:	61 15       	cp	r22, r1
    3e50:	71 05       	cpc	r23, r1
    3e52:	c1 f7       	brne	.-16     	; 0x3e44 <x_movep+0x266>
    3e54:	0e c0       	rjmp	.+28     	; 0x3e72 <x_movep+0x294>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3e56:	c8 01       	movw	r24, r16
    3e58:	b7 01       	movw	r22, r14
    3e5a:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    3e5e:	cb 01       	movw	r24, r22
    3e60:	01 97       	sbiw	r24, 0x01	; 1
    3e62:	f1 f7       	brne	.-4      	; 0x3e60 <x_movep+0x282>
    3e64:	06 c0       	rjmp	.+12     	; 0x3e72 <x_movep+0x294>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3e66:	c6 01       	movw	r24, r12
    3e68:	b5 01       	movw	r22, r10
    3e6a:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3e6e:	6a 95       	dec	r22
    3e70:	f1 f7       	brne	.-4      	; 0x3e6e <x_movep+0x290>
_delay_us(d);
cbi(PORTA,3);
    3e72:	db 98       	cbi	0x1b, 3	; 27
sbi(PORTA,4);
    3e74:	dc 9a       	sbi	0x1b, 4	; 27
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
	if (__tmp < 1.0)
    3e76:	c6 01       	movw	r24, r12
    3e78:	b5 01       	movw	r22, r10
    3e7a:	20 e0       	ldi	r18, 0x00	; 0
    3e7c:	30 e0       	ldi	r19, 0x00	; 0
    3e7e:	40 e8       	ldi	r20, 0x80	; 128
    3e80:	5f e3       	ldi	r21, 0x3F	; 63
    3e82:	0e 94 10 31 	call	0x6220	; 0x6220 <__ltsf2>
    3e86:	88 23       	and	r24, r24
    3e88:	14 f4       	brge	.+4      	; 0x3e8e <x_movep+0x2b0>
    3e8a:	61 e0       	ldi	r22, 0x01	; 1
    3e8c:	54 c0       	rjmp	.+168    	; 0x3f36 <x_movep+0x358>
		__ticks = 1;
	else if (__tmp > 255)
    3e8e:	c6 01       	movw	r24, r12
    3e90:	b5 01       	movw	r22, r10
    3e92:	20 e0       	ldi	r18, 0x00	; 0
    3e94:	30 e0       	ldi	r19, 0x00	; 0
    3e96:	4f e7       	ldi	r20, 0x7F	; 127
    3e98:	53 e4       	ldi	r21, 0x43	; 67
    3e9a:	0e 94 b0 30 	call	0x6160	; 0x6160 <__gtsf2>
    3e9e:	18 16       	cp	r1, r24
    3ea0:	0c f0       	brlt	.+2      	; 0x3ea4 <x_movep+0x2c6>
    3ea2:	45 c0       	rjmp	.+138    	; 0x3f2e <x_movep+0x350>
	{
		_delay_ms(__us / 1000.0);
    3ea4:	c2 01       	movw	r24, r4
    3ea6:	b1 01       	movw	r22, r2
    3ea8:	20 e0       	ldi	r18, 0x00	; 0
    3eaa:	30 e0       	ldi	r19, 0x00	; 0
    3eac:	4a e7       	ldi	r20, 0x7A	; 122
    3eae:	54 e4       	ldi	r21, 0x44	; 68
    3eb0:	0e 94 04 30 	call	0x6008	; 0x6008 <__divsf3>
    3eb4:	5b 01       	movw	r10, r22
    3eb6:	6c 01       	movw	r12, r24
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3eb8:	20 e0       	ldi	r18, 0x00	; 0
    3eba:	30 e0       	ldi	r19, 0x00	; 0
    3ebc:	4a e7       	ldi	r20, 0x7A	; 122
    3ebe:	55 e4       	ldi	r21, 0x45	; 69
    3ec0:	0e 94 0a 2f 	call	0x5e14	; 0x5e14 <__mulsf3>
    3ec4:	7b 01       	movw	r14, r22
    3ec6:	8c 01       	movw	r16, r24
	if (__tmp < 1.0)
    3ec8:	20 e0       	ldi	r18, 0x00	; 0
    3eca:	30 e0       	ldi	r19, 0x00	; 0
    3ecc:	40 e8       	ldi	r20, 0x80	; 128
    3ece:	5f e3       	ldi	r21, 0x3F	; 63
    3ed0:	0e 94 10 31 	call	0x6220	; 0x6220 <__ltsf2>
    3ed4:	88 23       	and	r24, r24
    3ed6:	1c f4       	brge	.+6      	; 0x3ede <x_movep+0x300>
    3ed8:	61 e0       	ldi	r22, 0x01	; 1
    3eda:	70 e0       	ldi	r23, 0x00	; 0
    3edc:	24 c0       	rjmp	.+72     	; 0x3f26 <x_movep+0x348>
		__ticks = 1;
	else if (__tmp > 65535)
    3ede:	c8 01       	movw	r24, r16
    3ee0:	b7 01       	movw	r22, r14
    3ee2:	20 e0       	ldi	r18, 0x00	; 0
    3ee4:	3f ef       	ldi	r19, 0xFF	; 255
    3ee6:	4f e7       	ldi	r20, 0x7F	; 127
    3ee8:	57 e4       	ldi	r21, 0x47	; 71
    3eea:	0e 94 b0 30 	call	0x6160	; 0x6160 <__gtsf2>
    3eee:	18 16       	cp	r1, r24
    3ef0:	b4 f4       	brge	.+44     	; 0x3f1e <x_movep+0x340>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3ef2:	c6 01       	movw	r24, r12
    3ef4:	b5 01       	movw	r22, r10
    3ef6:	20 e0       	ldi	r18, 0x00	; 0
    3ef8:	30 e0       	ldi	r19, 0x00	; 0
    3efa:	40 e2       	ldi	r20, 0x20	; 32
    3efc:	51 e4       	ldi	r21, 0x41	; 65
    3efe:	0e 94 0a 2f 	call	0x5e14	; 0x5e14 <__mulsf3>
    3f02:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3f06:	80 e9       	ldi	r24, 0x90	; 144
    3f08:	91 e0       	ldi	r25, 0x01	; 1
    3f0a:	05 c0       	rjmp	.+10     	; 0x3f16 <x_movep+0x338>
    3f0c:	fc 01       	movw	r30, r24
    3f0e:	31 97       	sbiw	r30, 0x01	; 1
    3f10:	f1 f7       	brne	.-4      	; 0x3f0e <x_movep+0x330>
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3f12:	61 50       	subi	r22, 0x01	; 1
    3f14:	70 40       	sbci	r23, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3f16:	61 15       	cp	r22, r1
    3f18:	71 05       	cpc	r23, r1
    3f1a:	c1 f7       	brne	.-16     	; 0x3f0c <x_movep+0x32e>
    3f1c:	0e c0       	rjmp	.+28     	; 0x3f3a <x_movep+0x35c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3f1e:	c8 01       	movw	r24, r16
    3f20:	b7 01       	movw	r22, r14
    3f22:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    3f26:	cb 01       	movw	r24, r22
    3f28:	01 97       	sbiw	r24, 0x01	; 1
    3f2a:	f1 f7       	brne	.-4      	; 0x3f28 <x_movep+0x34a>
    3f2c:	06 c0       	rjmp	.+12     	; 0x3f3a <x_movep+0x35c>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3f2e:	c6 01       	movw	r24, r12
    3f30:	b5 01       	movw	r22, r10
    3f32:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3f36:	6a 95       	dec	r22
    3f38:	f1 f7       	brne	.-4      	; 0x3f36 <x_movep+0x358>
_delay_us(d);

}
    3f3a:	1f 91       	pop	r17
    3f3c:	0f 91       	pop	r16
    3f3e:	ff 90       	pop	r15
    3f40:	ef 90       	pop	r14
    3f42:	df 90       	pop	r13
    3f44:	cf 90       	pop	r12
    3f46:	bf 90       	pop	r11
    3f48:	af 90       	pop	r10
    3f4a:	9f 90       	pop	r9
    3f4c:	8f 90       	pop	r8
    3f4e:	7f 90       	pop	r7
    3f50:	6f 90       	pop	r6
    3f52:	5f 90       	pop	r5
    3f54:	4f 90       	pop	r4
    3f56:	3f 90       	pop	r3
    3f58:	2f 90       	pop	r2
    3f5a:	08 95       	ret

00003f5c <x_moven>:

void x_moven(uint16_t d)
{
    3f5c:	2f 92       	push	r2
    3f5e:	3f 92       	push	r3
    3f60:	4f 92       	push	r4
    3f62:	5f 92       	push	r5
    3f64:	6f 92       	push	r6
    3f66:	7f 92       	push	r7
    3f68:	8f 92       	push	r8
    3f6a:	9f 92       	push	r9
    3f6c:	af 92       	push	r10
    3f6e:	bf 92       	push	r11
    3f70:	cf 92       	push	r12
    3f72:	df 92       	push	r13
    3f74:	ef 92       	push	r14
    3f76:	ff 92       	push	r15
    3f78:	0f 93       	push	r16
    3f7a:	1f 93       	push	r17
cbi(PORTA,3);
    3f7c:	db 98       	cbi	0x1b, 3	; 27
sbi(PORTA,4);
    3f7e:	dc 9a       	sbi	0x1b, 4	; 27
_delay_us(d);
    3f80:	a0 e0       	ldi	r26, 0x00	; 0
    3f82:	b0 e0       	ldi	r27, 0x00	; 0
    3f84:	bc 01       	movw	r22, r24
    3f86:	cd 01       	movw	r24, r26
    3f88:	0e 94 f2 31 	call	0x63e4	; 0x63e4 <__floatunsisf>
    3f8c:	1b 01       	movw	r2, r22
    3f8e:	2c 01       	movw	r4, r24
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    3f90:	2b ea       	ldi	r18, 0xAB	; 171
    3f92:	3a ea       	ldi	r19, 0xAA	; 170
    3f94:	4a ea       	ldi	r20, 0xAA	; 170
    3f96:	50 e4       	ldi	r21, 0x40	; 64
    3f98:	0e 94 0a 2f 	call	0x5e14	; 0x5e14 <__mulsf3>
    3f9c:	5b 01       	movw	r10, r22
    3f9e:	6c 01       	movw	r12, r24
	if (__tmp < 1.0)
    3fa0:	20 e0       	ldi	r18, 0x00	; 0
    3fa2:	30 e0       	ldi	r19, 0x00	; 0
    3fa4:	40 e8       	ldi	r20, 0x80	; 128
    3fa6:	5f e3       	ldi	r21, 0x3F	; 63
    3fa8:	0e 94 10 31 	call	0x6220	; 0x6220 <__ltsf2>
    3fac:	88 23       	and	r24, r24
    3fae:	14 f4       	brge	.+4      	; 0x3fb4 <x_moven+0x58>
    3fb0:	61 e0       	ldi	r22, 0x01	; 1
    3fb2:	54 c0       	rjmp	.+168    	; 0x405c <x_moven+0x100>
		__ticks = 1;
	else if (__tmp > 255)
    3fb4:	c6 01       	movw	r24, r12
    3fb6:	b5 01       	movw	r22, r10
    3fb8:	20 e0       	ldi	r18, 0x00	; 0
    3fba:	30 e0       	ldi	r19, 0x00	; 0
    3fbc:	4f e7       	ldi	r20, 0x7F	; 127
    3fbe:	53 e4       	ldi	r21, 0x43	; 67
    3fc0:	0e 94 b0 30 	call	0x6160	; 0x6160 <__gtsf2>
    3fc4:	18 16       	cp	r1, r24
    3fc6:	0c f0       	brlt	.+2      	; 0x3fca <x_moven+0x6e>
    3fc8:	45 c0       	rjmp	.+138    	; 0x4054 <x_moven+0xf8>
	{
		_delay_ms(__us / 1000.0);
    3fca:	c2 01       	movw	r24, r4
    3fcc:	b1 01       	movw	r22, r2
    3fce:	20 e0       	ldi	r18, 0x00	; 0
    3fd0:	30 e0       	ldi	r19, 0x00	; 0
    3fd2:	4a e7       	ldi	r20, 0x7A	; 122
    3fd4:	54 e4       	ldi	r21, 0x44	; 68
    3fd6:	0e 94 04 30 	call	0x6008	; 0x6008 <__divsf3>
    3fda:	3b 01       	movw	r6, r22
    3fdc:	4c 01       	movw	r8, r24
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3fde:	20 e0       	ldi	r18, 0x00	; 0
    3fe0:	30 e0       	ldi	r19, 0x00	; 0
    3fe2:	4a e7       	ldi	r20, 0x7A	; 122
    3fe4:	55 e4       	ldi	r21, 0x45	; 69
    3fe6:	0e 94 0a 2f 	call	0x5e14	; 0x5e14 <__mulsf3>
    3fea:	7b 01       	movw	r14, r22
    3fec:	8c 01       	movw	r16, r24
	if (__tmp < 1.0)
    3fee:	20 e0       	ldi	r18, 0x00	; 0
    3ff0:	30 e0       	ldi	r19, 0x00	; 0
    3ff2:	40 e8       	ldi	r20, 0x80	; 128
    3ff4:	5f e3       	ldi	r21, 0x3F	; 63
    3ff6:	0e 94 10 31 	call	0x6220	; 0x6220 <__ltsf2>
    3ffa:	88 23       	and	r24, r24
    3ffc:	1c f4       	brge	.+6      	; 0x4004 <x_moven+0xa8>
    3ffe:	61 e0       	ldi	r22, 0x01	; 1
    4000:	70 e0       	ldi	r23, 0x00	; 0
    4002:	24 c0       	rjmp	.+72     	; 0x404c <x_moven+0xf0>
		__ticks = 1;
	else if (__tmp > 65535)
    4004:	c8 01       	movw	r24, r16
    4006:	b7 01       	movw	r22, r14
    4008:	20 e0       	ldi	r18, 0x00	; 0
    400a:	3f ef       	ldi	r19, 0xFF	; 255
    400c:	4f e7       	ldi	r20, 0x7F	; 127
    400e:	57 e4       	ldi	r21, 0x47	; 71
    4010:	0e 94 b0 30 	call	0x6160	; 0x6160 <__gtsf2>
    4014:	18 16       	cp	r1, r24
    4016:	b4 f4       	brge	.+44     	; 0x4044 <x_moven+0xe8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4018:	c4 01       	movw	r24, r8
    401a:	b3 01       	movw	r22, r6
    401c:	20 e0       	ldi	r18, 0x00	; 0
    401e:	30 e0       	ldi	r19, 0x00	; 0
    4020:	40 e2       	ldi	r20, 0x20	; 32
    4022:	51 e4       	ldi	r21, 0x41	; 65
    4024:	0e 94 0a 2f 	call	0x5e14	; 0x5e14 <__mulsf3>
    4028:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    402c:	80 e9       	ldi	r24, 0x90	; 144
    402e:	91 e0       	ldi	r25, 0x01	; 1
    4030:	05 c0       	rjmp	.+10     	; 0x403c <x_moven+0xe0>
    4032:	fc 01       	movw	r30, r24
    4034:	31 97       	sbiw	r30, 0x01	; 1
    4036:	f1 f7       	brne	.-4      	; 0x4034 <x_moven+0xd8>
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4038:	61 50       	subi	r22, 0x01	; 1
    403a:	70 40       	sbci	r23, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    403c:	61 15       	cp	r22, r1
    403e:	71 05       	cpc	r23, r1
    4040:	c1 f7       	brne	.-16     	; 0x4032 <x_moven+0xd6>
    4042:	0e c0       	rjmp	.+28     	; 0x4060 <x_moven+0x104>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4044:	c8 01       	movw	r24, r16
    4046:	b7 01       	movw	r22, r14
    4048:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    404c:	cb 01       	movw	r24, r22
    404e:	01 97       	sbiw	r24, 0x01	; 1
    4050:	f1 f7       	brne	.-4      	; 0x404e <x_moven+0xf2>
    4052:	06 c0       	rjmp	.+12     	; 0x4060 <x_moven+0x104>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    4054:	c6 01       	movw	r24, r12
    4056:	b5 01       	movw	r22, r10
    4058:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    405c:	6a 95       	dec	r22
    405e:	f1 f7       	brne	.-4      	; 0x405c <x_moven+0x100>
sbi(PORTA,3);
    4060:	db 9a       	sbi	0x1b, 3	; 27
sbi(PORTA,4);
    4062:	dc 9a       	sbi	0x1b, 4	; 27
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
	if (__tmp < 1.0)
    4064:	c6 01       	movw	r24, r12
    4066:	b5 01       	movw	r22, r10
    4068:	20 e0       	ldi	r18, 0x00	; 0
    406a:	30 e0       	ldi	r19, 0x00	; 0
    406c:	40 e8       	ldi	r20, 0x80	; 128
    406e:	5f e3       	ldi	r21, 0x3F	; 63
    4070:	0e 94 10 31 	call	0x6220	; 0x6220 <__ltsf2>
    4074:	88 23       	and	r24, r24
    4076:	14 f4       	brge	.+4      	; 0x407c <x_moven+0x120>
    4078:	61 e0       	ldi	r22, 0x01	; 1
    407a:	54 c0       	rjmp	.+168    	; 0x4124 <x_moven+0x1c8>
		__ticks = 1;
	else if (__tmp > 255)
    407c:	c6 01       	movw	r24, r12
    407e:	b5 01       	movw	r22, r10
    4080:	20 e0       	ldi	r18, 0x00	; 0
    4082:	30 e0       	ldi	r19, 0x00	; 0
    4084:	4f e7       	ldi	r20, 0x7F	; 127
    4086:	53 e4       	ldi	r21, 0x43	; 67
    4088:	0e 94 b0 30 	call	0x6160	; 0x6160 <__gtsf2>
    408c:	18 16       	cp	r1, r24
    408e:	0c f0       	brlt	.+2      	; 0x4092 <x_moven+0x136>
    4090:	45 c0       	rjmp	.+138    	; 0x411c <x_moven+0x1c0>
	{
		_delay_ms(__us / 1000.0);
    4092:	c2 01       	movw	r24, r4
    4094:	b1 01       	movw	r22, r2
    4096:	20 e0       	ldi	r18, 0x00	; 0
    4098:	30 e0       	ldi	r19, 0x00	; 0
    409a:	4a e7       	ldi	r20, 0x7A	; 122
    409c:	54 e4       	ldi	r21, 0x44	; 68
    409e:	0e 94 04 30 	call	0x6008	; 0x6008 <__divsf3>
    40a2:	3b 01       	movw	r6, r22
    40a4:	4c 01       	movw	r8, r24
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    40a6:	20 e0       	ldi	r18, 0x00	; 0
    40a8:	30 e0       	ldi	r19, 0x00	; 0
    40aa:	4a e7       	ldi	r20, 0x7A	; 122
    40ac:	55 e4       	ldi	r21, 0x45	; 69
    40ae:	0e 94 0a 2f 	call	0x5e14	; 0x5e14 <__mulsf3>
    40b2:	7b 01       	movw	r14, r22
    40b4:	8c 01       	movw	r16, r24
	if (__tmp < 1.0)
    40b6:	20 e0       	ldi	r18, 0x00	; 0
    40b8:	30 e0       	ldi	r19, 0x00	; 0
    40ba:	40 e8       	ldi	r20, 0x80	; 128
    40bc:	5f e3       	ldi	r21, 0x3F	; 63
    40be:	0e 94 10 31 	call	0x6220	; 0x6220 <__ltsf2>
    40c2:	88 23       	and	r24, r24
    40c4:	1c f4       	brge	.+6      	; 0x40cc <x_moven+0x170>
    40c6:	61 e0       	ldi	r22, 0x01	; 1
    40c8:	70 e0       	ldi	r23, 0x00	; 0
    40ca:	24 c0       	rjmp	.+72     	; 0x4114 <x_moven+0x1b8>
		__ticks = 1;
	else if (__tmp > 65535)
    40cc:	c8 01       	movw	r24, r16
    40ce:	b7 01       	movw	r22, r14
    40d0:	20 e0       	ldi	r18, 0x00	; 0
    40d2:	3f ef       	ldi	r19, 0xFF	; 255
    40d4:	4f e7       	ldi	r20, 0x7F	; 127
    40d6:	57 e4       	ldi	r21, 0x47	; 71
    40d8:	0e 94 b0 30 	call	0x6160	; 0x6160 <__gtsf2>
    40dc:	18 16       	cp	r1, r24
    40de:	b4 f4       	brge	.+44     	; 0x410c <x_moven+0x1b0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    40e0:	c4 01       	movw	r24, r8
    40e2:	b3 01       	movw	r22, r6
    40e4:	20 e0       	ldi	r18, 0x00	; 0
    40e6:	30 e0       	ldi	r19, 0x00	; 0
    40e8:	40 e2       	ldi	r20, 0x20	; 32
    40ea:	51 e4       	ldi	r21, 0x41	; 65
    40ec:	0e 94 0a 2f 	call	0x5e14	; 0x5e14 <__mulsf3>
    40f0:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    40f4:	80 e9       	ldi	r24, 0x90	; 144
    40f6:	91 e0       	ldi	r25, 0x01	; 1
    40f8:	05 c0       	rjmp	.+10     	; 0x4104 <x_moven+0x1a8>
    40fa:	fc 01       	movw	r30, r24
    40fc:	31 97       	sbiw	r30, 0x01	; 1
    40fe:	f1 f7       	brne	.-4      	; 0x40fc <x_moven+0x1a0>
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4100:	61 50       	subi	r22, 0x01	; 1
    4102:	70 40       	sbci	r23, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4104:	61 15       	cp	r22, r1
    4106:	71 05       	cpc	r23, r1
    4108:	c1 f7       	brne	.-16     	; 0x40fa <x_moven+0x19e>
    410a:	0e c0       	rjmp	.+28     	; 0x4128 <x_moven+0x1cc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    410c:	c8 01       	movw	r24, r16
    410e:	b7 01       	movw	r22, r14
    4110:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    4114:	cb 01       	movw	r24, r22
    4116:	01 97       	sbiw	r24, 0x01	; 1
    4118:	f1 f7       	brne	.-4      	; 0x4116 <x_moven+0x1ba>
    411a:	06 c0       	rjmp	.+12     	; 0x4128 <x_moven+0x1cc>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    411c:	c6 01       	movw	r24, r12
    411e:	b5 01       	movw	r22, r10
    4120:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    4124:	6a 95       	dec	r22
    4126:	f1 f7       	brne	.-4      	; 0x4124 <x_moven+0x1c8>
_delay_us(d);
sbi(PORTA,3);
    4128:	db 9a       	sbi	0x1b, 3	; 27
cbi(PORTA,4);
    412a:	dc 98       	cbi	0x1b, 4	; 27
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
	if (__tmp < 1.0)
    412c:	c6 01       	movw	r24, r12
    412e:	b5 01       	movw	r22, r10
    4130:	20 e0       	ldi	r18, 0x00	; 0
    4132:	30 e0       	ldi	r19, 0x00	; 0
    4134:	40 e8       	ldi	r20, 0x80	; 128
    4136:	5f e3       	ldi	r21, 0x3F	; 63
    4138:	0e 94 10 31 	call	0x6220	; 0x6220 <__ltsf2>
    413c:	88 23       	and	r24, r24
    413e:	14 f4       	brge	.+4      	; 0x4144 <x_moven+0x1e8>
    4140:	61 e0       	ldi	r22, 0x01	; 1
    4142:	54 c0       	rjmp	.+168    	; 0x41ec <x_moven+0x290>
		__ticks = 1;
	else if (__tmp > 255)
    4144:	c6 01       	movw	r24, r12
    4146:	b5 01       	movw	r22, r10
    4148:	20 e0       	ldi	r18, 0x00	; 0
    414a:	30 e0       	ldi	r19, 0x00	; 0
    414c:	4f e7       	ldi	r20, 0x7F	; 127
    414e:	53 e4       	ldi	r21, 0x43	; 67
    4150:	0e 94 b0 30 	call	0x6160	; 0x6160 <__gtsf2>
    4154:	18 16       	cp	r1, r24
    4156:	0c f0       	brlt	.+2      	; 0x415a <x_moven+0x1fe>
    4158:	45 c0       	rjmp	.+138    	; 0x41e4 <x_moven+0x288>
	{
		_delay_ms(__us / 1000.0);
    415a:	c2 01       	movw	r24, r4
    415c:	b1 01       	movw	r22, r2
    415e:	20 e0       	ldi	r18, 0x00	; 0
    4160:	30 e0       	ldi	r19, 0x00	; 0
    4162:	4a e7       	ldi	r20, 0x7A	; 122
    4164:	54 e4       	ldi	r21, 0x44	; 68
    4166:	0e 94 04 30 	call	0x6008	; 0x6008 <__divsf3>
    416a:	3b 01       	movw	r6, r22
    416c:	4c 01       	movw	r8, r24
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    416e:	20 e0       	ldi	r18, 0x00	; 0
    4170:	30 e0       	ldi	r19, 0x00	; 0
    4172:	4a e7       	ldi	r20, 0x7A	; 122
    4174:	55 e4       	ldi	r21, 0x45	; 69
    4176:	0e 94 0a 2f 	call	0x5e14	; 0x5e14 <__mulsf3>
    417a:	7b 01       	movw	r14, r22
    417c:	8c 01       	movw	r16, r24
	if (__tmp < 1.0)
    417e:	20 e0       	ldi	r18, 0x00	; 0
    4180:	30 e0       	ldi	r19, 0x00	; 0
    4182:	40 e8       	ldi	r20, 0x80	; 128
    4184:	5f e3       	ldi	r21, 0x3F	; 63
    4186:	0e 94 10 31 	call	0x6220	; 0x6220 <__ltsf2>
    418a:	88 23       	and	r24, r24
    418c:	1c f4       	brge	.+6      	; 0x4194 <x_moven+0x238>
    418e:	61 e0       	ldi	r22, 0x01	; 1
    4190:	70 e0       	ldi	r23, 0x00	; 0
    4192:	24 c0       	rjmp	.+72     	; 0x41dc <x_moven+0x280>
		__ticks = 1;
	else if (__tmp > 65535)
    4194:	c8 01       	movw	r24, r16
    4196:	b7 01       	movw	r22, r14
    4198:	20 e0       	ldi	r18, 0x00	; 0
    419a:	3f ef       	ldi	r19, 0xFF	; 255
    419c:	4f e7       	ldi	r20, 0x7F	; 127
    419e:	57 e4       	ldi	r21, 0x47	; 71
    41a0:	0e 94 b0 30 	call	0x6160	; 0x6160 <__gtsf2>
    41a4:	18 16       	cp	r1, r24
    41a6:	b4 f4       	brge	.+44     	; 0x41d4 <x_moven+0x278>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    41a8:	c4 01       	movw	r24, r8
    41aa:	b3 01       	movw	r22, r6
    41ac:	20 e0       	ldi	r18, 0x00	; 0
    41ae:	30 e0       	ldi	r19, 0x00	; 0
    41b0:	40 e2       	ldi	r20, 0x20	; 32
    41b2:	51 e4       	ldi	r21, 0x41	; 65
    41b4:	0e 94 0a 2f 	call	0x5e14	; 0x5e14 <__mulsf3>
    41b8:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    41bc:	80 e9       	ldi	r24, 0x90	; 144
    41be:	91 e0       	ldi	r25, 0x01	; 1
    41c0:	05 c0       	rjmp	.+10     	; 0x41cc <x_moven+0x270>
    41c2:	fc 01       	movw	r30, r24
    41c4:	31 97       	sbiw	r30, 0x01	; 1
    41c6:	f1 f7       	brne	.-4      	; 0x41c4 <x_moven+0x268>
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    41c8:	61 50       	subi	r22, 0x01	; 1
    41ca:	70 40       	sbci	r23, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    41cc:	61 15       	cp	r22, r1
    41ce:	71 05       	cpc	r23, r1
    41d0:	c1 f7       	brne	.-16     	; 0x41c2 <x_moven+0x266>
    41d2:	0e c0       	rjmp	.+28     	; 0x41f0 <x_moven+0x294>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    41d4:	c8 01       	movw	r24, r16
    41d6:	b7 01       	movw	r22, r14
    41d8:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    41dc:	cb 01       	movw	r24, r22
    41de:	01 97       	sbiw	r24, 0x01	; 1
    41e0:	f1 f7       	brne	.-4      	; 0x41de <x_moven+0x282>
    41e2:	06 c0       	rjmp	.+12     	; 0x41f0 <x_moven+0x294>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    41e4:	c6 01       	movw	r24, r12
    41e6:	b5 01       	movw	r22, r10
    41e8:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    41ec:	6a 95       	dec	r22
    41ee:	f1 f7       	brne	.-4      	; 0x41ec <x_moven+0x290>
_delay_us(d);
cbi(PORTA,3);
    41f0:	db 98       	cbi	0x1b, 3	; 27
cbi(PORTA,4);
    41f2:	dc 98       	cbi	0x1b, 4	; 27
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
	if (__tmp < 1.0)
    41f4:	c6 01       	movw	r24, r12
    41f6:	b5 01       	movw	r22, r10
    41f8:	20 e0       	ldi	r18, 0x00	; 0
    41fa:	30 e0       	ldi	r19, 0x00	; 0
    41fc:	40 e8       	ldi	r20, 0x80	; 128
    41fe:	5f e3       	ldi	r21, 0x3F	; 63
    4200:	0e 94 10 31 	call	0x6220	; 0x6220 <__ltsf2>
    4204:	88 23       	and	r24, r24
    4206:	14 f4       	brge	.+4      	; 0x420c <x_moven+0x2b0>
    4208:	61 e0       	ldi	r22, 0x01	; 1
    420a:	54 c0       	rjmp	.+168    	; 0x42b4 <x_moven+0x358>
		__ticks = 1;
	else if (__tmp > 255)
    420c:	c6 01       	movw	r24, r12
    420e:	b5 01       	movw	r22, r10
    4210:	20 e0       	ldi	r18, 0x00	; 0
    4212:	30 e0       	ldi	r19, 0x00	; 0
    4214:	4f e7       	ldi	r20, 0x7F	; 127
    4216:	53 e4       	ldi	r21, 0x43	; 67
    4218:	0e 94 b0 30 	call	0x6160	; 0x6160 <__gtsf2>
    421c:	18 16       	cp	r1, r24
    421e:	0c f0       	brlt	.+2      	; 0x4222 <x_moven+0x2c6>
    4220:	45 c0       	rjmp	.+138    	; 0x42ac <x_moven+0x350>
	{
		_delay_ms(__us / 1000.0);
    4222:	c2 01       	movw	r24, r4
    4224:	b1 01       	movw	r22, r2
    4226:	20 e0       	ldi	r18, 0x00	; 0
    4228:	30 e0       	ldi	r19, 0x00	; 0
    422a:	4a e7       	ldi	r20, 0x7A	; 122
    422c:	54 e4       	ldi	r21, 0x44	; 68
    422e:	0e 94 04 30 	call	0x6008	; 0x6008 <__divsf3>
    4232:	5b 01       	movw	r10, r22
    4234:	6c 01       	movw	r12, r24
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4236:	20 e0       	ldi	r18, 0x00	; 0
    4238:	30 e0       	ldi	r19, 0x00	; 0
    423a:	4a e7       	ldi	r20, 0x7A	; 122
    423c:	55 e4       	ldi	r21, 0x45	; 69
    423e:	0e 94 0a 2f 	call	0x5e14	; 0x5e14 <__mulsf3>
    4242:	7b 01       	movw	r14, r22
    4244:	8c 01       	movw	r16, r24
	if (__tmp < 1.0)
    4246:	20 e0       	ldi	r18, 0x00	; 0
    4248:	30 e0       	ldi	r19, 0x00	; 0
    424a:	40 e8       	ldi	r20, 0x80	; 128
    424c:	5f e3       	ldi	r21, 0x3F	; 63
    424e:	0e 94 10 31 	call	0x6220	; 0x6220 <__ltsf2>
    4252:	88 23       	and	r24, r24
    4254:	1c f4       	brge	.+6      	; 0x425c <x_moven+0x300>
    4256:	61 e0       	ldi	r22, 0x01	; 1
    4258:	70 e0       	ldi	r23, 0x00	; 0
    425a:	24 c0       	rjmp	.+72     	; 0x42a4 <x_moven+0x348>
		__ticks = 1;
	else if (__tmp > 65535)
    425c:	c8 01       	movw	r24, r16
    425e:	b7 01       	movw	r22, r14
    4260:	20 e0       	ldi	r18, 0x00	; 0
    4262:	3f ef       	ldi	r19, 0xFF	; 255
    4264:	4f e7       	ldi	r20, 0x7F	; 127
    4266:	57 e4       	ldi	r21, 0x47	; 71
    4268:	0e 94 b0 30 	call	0x6160	; 0x6160 <__gtsf2>
    426c:	18 16       	cp	r1, r24
    426e:	b4 f4       	brge	.+44     	; 0x429c <x_moven+0x340>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4270:	c6 01       	movw	r24, r12
    4272:	b5 01       	movw	r22, r10
    4274:	20 e0       	ldi	r18, 0x00	; 0
    4276:	30 e0       	ldi	r19, 0x00	; 0
    4278:	40 e2       	ldi	r20, 0x20	; 32
    427a:	51 e4       	ldi	r21, 0x41	; 65
    427c:	0e 94 0a 2f 	call	0x5e14	; 0x5e14 <__mulsf3>
    4280:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4284:	80 e9       	ldi	r24, 0x90	; 144
    4286:	91 e0       	ldi	r25, 0x01	; 1
    4288:	05 c0       	rjmp	.+10     	; 0x4294 <x_moven+0x338>
    428a:	fc 01       	movw	r30, r24
    428c:	31 97       	sbiw	r30, 0x01	; 1
    428e:	f1 f7       	brne	.-4      	; 0x428c <x_moven+0x330>
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4290:	61 50       	subi	r22, 0x01	; 1
    4292:	70 40       	sbci	r23, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4294:	61 15       	cp	r22, r1
    4296:	71 05       	cpc	r23, r1
    4298:	c1 f7       	brne	.-16     	; 0x428a <x_moven+0x32e>
    429a:	0e c0       	rjmp	.+28     	; 0x42b8 <x_moven+0x35c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    429c:	c8 01       	movw	r24, r16
    429e:	b7 01       	movw	r22, r14
    42a0:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    42a4:	cb 01       	movw	r24, r22
    42a6:	01 97       	sbiw	r24, 0x01	; 1
    42a8:	f1 f7       	brne	.-4      	; 0x42a6 <x_moven+0x34a>
    42aa:	06 c0       	rjmp	.+12     	; 0x42b8 <x_moven+0x35c>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    42ac:	c6 01       	movw	r24, r12
    42ae:	b5 01       	movw	r22, r10
    42b0:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    42b4:	6a 95       	dec	r22
    42b6:	f1 f7       	brne	.-4      	; 0x42b4 <x_moven+0x358>
_delay_us(d);

}
    42b8:	1f 91       	pop	r17
    42ba:	0f 91       	pop	r16
    42bc:	ff 90       	pop	r15
    42be:	ef 90       	pop	r14
    42c0:	df 90       	pop	r13
    42c2:	cf 90       	pop	r12
    42c4:	bf 90       	pop	r11
    42c6:	af 90       	pop	r10
    42c8:	9f 90       	pop	r9
    42ca:	8f 90       	pop	r8
    42cc:	7f 90       	pop	r7
    42ce:	6f 90       	pop	r6
    42d0:	5f 90       	pop	r5
    42d2:	4f 90       	pop	r4
    42d4:	3f 90       	pop	r3
    42d6:	2f 90       	pop	r2
    42d8:	08 95       	ret

000042da <chk_click>:

void chk_click()
{

if(cmd==0xCF)
    42da:	80 91 68 04 	lds	r24, 0x0468
    42de:	8f 3c       	cpi	r24, 0xCF	; 207
    42e0:	91 f4       	brne	.+36     	; 0x4306 <chk_click+0x2c>
{
lc=rxBuffer[3];
    42e2:	90 91 c1 04 	lds	r25, 0x04C1
    42e6:	90 93 cd 04 	sts	0x04CD, r25
rc=rxBuffer[4];
    42ea:	80 91 c2 04 	lds	r24, 0x04C2
    42ee:	80 93 b9 04 	sts	0x04B9, r24

if(rc==0xDF){
    42f2:	8f 3d       	cpi	r24, 0xDF	; 223
    42f4:	11 f4       	brne	.+4      	; 0x42fa <chk_click+0x20>
sbi(PORTA,1);
    42f6:	d9 9a       	sbi	0x1b, 1	; 27
    42f8:	01 c0       	rjmp	.+2      	; 0x42fc <chk_click+0x22>
//_delay_ms(25);
}
else cbi(PORTA,1);
    42fa:	d9 98       	cbi	0x1b, 1	; 27


if(lc==0xEF){
    42fc:	9f 3e       	cpi	r25, 0xEF	; 239
    42fe:	11 f4       	brne	.+4      	; 0x4304 <chk_click+0x2a>
sbi(PORTA,2);
    4300:	da 9a       	sbi	0x1b, 2	; 27
    4302:	08 95       	ret
//_delay_ms(25);
}
else cbi(PORTA,2);
    4304:	da 98       	cbi	0x1b, 2	; 27
    4306:	08 95       	ret

00004308 <glcd_puts>:
*/


//---------------------------
void glcd_puts(char *c,int x,int y)
{
    4308:	bf 92       	push	r11
    430a:	cf 92       	push	r12
    430c:	df 92       	push	r13
    430e:	ef 92       	push	r14
    4310:	ff 92       	push	r15
    4312:	0f 93       	push	r16
    4314:	1f 93       	push	r17
    4316:	cf 93       	push	r28
    4318:	df 93       	push	r29
    431a:	6c 01       	movw	r12, r24
    431c:	8b 01       	movw	r16, r22
    431e:	7a 01       	movw	r14, r20
    4320:	bb 24       	eor	r11, r11
    4322:	13 c0       	rjmp	.+38     	; 0x434a <glcd_puts+0x42>
   char i = 0;
   while(i<strlen(c))
   {
      glcd_putchar(*(c+i),x,y);
    4324:	cc 0d       	add	r28, r12
    4326:	dd 1d       	adc	r29, r13
    4328:	88 81       	ld	r24, Y
    432a:	90 e0       	ldi	r25, 0x00	; 0
    432c:	b8 01       	movw	r22, r16
    432e:	a7 01       	movw	r20, r14
    4330:	0e 94 fc 13 	call	0x27f8	; 0x27f8 <glcd_putchar>
      x += 8;
    4334:	08 5f       	subi	r16, 0xF8	; 248
    4336:	1f 4f       	sbci	r17, 0xFF	; 255
      if(x>=128)
    4338:	00 38       	cpi	r16, 0x80	; 128
    433a:	11 05       	cpc	r17, r1
    433c:	2c f0       	brlt	.+10     	; 0x4348 <glcd_puts+0x40>
      {
         x=0;
         y++;
    433e:	08 94       	sec
    4340:	e1 1c       	adc	r14, r1
    4342:	f1 1c       	adc	r15, r1
    4344:	00 e0       	ldi	r16, 0x00	; 0
    4346:	10 e0       	ldi	r17, 0x00	; 0
      }
      i++;
    4348:	b3 94       	inc	r11

//---------------------------
void glcd_puts(char *c,int x,int y)
{
   char i = 0;
   while(i<strlen(c))
    434a:	cb 2d       	mov	r28, r11
    434c:	d0 e0       	ldi	r29, 0x00	; 0
    434e:	f6 01       	movw	r30, r12
    4350:	01 90       	ld	r0, Z+
    4352:	00 20       	and	r0, r0
    4354:	e9 f7       	brne	.-6      	; 0x4350 <glcd_puts+0x48>
    4356:	31 97       	sbiw	r30, 0x01	; 1
    4358:	ec 19       	sub	r30, r12
    435a:	fd 09       	sbc	r31, r13
    435c:	ce 17       	cp	r28, r30
    435e:	df 07       	cpc	r29, r31
    4360:	08 f3       	brcs	.-62     	; 0x4324 <glcd_puts+0x1c>
         x=0;
         y++;
      }
      i++;
   }
}
    4362:	df 91       	pop	r29
    4364:	cf 91       	pop	r28
    4366:	1f 91       	pop	r17
    4368:	0f 91       	pop	r16
    436a:	ff 90       	pop	r15
    436c:	ef 90       	pop	r14
    436e:	df 90       	pop	r13
    4370:	cf 90       	pop	r12
    4372:	bf 90       	pop	r11
    4374:	08 95       	ret

00004376 <refresh_robo_screen>:
}


void refresh_robo_screen()
{
glcd_puts("ROBOT CTRL",0,0);
    4376:	80 e6       	ldi	r24, 0x60	; 96
    4378:	90 e0       	ldi	r25, 0x00	; 0
    437a:	60 e0       	ldi	r22, 0x00	; 0
    437c:	70 e0       	ldi	r23, 0x00	; 0
    437e:	40 e0       	ldi	r20, 0x00	; 0
    4380:	50 e0       	ldi	r21, 0x00	; 0
    4382:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
glcd_puts(" 1) User Control",0,2);
    4386:	8b e6       	ldi	r24, 0x6B	; 107
    4388:	90 e0       	ldi	r25, 0x00	; 0
    438a:	60 e0       	ldi	r22, 0x00	; 0
    438c:	70 e0       	ldi	r23, 0x00	; 0
    438e:	42 e0       	ldi	r20, 0x02	; 2
    4390:	50 e0       	ldi	r21, 0x00	; 0
    4392:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
glcd_puts(" 2) Train Robot",0,3);
    4396:	8c e7       	ldi	r24, 0x7C	; 124
    4398:	90 e0       	ldi	r25, 0x00	; 0
    439a:	60 e0       	ldi	r22, 0x00	; 0
    439c:	70 e0       	ldi	r23, 0x00	; 0
    439e:	43 e0       	ldi	r20, 0x03	; 3
    43a0:	50 e0       	ldi	r21, 0x00	; 0
    43a2:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
glcd_puts(" 3) Auto Mode",0,4);
    43a6:	8c e8       	ldi	r24, 0x8C	; 140
    43a8:	90 e0       	ldi	r25, 0x00	; 0
    43aa:	60 e0       	ldi	r22, 0x00	; 0
    43ac:	70 e0       	ldi	r23, 0x00	; 0
    43ae:	44 e0       	ldi	r20, 0x04	; 4
    43b0:	50 e0       	ldi	r21, 0x00	; 0
    43b2:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
glcd_puts(" 4) Clear Memory",0,5);
    43b6:	8a e9       	ldi	r24, 0x9A	; 154
    43b8:	90 e0       	ldi	r25, 0x00	; 0
    43ba:	60 e0       	ldi	r22, 0x00	; 0
    43bc:	70 e0       	ldi	r23, 0x00	; 0
    43be:	45 e0       	ldi	r20, 0x05	; 5
    43c0:	50 e0       	ldi	r21, 0x00	; 0
    43c2:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
}
    43c6:	08 95       	ret

000043c8 <dev_status>:
glcd_puts("3) special symb",0,5);
glcd_puts("4) mouse ctrl",0,6);
}

void dev_status()
{
    43c8:	ef 92       	push	r14
    43ca:	ff 92       	push	r15
    43cc:	0f 93       	push	r16
    43ce:	1f 93       	push	r17
    43d0:	cf 93       	push	r28
    43d2:	df 93       	push	r29
uint8_t i;
read_batt();
    43d4:	0e 94 49 19 	call	0x3292	; 0x3292 <read_batt>
glcd_puts("DEVICE CTRL",0,0);
    43d8:	8b ea       	ldi	r24, 0xAB	; 171
    43da:	90 e0       	ldi	r25, 0x00	; 0
    43dc:	60 e0       	ldi	r22, 0x00	; 0
    43de:	70 e0       	ldi	r23, 0x00	; 0
    43e0:	40 e0       	ldi	r20, 0x00	; 0
    43e2:	50 e0       	ldi	r21, 0x00	; 0
    43e4:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
glcd_puts("DEVICE",0,1);
    43e8:	87 eb       	ldi	r24, 0xB7	; 183
    43ea:	90 e0       	ldi	r25, 0x00	; 0
    43ec:	60 e0       	ldi	r22, 0x00	; 0
    43ee:	70 e0       	ldi	r23, 0x00	; 0
    43f0:	41 e0       	ldi	r20, 0x01	; 1
    43f2:	50 e0       	ldi	r21, 0x00	; 0
    43f4:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
glcd_puts("STATUS",73,1);
    43f8:	8e eb       	ldi	r24, 0xBE	; 190
    43fa:	90 e0       	ldi	r25, 0x00	; 0
    43fc:	69 e4       	ldi	r22, 0x49	; 73
    43fe:	70 e0       	ldi	r23, 0x00	; 0
    4400:	41 e0       	ldi	r20, 0x01	; 1
    4402:	50 e0       	ldi	r21, 0x00	; 0
    4404:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
    4408:	c1 e0       	ldi	r28, 0x01	; 1
    440a:	d0 e0       	ldi	r29, 0x00	; 0
for(i=0;i<5;i++)
{
glcd_putchar((i+49),17,i+3);
if(tog[i]==1){glcd_puts("ON ",89,i+3);sbi(PORTA,i+1);}
else{glcd_puts("OFF",89,i+3);cbi(PORTA,i+1);}
    440c:	e1 e0       	ldi	r30, 0x01	; 1
    440e:	ee 2e       	mov	r14, r30
    4410:	f1 2c       	mov	r15, r1
{
uint8_t i;
read_batt();
glcd_puts("DEVICE CTRL",0,0);
glcd_puts("DEVICE",0,1);
glcd_puts("STATUS",73,1);
    4412:	8e 01       	movw	r16, r28
    4414:	0e 5f       	subi	r16, 0xFE	; 254
    4416:	1f 4f       	sbci	r17, 0xFF	; 255
for(i=0;i<5;i++)
{
glcd_putchar((i+49),17,i+3);
    4418:	ce 01       	movw	r24, r28
    441a:	c0 96       	adiw	r24, 0x30	; 48
    441c:	61 e1       	ldi	r22, 0x11	; 17
    441e:	70 e0       	ldi	r23, 0x00	; 0
    4420:	a8 01       	movw	r20, r16
    4422:	0e 94 fc 13 	call	0x27f8	; 0x27f8 <glcd_putchar>
if(tog[i]==1){glcd_puts("ON ",89,i+3);sbi(PORTA,i+1);}
    4426:	fe 01       	movw	r30, r28
    4428:	e6 59       	subi	r30, 0x96	; 150
    442a:	fb 4f       	sbci	r31, 0xFB	; 251
    442c:	80 81       	ld	r24, Z
    442e:	81 30       	cpi	r24, 0x01	; 1
    4430:	91 f4       	brne	.+36     	; 0x4456 <dev_status+0x8e>
    4432:	85 ec       	ldi	r24, 0xC5	; 197
    4434:	90 e0       	ldi	r25, 0x00	; 0
    4436:	69 e5       	ldi	r22, 0x59	; 89
    4438:	70 e0       	ldi	r23, 0x00	; 0
    443a:	a8 01       	movw	r20, r16
    443c:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
    4440:	2b b3       	in	r18, 0x1b	; 27
    4442:	c7 01       	movw	r24, r14
    4444:	0c 2e       	mov	r0, r28
    4446:	02 c0       	rjmp	.+4      	; 0x444c <dev_status+0x84>
    4448:	88 0f       	add	r24, r24
    444a:	99 1f       	adc	r25, r25
    444c:	0a 94       	dec	r0
    444e:	e2 f7       	brpl	.-8      	; 0x4448 <dev_status+0x80>
    4450:	28 2b       	or	r18, r24
    4452:	2b bb       	out	0x1b, r18	; 27
    4454:	12 c0       	rjmp	.+36     	; 0x447a <dev_status+0xb2>
else{glcd_puts("OFF",89,i+3);cbi(PORTA,i+1);}
    4456:	89 ec       	ldi	r24, 0xC9	; 201
    4458:	90 e0       	ldi	r25, 0x00	; 0
    445a:	69 e5       	ldi	r22, 0x59	; 89
    445c:	70 e0       	ldi	r23, 0x00	; 0
    445e:	a8 01       	movw	r20, r16
    4460:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
    4464:	2b b3       	in	r18, 0x1b	; 27
    4466:	c7 01       	movw	r24, r14
    4468:	0c 2e       	mov	r0, r28
    446a:	02 c0       	rjmp	.+4      	; 0x4470 <dev_status+0xa8>
    446c:	88 0f       	add	r24, r24
    446e:	99 1f       	adc	r25, r25
    4470:	0a 94       	dec	r0
    4472:	e2 f7       	brpl	.-8      	; 0x446c <dev_status+0xa4>
    4474:	80 95       	com	r24
    4476:	82 23       	and	r24, r18
    4478:	8b bb       	out	0x1b, r24	; 27
    447a:	21 96       	adiw	r28, 0x01	; 1
uint8_t i;
read_batt();
glcd_puts("DEVICE CTRL",0,0);
glcd_puts("DEVICE",0,1);
glcd_puts("STATUS",73,1);
for(i=0;i<5;i++)
    447c:	c6 30       	cpi	r28, 0x06	; 6
    447e:	d1 05       	cpc	r29, r1
    4480:	41 f6       	brne	.-112    	; 0x4412 <dev_status+0x4a>
glcd_putchar((i+49),17,i+3);
if(tog[i]==1){glcd_puts("ON ",89,i+3);sbi(PORTA,i+1);}
else{glcd_puts("OFF",89,i+3);cbi(PORTA,i+1);}
}

}
    4482:	df 91       	pop	r29
    4484:	cf 91       	pop	r28
    4486:	1f 91       	pop	r17
    4488:	0f 91       	pop	r16
    448a:	ff 90       	pop	r15
    448c:	ef 90       	pop	r14
    448e:	08 95       	ret

00004490 <mouse_menu>:
glcd_puts("3) special symb",0,5);
}

void mouse_menu()//menu for mouse
{
glcd_puts("SUB MENU   ",0,0);
    4490:	8d ec       	ldi	r24, 0xCD	; 205
    4492:	90 e0       	ldi	r25, 0x00	; 0
    4494:	60 e0       	ldi	r22, 0x00	; 0
    4496:	70 e0       	ldi	r23, 0x00	; 0
    4498:	40 e0       	ldi	r20, 0x00	; 0
    449a:	50 e0       	ldi	r21, 0x00	; 0
    449c:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
glcd_puts("================",0,1);
    44a0:	89 ed       	ldi	r24, 0xD9	; 217
    44a2:	90 e0       	ldi	r25, 0x00	; 0
    44a4:	60 e0       	ldi	r22, 0x00	; 0
    44a6:	70 e0       	ldi	r23, 0x00	; 0
    44a8:	41 e0       	ldi	r20, 0x01	; 1
    44aa:	50 e0       	ldi	r21, 0x00	; 0
    44ac:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
glcd_puts("1) character",0,3);
    44b0:	8a ee       	ldi	r24, 0xEA	; 234
    44b2:	90 e0       	ldi	r25, 0x00	; 0
    44b4:	60 e0       	ldi	r22, 0x00	; 0
    44b6:	70 e0       	ldi	r23, 0x00	; 0
    44b8:	43 e0       	ldi	r20, 0x03	; 3
    44ba:	50 e0       	ldi	r21, 0x00	; 0
    44bc:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
glcd_puts("2) number",0,4);
    44c0:	87 ef       	ldi	r24, 0xF7	; 247
    44c2:	90 e0       	ldi	r25, 0x00	; 0
    44c4:	60 e0       	ldi	r22, 0x00	; 0
    44c6:	70 e0       	ldi	r23, 0x00	; 0
    44c8:	44 e0       	ldi	r20, 0x04	; 4
    44ca:	50 e0       	ldi	r21, 0x00	; 0
    44cc:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
glcd_puts("3) special symb",0,5);
    44d0:	81 e0       	ldi	r24, 0x01	; 1
    44d2:	91 e0       	ldi	r25, 0x01	; 1
    44d4:	60 e0       	ldi	r22, 0x00	; 0
    44d6:	70 e0       	ldi	r23, 0x00	; 0
    44d8:	45 e0       	ldi	r20, 0x05	; 5
    44da:	50 e0       	ldi	r21, 0x00	; 0
    44dc:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
glcd_puts("4) mouse ctrl",0,6);
    44e0:	81 e1       	ldi	r24, 0x11	; 17
    44e2:	91 e0       	ldi	r25, 0x01	; 1
    44e4:	60 e0       	ldi	r22, 0x00	; 0
    44e6:	70 e0       	ldi	r23, 0x00	; 0
    44e8:	46 e0       	ldi	r20, 0x06	; 6
    44ea:	50 e0       	ldi	r21, 0x00	; 0
    44ec:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
}
    44f0:	08 95       	ret

000044f2 <submenu>:
//glcd_puts("5) train unit",0,7);
}

void submenu()//sub menu
{
glcd_puts("SUB MENU   ",0,0);
    44f2:	8d ec       	ldi	r24, 0xCD	; 205
    44f4:	90 e0       	ldi	r25, 0x00	; 0
    44f6:	60 e0       	ldi	r22, 0x00	; 0
    44f8:	70 e0       	ldi	r23, 0x00	; 0
    44fa:	40 e0       	ldi	r20, 0x00	; 0
    44fc:	50 e0       	ldi	r21, 0x00	; 0
    44fe:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
glcd_puts("================",0,1);
    4502:	89 ed       	ldi	r24, 0xD9	; 217
    4504:	90 e0       	ldi	r25, 0x00	; 0
    4506:	60 e0       	ldi	r22, 0x00	; 0
    4508:	70 e0       	ldi	r23, 0x00	; 0
    450a:	41 e0       	ldi	r20, 0x01	; 1
    450c:	50 e0       	ldi	r21, 0x00	; 0
    450e:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
glcd_puts("1) character",0,3);
    4512:	8a ee       	ldi	r24, 0xEA	; 234
    4514:	90 e0       	ldi	r25, 0x00	; 0
    4516:	60 e0       	ldi	r22, 0x00	; 0
    4518:	70 e0       	ldi	r23, 0x00	; 0
    451a:	43 e0       	ldi	r20, 0x03	; 3
    451c:	50 e0       	ldi	r21, 0x00	; 0
    451e:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
glcd_puts("2) number",0,4);
    4522:	87 ef       	ldi	r24, 0xF7	; 247
    4524:	90 e0       	ldi	r25, 0x00	; 0
    4526:	60 e0       	ldi	r22, 0x00	; 0
    4528:	70 e0       	ldi	r23, 0x00	; 0
    452a:	44 e0       	ldi	r20, 0x04	; 4
    452c:	50 e0       	ldi	r21, 0x00	; 0
    452e:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
glcd_puts("3) special symb",0,5);
    4532:	81 e0       	ldi	r24, 0x01	; 1
    4534:	91 e0       	ldi	r25, 0x01	; 1
    4536:	60 e0       	ldi	r22, 0x00	; 0
    4538:	70 e0       	ldi	r23, 0x00	; 0
    453a:	45 e0       	ldi	r20, 0x05	; 5
    453c:	50 e0       	ldi	r21, 0x00	; 0
    453e:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
}
    4542:	08 95       	ret

00004544 <menu>:
glcd_puts("3) SHAWN   ",0,5);
}

void menu()//main menu
{
glcd_puts("MAIN MENU  ",0,0);
    4544:	8f e1       	ldi	r24, 0x1F	; 31
    4546:	91 e0       	ldi	r25, 0x01	; 1
    4548:	60 e0       	ldi	r22, 0x00	; 0
    454a:	70 e0       	ldi	r23, 0x00	; 0
    454c:	40 e0       	ldi	r20, 0x00	; 0
    454e:	50 e0       	ldi	r21, 0x00	; 0
    4550:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
glcd_puts("================",0,1);
    4554:	89 ed       	ldi	r24, 0xD9	; 217
    4556:	90 e0       	ldi	r25, 0x00	; 0
    4558:	60 e0       	ldi	r22, 0x00	; 0
    455a:	70 e0       	ldi	r23, 0x00	; 0
    455c:	41 e0       	ldi	r20, 0x01	; 1
    455e:	50 e0       	ldi	r21, 0x00	; 0
    4560:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
glcd_puts("1) txt/num/spch",0,3);
    4564:	8b e2       	ldi	r24, 0x2B	; 43
    4566:	91 e0       	ldi	r25, 0x01	; 1
    4568:	60 e0       	ldi	r22, 0x00	; 0
    456a:	70 e0       	ldi	r23, 0x00	; 0
    456c:	43 e0       	ldi	r20, 0x03	; 3
    456e:	50 e0       	ldi	r21, 0x00	; 0
    4570:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
glcd_puts("2) keybd/mouse",0,4);
    4574:	8b e3       	ldi	r24, 0x3B	; 59
    4576:	91 e0       	ldi	r25, 0x01	; 1
    4578:	60 e0       	ldi	r22, 0x00	; 0
    457a:	70 e0       	ldi	r23, 0x00	; 0
    457c:	44 e0       	ldi	r20, 0x04	; 4
    457e:	50 e0       	ldi	r21, 0x00	; 0
    4580:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
glcd_puts("3) ctrl device",0,5);
    4584:	8a e4       	ldi	r24, 0x4A	; 74
    4586:	91 e0       	ldi	r25, 0x01	; 1
    4588:	60 e0       	ldi	r22, 0x00	; 0
    458a:	70 e0       	ldi	r23, 0x00	; 0
    458c:	45 e0       	ldi	r20, 0x05	; 5
    458e:	50 e0       	ldi	r21, 0x00	; 0
    4590:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
glcd_puts("4) ctrl robot",0,6);
    4594:	89 e5       	ldi	r24, 0x59	; 89
    4596:	91 e0       	ldi	r25, 0x01	; 1
    4598:	60 e0       	ldi	r22, 0x00	; 0
    459a:	70 e0       	ldi	r23, 0x00	; 0
    459c:	46 e0       	ldi	r20, 0x06	; 6
    459e:	50 e0       	ldi	r21, 0x00	; 0
    45a0:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
//glcd_puts("5) train unit",0,7);
}
    45a4:	08 95       	ret

000045a6 <user_ch>:

}

void user_ch()//user select screen
{
glcd_puts("SELECT USER ",0,0);
    45a6:	87 e6       	ldi	r24, 0x67	; 103
    45a8:	91 e0       	ldi	r25, 0x01	; 1
    45aa:	60 e0       	ldi	r22, 0x00	; 0
    45ac:	70 e0       	ldi	r23, 0x00	; 0
    45ae:	40 e0       	ldi	r20, 0x00	; 0
    45b0:	50 e0       	ldi	r21, 0x00	; 0
    45b2:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
glcd_puts("================",0,1);
    45b6:	89 ed       	ldi	r24, 0xD9	; 217
    45b8:	90 e0       	ldi	r25, 0x00	; 0
    45ba:	60 e0       	ldi	r22, 0x00	; 0
    45bc:	70 e0       	ldi	r23, 0x00	; 0
    45be:	41 e0       	ldi	r20, 0x01	; 1
    45c0:	50 e0       	ldi	r21, 0x00	; 0
    45c2:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
glcd_puts("1) ANIRUDDH",0,3);
    45c6:	84 e7       	ldi	r24, 0x74	; 116
    45c8:	91 e0       	ldi	r25, 0x01	; 1
    45ca:	60 e0       	ldi	r22, 0x00	; 0
    45cc:	70 e0       	ldi	r23, 0x00	; 0
    45ce:	43 e0       	ldi	r20, 0x03	; 3
    45d0:	50 e0       	ldi	r21, 0x00	; 0
    45d2:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
glcd_puts("2) SIDDESH ",0,4);
    45d6:	80 e8       	ldi	r24, 0x80	; 128
    45d8:	91 e0       	ldi	r25, 0x01	; 1
    45da:	60 e0       	ldi	r22, 0x00	; 0
    45dc:	70 e0       	ldi	r23, 0x00	; 0
    45de:	44 e0       	ldi	r20, 0x04	; 4
    45e0:	50 e0       	ldi	r21, 0x00	; 0
    45e2:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
glcd_puts("3) SHAWN   ",0,5);
    45e6:	8c e8       	ldi	r24, 0x8C	; 140
    45e8:	91 e0       	ldi	r25, 0x01	; 1
    45ea:	60 e0       	ldi	r22, 0x00	; 0
    45ec:	70 e0       	ldi	r23, 0x00	; 0
    45ee:	45 e0       	ldi	r20, 0x05	; 5
    45f0:	50 e0       	ldi	r21, 0x00	; 0
    45f2:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
}
    45f6:	08 95       	ret

000045f8 <welcome>:
glcd_puts(disp,0,1);
}


void welcome()//welcome screen and animation display
{
    45f8:	cf 93       	push	r28
    45fa:	df 93       	push	r29
    45fc:	80 e1       	ldi	r24, 0x10	; 16
    45fe:	97 e2       	ldi	r25, 0x27	; 39
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4600:	20 e9       	ldi	r18, 0x90	; 144
    4602:	31 e0       	ldi	r19, 0x01	; 1
    4604:	f9 01       	movw	r30, r18
    4606:	31 97       	sbiw	r30, 0x01	; 1
    4608:	f1 f7       	brne	.-4      	; 0x4606 <welcome+0xe>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    460a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    460c:	d9 f7       	brne	.-10     	; 0x4604 <welcome+0xc>
_delay_ms(1000);
vertical_change(hand6,1);
    460e:	84 e5       	ldi	r24, 0x54	; 84
    4610:	98 e0       	ldi	r25, 0x08	; 8
    4612:	61 e0       	ldi	r22, 0x01	; 1
    4614:	0e 94 da 14 	call	0x29b4	; 0x29b4 <vertical_change>
    4618:	80 e1       	ldi	r24, 0x10	; 16
    461a:	97 e2       	ldi	r25, 0x27	; 39
    461c:	20 e9       	ldi	r18, 0x90	; 144
    461e:	31 e0       	ldi	r19, 0x01	; 1
    4620:	f9 01       	movw	r30, r18
    4622:	31 97       	sbiw	r30, 0x01	; 1
    4624:	f1 f7       	brne	.-4      	; 0x4622 <welcome+0x2a>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4626:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4628:	d9 f7       	brne	.-10     	; 0x4620 <welcome+0x28>
_delay_ms(1000);
vertical_change(hand1,1);
    462a:	84 e5       	ldi	r24, 0x54	; 84
    462c:	9c e0       	ldi	r25, 0x0C	; 12
    462e:	61 e0       	ldi	r22, 0x01	; 1
    4630:	0e 94 da 14 	call	0x29b4	; 0x29b4 <vertical_change>
for(b=0;b<3;b++)
    4634:	10 92 71 04 	sts	0x0471, r1
    4638:	c0 e9       	ldi	r28, 0x90	; 144
    463a:	d1 e0       	ldi	r29, 0x01	; 1
    463c:	73 c0       	rjmp	.+230    	; 0x4724 <welcome+0x12c>
{
bmp_disp(hand1);
    463e:	84 e5       	ldi	r24, 0x54	; 84
    4640:	9c e0       	ldi	r25, 0x0C	; 12
    4642:	0e 94 42 14 	call	0x2884	; 0x2884 <bmp_disp>
    4646:	8c ed       	ldi	r24, 0xDC	; 220
    4648:	95 e0       	ldi	r25, 0x05	; 5
    464a:	fe 01       	movw	r30, r28
    464c:	31 97       	sbiw	r30, 0x01	; 1
    464e:	f1 f7       	brne	.-4      	; 0x464c <welcome+0x54>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4650:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4652:	d9 f7       	brne	.-10     	; 0x464a <welcome+0x52>
_delay_ms(ani_delay);
bmp_disp(hand2);
    4654:	84 e5       	ldi	r24, 0x54	; 84
    4656:	90 e1       	ldi	r25, 0x10	; 16
    4658:	0e 94 42 14 	call	0x2884	; 0x2884 <bmp_disp>
    465c:	8c ed       	ldi	r24, 0xDC	; 220
    465e:	95 e0       	ldi	r25, 0x05	; 5
    4660:	fe 01       	movw	r30, r28
    4662:	31 97       	sbiw	r30, 0x01	; 1
    4664:	f1 f7       	brne	.-4      	; 0x4662 <welcome+0x6a>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4666:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4668:	d9 f7       	brne	.-10     	; 0x4660 <welcome+0x68>
_delay_ms(ani_delay);
bmp_disp(hand3);
    466a:	84 e5       	ldi	r24, 0x54	; 84
    466c:	94 e1       	ldi	r25, 0x14	; 20
    466e:	0e 94 42 14 	call	0x2884	; 0x2884 <bmp_disp>
    4672:	8c ed       	ldi	r24, 0xDC	; 220
    4674:	95 e0       	ldi	r25, 0x05	; 5
    4676:	fe 01       	movw	r30, r28
    4678:	31 97       	sbiw	r30, 0x01	; 1
    467a:	f1 f7       	brne	.-4      	; 0x4678 <welcome+0x80>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    467c:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    467e:	d9 f7       	brne	.-10     	; 0x4676 <welcome+0x7e>
_delay_ms(ani_delay);
bmp_disp(hand4);
    4680:	84 e5       	ldi	r24, 0x54	; 84
    4682:	98 e1       	ldi	r25, 0x18	; 24
    4684:	0e 94 42 14 	call	0x2884	; 0x2884 <bmp_disp>
    4688:	8c ed       	ldi	r24, 0xDC	; 220
    468a:	95 e0       	ldi	r25, 0x05	; 5
    468c:	fe 01       	movw	r30, r28
    468e:	31 97       	sbiw	r30, 0x01	; 1
    4690:	f1 f7       	brne	.-4      	; 0x468e <welcome+0x96>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4692:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4694:	d9 f7       	brne	.-10     	; 0x468c <welcome+0x94>
_delay_ms(ani_delay);
bmp_disp(hand5);
    4696:	84 e5       	ldi	r24, 0x54	; 84
    4698:	9c e1       	ldi	r25, 0x1C	; 28
    469a:	0e 94 42 14 	call	0x2884	; 0x2884 <bmp_disp>
    469e:	8c ed       	ldi	r24, 0xDC	; 220
    46a0:	95 e0       	ldi	r25, 0x05	; 5
    46a2:	fe 01       	movw	r30, r28
    46a4:	31 97       	sbiw	r30, 0x01	; 1
    46a6:	f1 f7       	brne	.-4      	; 0x46a4 <welcome+0xac>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    46a8:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    46aa:	d9 f7       	brne	.-10     	; 0x46a2 <welcome+0xaa>
_delay_ms(ani_delay);
bmp_disp(hand6);
    46ac:	84 e5       	ldi	r24, 0x54	; 84
    46ae:	98 e0       	ldi	r25, 0x08	; 8
    46b0:	0e 94 42 14 	call	0x2884	; 0x2884 <bmp_disp>
    46b4:	8c ed       	ldi	r24, 0xDC	; 220
    46b6:	95 e0       	ldi	r25, 0x05	; 5
    46b8:	fe 01       	movw	r30, r28
    46ba:	31 97       	sbiw	r30, 0x01	; 1
    46bc:	f1 f7       	brne	.-4      	; 0x46ba <welcome+0xc2>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    46be:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    46c0:	d9 f7       	brne	.-10     	; 0x46b8 <welcome+0xc0>
_delay_ms(ani_delay);
bmp_disp(hand5);
    46c2:	84 e5       	ldi	r24, 0x54	; 84
    46c4:	9c e1       	ldi	r25, 0x1C	; 28
    46c6:	0e 94 42 14 	call	0x2884	; 0x2884 <bmp_disp>
    46ca:	8c ed       	ldi	r24, 0xDC	; 220
    46cc:	95 e0       	ldi	r25, 0x05	; 5
    46ce:	fe 01       	movw	r30, r28
    46d0:	31 97       	sbiw	r30, 0x01	; 1
    46d2:	f1 f7       	brne	.-4      	; 0x46d0 <welcome+0xd8>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    46d4:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    46d6:	d9 f7       	brne	.-10     	; 0x46ce <welcome+0xd6>
_delay_ms(ani_delay);
bmp_disp(hand4);
    46d8:	84 e5       	ldi	r24, 0x54	; 84
    46da:	98 e1       	ldi	r25, 0x18	; 24
    46dc:	0e 94 42 14 	call	0x2884	; 0x2884 <bmp_disp>
    46e0:	8c ed       	ldi	r24, 0xDC	; 220
    46e2:	95 e0       	ldi	r25, 0x05	; 5
    46e4:	fe 01       	movw	r30, r28
    46e6:	31 97       	sbiw	r30, 0x01	; 1
    46e8:	f1 f7       	brne	.-4      	; 0x46e6 <welcome+0xee>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    46ea:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    46ec:	d9 f7       	brne	.-10     	; 0x46e4 <welcome+0xec>
_delay_ms(ani_delay);
bmp_disp(hand3);
    46ee:	84 e5       	ldi	r24, 0x54	; 84
    46f0:	94 e1       	ldi	r25, 0x14	; 20
    46f2:	0e 94 42 14 	call	0x2884	; 0x2884 <bmp_disp>
    46f6:	8c ed       	ldi	r24, 0xDC	; 220
    46f8:	95 e0       	ldi	r25, 0x05	; 5
    46fa:	fe 01       	movw	r30, r28
    46fc:	31 97       	sbiw	r30, 0x01	; 1
    46fe:	f1 f7       	brne	.-4      	; 0x46fc <welcome+0x104>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4700:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4702:	d9 f7       	brne	.-10     	; 0x46fa <welcome+0x102>
_delay_ms(ani_delay);
bmp_disp(hand2);
    4704:	84 e5       	ldi	r24, 0x54	; 84
    4706:	90 e1       	ldi	r25, 0x10	; 16
    4708:	0e 94 42 14 	call	0x2884	; 0x2884 <bmp_disp>
    470c:	8c ed       	ldi	r24, 0xDC	; 220
    470e:	95 e0       	ldi	r25, 0x05	; 5
    4710:	fe 01       	movw	r30, r28
    4712:	31 97       	sbiw	r30, 0x01	; 1
    4714:	f1 f7       	brne	.-4      	; 0x4712 <welcome+0x11a>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4716:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4718:	d9 f7       	brne	.-10     	; 0x4710 <welcome+0x118>
{
_delay_ms(1000);
vertical_change(hand6,1);
_delay_ms(1000);
vertical_change(hand1,1);
for(b=0;b<3;b++)
    471a:	80 91 71 04 	lds	r24, 0x0471
    471e:	8f 5f       	subi	r24, 0xFF	; 255
    4720:	80 93 71 04 	sts	0x0471, r24
    4724:	80 91 71 04 	lds	r24, 0x0471
    4728:	83 30       	cpi	r24, 0x03	; 3
    472a:	08 f4       	brcc	.+2      	; 0x472e <welcome+0x136>
    472c:	88 cf       	rjmp	.-240    	; 0x463e <welcome+0x46>
_delay_ms(ani_delay);
bmp_disp(hand2);
_delay_ms(ani_delay);
}

glcd_vclear(1);
    472e:	81 e0       	ldi	r24, 0x01	; 1
    4730:	0e 94 94 15 	call	0x2b28	; 0x2b28 <glcd_vclear>
horizontal_change(hand6,1);
    4734:	84 e5       	ldi	r24, 0x54	; 84
    4736:	98 e0       	ldi	r25, 0x08	; 8
    4738:	61 e0       	ldi	r22, 0x01	; 1
    473a:	0e 94 82 14 	call	0x2904	; 0x2904 <horizontal_change>
    473e:	80 e1       	ldi	r24, 0x10	; 16
    4740:	97 e2       	ldi	r25, 0x27	; 39
    4742:	20 e9       	ldi	r18, 0x90	; 144
    4744:	31 e0       	ldi	r19, 0x01	; 1
    4746:	f9 01       	movw	r30, r18
    4748:	31 97       	sbiw	r30, 0x01	; 1
    474a:	f1 f7       	brne	.-4      	; 0x4748 <welcome+0x150>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    474c:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    474e:	d9 f7       	brne	.-10     	; 0x4746 <welcome+0x14e>
_delay_ms(1000);
horizontal_change(hand6,0);
    4750:	84 e5       	ldi	r24, 0x54	; 84
    4752:	98 e0       	ldi	r25, 0x08	; 8
    4754:	60 e0       	ldi	r22, 0x00	; 0
    4756:	0e 94 82 14 	call	0x2904	; 0x2904 <horizontal_change>
    475a:	80 e1       	ldi	r24, 0x10	; 16
    475c:	97 e2       	ldi	r25, 0x27	; 39
    475e:	20 e9       	ldi	r18, 0x90	; 144
    4760:	31 e0       	ldi	r19, 0x01	; 1
    4762:	f9 01       	movw	r30, r18
    4764:	31 97       	sbiw	r30, 0x01	; 1
    4766:	f1 f7       	brne	.-4      	; 0x4764 <welcome+0x16c>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4768:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    476a:	d9 f7       	brne	.-10     	; 0x4762 <welcome+0x16a>
_delay_ms(1000);
vertical_change(author,1);
    476c:	84 e5       	ldi	r24, 0x54	; 84
    476e:	90 e2       	ldi	r25, 0x20	; 32
    4770:	61 e0       	ldi	r22, 0x01	; 1
    4772:	0e 94 da 14 	call	0x29b4	; 0x29b4 <vertical_change>
    4776:	88 ea       	ldi	r24, 0xA8	; 168
    4778:	91 e6       	ldi	r25, 0x61	; 97
    477a:	20 e9       	ldi	r18, 0x90	; 144
    477c:	31 e0       	ldi	r19, 0x01	; 1
    477e:	f9 01       	movw	r30, r18
    4780:	31 97       	sbiw	r30, 0x01	; 1
    4782:	f1 f7       	brne	.-4      	; 0x4780 <welcome+0x188>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4784:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4786:	d9 f7       	brne	.-10     	; 0x477e <welcome+0x186>
_delay_ms(2500);
glcd_vclear(1);
    4788:	81 e0       	ldi	r24, 0x01	; 1
    478a:	0e 94 94 15 	call	0x2b28	; 0x2b28 <glcd_vclear>
    478e:	80 e1       	ldi	r24, 0x10	; 16
    4790:	97 e2       	ldi	r25, 0x27	; 39
    4792:	20 e9       	ldi	r18, 0x90	; 144
    4794:	31 e0       	ldi	r19, 0x01	; 1
    4796:	f9 01       	movw	r30, r18
    4798:	31 97       	sbiw	r30, 0x01	; 1
    479a:	f1 f7       	brne	.-4      	; 0x4798 <welcome+0x1a0>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    479c:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    479e:	d9 f7       	brne	.-10     	; 0x4796 <welcome+0x19e>
_delay_ms(1000);
glcd_clear();
    47a0:	0e 94 ee 12 	call	0x25dc	; 0x25dc <glcd_clear>
glcd_puts("****WELCOME!****",0,3);
    47a4:	88 e9       	ldi	r24, 0x98	; 152
    47a6:	91 e0       	ldi	r25, 0x01	; 1
    47a8:	60 e0       	ldi	r22, 0x00	; 0
    47aa:	70 e0       	ldi	r23, 0x00	; 0
    47ac:	43 e0       	ldi	r20, 0x03	; 3
    47ae:	50 e0       	ldi	r21, 0x00	; 0
    47b0:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
glcd_puts("SWITCH ON THE   TRANSMITTER...",0,5);
    47b4:	89 ea       	ldi	r24, 0xA9	; 169
    47b6:	91 e0       	ldi	r25, 0x01	; 1
    47b8:	60 e0       	ldi	r22, 0x00	; 0
    47ba:	70 e0       	ldi	r23, 0x00	; 0
    47bc:	45 e0       	ldi	r20, 0x05	; 5
    47be:	50 e0       	ldi	r21, 0x00	; 0
    47c0:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>

}
    47c4:	df 91       	pop	r29
    47c6:	cf 91       	pop	r28
    47c8:	08 95       	ret

000047ca <check_char>:

void check_char()//checks to see if the end of screen is reached and shifts a line upward
{

uint8_t i;
if(char_cnt==max_char)
    47ca:	80 91 69 04 	lds	r24, 0x0469
    47ce:	80 37       	cpi	r24, 0x70	; 112
    47d0:	81 f4       	brne	.+32     	; 0x47f2 <check_char+0x28>
    47d2:	ef ec       	ldi	r30, 0xCF	; 207
    47d4:	f4 e0       	ldi	r31, 0x04	; 4
{
for(i=0;i<(max_char-16);i++) {disp[i]=disp[i+16];}
    47d6:	80 89       	ldd	r24, Z+16	; 0x10
    47d8:	81 93       	st	Z+, r24
    47da:	85 e0       	ldi	r24, 0x05	; 5
    47dc:	ef 32       	cpi	r30, 0x2F	; 47
    47de:	f8 07       	cpc	r31, r24
    47e0:	d1 f7       	brne	.-12     	; 0x47d6 <check_char+0xc>
for(i=96;i<max_char;i++){disp[i]=0x00;}
    47e2:	11 92       	st	Z+, r1
    47e4:	85 e0       	ldi	r24, 0x05	; 5
    47e6:	ef 33       	cpi	r30, 0x3F	; 63
    47e8:	f8 07       	cpc	r31, r24
    47ea:	d9 f7       	brne	.-10     	; 0x47e2 <check_char+0x18>
char_cnt=(max_char-16);
    47ec:	80 e6       	ldi	r24, 0x60	; 96
    47ee:	80 93 69 04 	sts	0x0469, r24
}
glcd_puts("                ",0,7);
    47f2:	88 ec       	ldi	r24, 0xC8	; 200
    47f4:	91 e0       	ldi	r25, 0x01	; 1
    47f6:	60 e0       	ldi	r22, 0x00	; 0
    47f8:	70 e0       	ldi	r23, 0x00	; 0
    47fa:	47 e0       	ldi	r20, 0x07	; 7
    47fc:	50 e0       	ldi	r21, 0x00	; 0
    47fe:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
glcd_puts(disp,0,1);
    4802:	8f ec       	ldi	r24, 0xCF	; 207
    4804:	94 e0       	ldi	r25, 0x04	; 4
    4806:	60 e0       	ldi	r22, 0x00	; 0
    4808:	70 e0       	ldi	r23, 0x00	; 0
    480a:	41 e0       	ldi	r20, 0x01	; 1
    480c:	50 e0       	ldi	r21, 0x00	; 0
    480e:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
}
    4812:	08 95       	ret

00004814 <main>:


uint8_t alp_cnt;

int main()
{
    4814:	1f 93       	push	r17
    4816:	cf 93       	push	r28
    4818:	df 93       	push	r29


DDRC=0xFF;
    481a:	8f ef       	ldi	r24, 0xFF	; 255
    481c:	84 bb       	out	0x14, r24	; 20
DDRD=0xF8;
    481e:	88 ef       	ldi	r24, 0xF8	; 248
    4820:	81 bb       	out	0x11, r24	; 17
DDRA=0b01111111;
    4822:	8f e7       	ldi	r24, 0x7F	; 127
    4824:	8a bb       	out	0x1a, r24	; 26

uart_init( UART_BAUD_SELECT(UART_BAUD_RATE,F_CPU) ); 
    4826:	87 e6       	ldi	r24, 0x67	; 103
    4828:	90 e0       	ldi	r25, 0x00	; 0
    482a:	0e 94 c6 2c 	call	0x598c	; 0x598c <uart_init>
sei();
    482e:	78 94       	sei

glcd_on();
    4830:	0e 94 52 12 	call	0x24a4	; 0x24a4 <glcd_on>
glcd_clear();
    4834:	0e 94 ee 12 	call	0x25dc	; 0x25dc <glcd_clear>
welcome();
    4838:	0e 94 fc 22 	call	0x45f8	; 0x45f8 <welcome>
    483c:	ef ec       	ldi	r30, 0xCF	; 207
    483e:	f4 e0       	ldi	r31, 0x04	; 4


void init_disp()
{
uint8_t cntr;
for(cntr=0;cntr<max_char;cntr++){disp[cntr]=0;}
    4840:	11 92       	st	Z+, r1
    4842:	85 e0       	ldi	r24, 0x05	; 5
    4844:	ef 33       	cpi	r30, 0x3F	; 63
    4846:	f8 07       	cpc	r31, r24
    4848:	d9 f7       	brne	.-10     	; 0x4840 <main+0x2c>
glcd_on();
glcd_clear();
welcome();

init_disp();
cc2500_init();
    484a:	0e 94 09 19 	call	0x3212	; 0x3212 <cc2500_init>
    484e:	88 ee       	ldi	r24, 0xE8	; 232
    4850:	93 e0       	ldi	r25, 0x03	; 3
    4852:	20 e9       	ldi	r18, 0x90	; 144
    4854:	31 e0       	ldi	r19, 0x01	; 1
    4856:	f9 01       	movw	r30, r18
    4858:	31 97       	sbiw	r30, 0x01	; 1
    485a:	f1 f7       	brne	.-4      	; 0x4858 <main+0x44>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    485c:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    485e:	d9 f7       	brne	.-10     	; 0x4856 <main+0x42>
_delay_ms(100);
wake();
    4860:	0e 94 26 19 	call	0x324c	; 0x324c <wake>
    4864:	c0 e9       	ldi	r28, 0x90	; 144
    4866:	d1 e0       	ldi	r29, 0x01	; 1



while(1)
{
while(data_rx()==0);
    4868:	0e 94 e0 18 	call	0x31c0	; 0x31c0 <data_rx>
    486c:	88 23       	and	r24, r24
    486e:	e1 f3       	breq	.-8      	; 0x4868 <main+0x54>
cmd=rxBuffer[0];
    4870:	80 91 be 04 	lds	r24, 0x04BE
    4874:	80 93 68 04 	sts	0x0468, r24

if(cmd==0x0C) //character display
    4878:	8c 30       	cpi	r24, 0x0C	; 12
    487a:	39 f5       	brne	.+78     	; 0x48ca <main+0xb6>
{
glcd_clear();
    487c:	0e 94 ee 12 	call	0x25dc	; 0x25dc <glcd_clear>
read_batt();
    4880:	0e 94 49 19 	call	0x3292	; 0x3292 <read_batt>
glcd_puts("CHARACTER  ",0,0);
    4884:	89 ed       	ldi	r24, 0xD9	; 217
    4886:	91 e0       	ldi	r25, 0x01	; 1
    4888:	60 e0       	ldi	r22, 0x00	; 0
    488a:	70 e0       	ldi	r23, 0x00	; 0
    488c:	40 e0       	ldi	r20, 0x00	; 0
    488e:	50 e0       	ldi	r21, 0x00	; 0
    4890:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
glcd_puts(disp,0,1);
    4894:	8f ec       	ldi	r24, 0xCF	; 207
    4896:	94 e0       	ldi	r25, 0x04	; 4
    4898:	60 e0       	ldi	r22, 0x00	; 0
    489a:	70 e0       	ldi	r23, 0x00	; 0
    489c:	41 e0       	ldi	r20, 0x01	; 1
    489e:	50 e0       	ldi	r21, 0x00	; 0
    48a0:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
disp[char_cnt]=rxBuffer[1];
    48a4:	80 91 bf 04 	lds	r24, 0x04BF
    48a8:	e0 91 69 04 	lds	r30, 0x0469
    48ac:	f0 e0       	ldi	r31, 0x00	; 0
    48ae:	e1 53       	subi	r30, 0x31	; 49
    48b0:	fb 4f       	sbci	r31, 0xFB	; 251
    48b2:	80 83       	st	Z, r24
c=rxBuffer[1];
    48b4:	80 93 bd 04 	sts	0x04BD, r24
uart_putc(c);
    48b8:	0e 94 f2 2c 	call	0x59e4	; 0x59e4 <uart_putc>
char_cnt++;
    48bc:	80 91 69 04 	lds	r24, 0x0469
    48c0:	8f 5f       	subi	r24, 0xFF	; 255
    48c2:	80 93 69 04 	sts	0x0469, r24
check_char();
    48c6:	0e 94 e5 23 	call	0x47ca	; 0x47ca <check_char>
}

if(cmd==0x1C) //number display
    48ca:	80 91 68 04 	lds	r24, 0x0468
    48ce:	8c 31       	cpi	r24, 0x1C	; 28
    48d0:	81 f5       	brne	.+96     	; 0x4932 <main+0x11e>
{
glcd_clear();
    48d2:	0e 94 ee 12 	call	0x25dc	; 0x25dc <glcd_clear>
read_batt();
    48d6:	0e 94 49 19 	call	0x3292	; 0x3292 <read_batt>
glcd_puts("NUMBER     ",0,0);
    48da:	85 ee       	ldi	r24, 0xE5	; 229
    48dc:	91 e0       	ldi	r25, 0x01	; 1
    48de:	60 e0       	ldi	r22, 0x00	; 0
    48e0:	70 e0       	ldi	r23, 0x00	; 0
    48e2:	40 e0       	ldi	r20, 0x00	; 0
    48e4:	50 e0       	ldi	r21, 0x00	; 0
    48e6:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
glcd_puts(disp,0,1);
    48ea:	8f ec       	ldi	r24, 0xCF	; 207
    48ec:	94 e0       	ldi	r25, 0x04	; 4
    48ee:	60 e0       	ldi	r22, 0x00	; 0
    48f0:	70 e0       	ldi	r23, 0x00	; 0
    48f2:	41 e0       	ldi	r20, 0x01	; 1
    48f4:	50 e0       	ldi	r21, 0x00	; 0
    48f6:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
if(rxBuffer[1]=='*'){disp[char_cnt]='.';c='.';}
    48fa:	80 91 bf 04 	lds	r24, 0x04BF
    48fe:	e0 91 69 04 	lds	r30, 0x0469
    4902:	8a 32       	cpi	r24, 0x2A	; 42
    4904:	29 f4       	brne	.+10     	; 0x4910 <main+0xfc>
    4906:	f0 e0       	ldi	r31, 0x00	; 0
    4908:	e1 53       	subi	r30, 0x31	; 49
    490a:	fb 4f       	sbci	r31, 0xFB	; 251
    490c:	8e e2       	ldi	r24, 0x2E	; 46
    490e:	03 c0       	rjmp	.+6      	; 0x4916 <main+0x102>
else{disp[char_cnt]=rxBuffer[1];c=rxBuffer[1];}
    4910:	f0 e0       	ldi	r31, 0x00	; 0
    4912:	e1 53       	subi	r30, 0x31	; 49
    4914:	fb 4f       	sbci	r31, 0xFB	; 251
    4916:	80 83       	st	Z, r24
    4918:	80 93 bd 04 	sts	0x04BD, r24
uart_putc(c);
    491c:	80 91 bd 04 	lds	r24, 0x04BD
    4920:	0e 94 f2 2c 	call	0x59e4	; 0x59e4 <uart_putc>
char_cnt++;
    4924:	80 91 69 04 	lds	r24, 0x0469
    4928:	8f 5f       	subi	r24, 0xFF	; 255
    492a:	80 93 69 04 	sts	0x0469, r24
check_char();
    492e:	0e 94 e5 23 	call	0x47ca	; 0x47ca <check_char>
}

if(cmd==0x2C) //special symbols
    4932:	80 91 68 04 	lds	r24, 0x0468
    4936:	8c 32       	cpi	r24, 0x2C	; 44
    4938:	39 f5       	brne	.+78     	; 0x4988 <main+0x174>
{
glcd_clear();
    493a:	0e 94 ee 12 	call	0x25dc	; 0x25dc <glcd_clear>
read_batt();
    493e:	0e 94 49 19 	call	0x3292	; 0x3292 <read_batt>
glcd_puts("SP SYMBOL  ",0,0);
    4942:	81 ef       	ldi	r24, 0xF1	; 241
    4944:	91 e0       	ldi	r25, 0x01	; 1
    4946:	60 e0       	ldi	r22, 0x00	; 0
    4948:	70 e0       	ldi	r23, 0x00	; 0
    494a:	40 e0       	ldi	r20, 0x00	; 0
    494c:	50 e0       	ldi	r21, 0x00	; 0
    494e:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
glcd_puts(disp,0,1);
    4952:	8f ec       	ldi	r24, 0xCF	; 207
    4954:	94 e0       	ldi	r25, 0x04	; 4
    4956:	60 e0       	ldi	r22, 0x00	; 0
    4958:	70 e0       	ldi	r23, 0x00	; 0
    495a:	41 e0       	ldi	r20, 0x01	; 1
    495c:	50 e0       	ldi	r21, 0x00	; 0
    495e:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
disp[char_cnt]=rxBuffer[1];
    4962:	80 91 bf 04 	lds	r24, 0x04BF
    4966:	e0 91 69 04 	lds	r30, 0x0469
    496a:	f0 e0       	ldi	r31, 0x00	; 0
    496c:	e1 53       	subi	r30, 0x31	; 49
    496e:	fb 4f       	sbci	r31, 0xFB	; 251
    4970:	80 83       	st	Z, r24
c=rxBuffer[1];
    4972:	80 93 bd 04 	sts	0x04BD, r24
uart_putc(c);
    4976:	0e 94 f2 2c 	call	0x59e4	; 0x59e4 <uart_putc>
char_cnt++;
    497a:	80 91 69 04 	lds	r24, 0x0469
    497e:	8f 5f       	subi	r24, 0xFF	; 255
    4980:	80 93 69 04 	sts	0x0469, r24
check_char();
    4984:	0e 94 e5 23 	call	0x47ca	; 0x47ca <check_char>
}

if(cmd==0x0B) //backspace
    4988:	80 91 68 04 	lds	r24, 0x0468
    498c:	8b 30       	cpi	r24, 0x0B	; 11
    498e:	a9 f4       	brne	.+42     	; 0x49ba <main+0x1a6>
{
char_cnt--;
    4990:	e0 91 69 04 	lds	r30, 0x0469
    4994:	e1 50       	subi	r30, 0x01	; 1
    4996:	e0 93 69 04 	sts	0x0469, r30
disp[char_cnt]=32;
    499a:	f0 e0       	ldi	r31, 0x00	; 0
    499c:	e1 53       	subi	r30, 0x31	; 49
    499e:	fb 4f       	sbci	r31, 0xFB	; 251
    49a0:	80 e2       	ldi	r24, 0x20	; 32
    49a2:	80 83       	st	Z, r24
uart_putc(0x08);    // backspace control character
    49a4:	88 e0       	ldi	r24, 0x08	; 8
    49a6:	0e 94 f2 2c 	call	0x59e4	; 0x59e4 <uart_putc>
glcd_puts(disp,0,1);
    49aa:	8f ec       	ldi	r24, 0xCF	; 207
    49ac:	94 e0       	ldi	r25, 0x04	; 4
    49ae:	60 e0       	ldi	r22, 0x00	; 0
    49b0:	70 e0       	ldi	r23, 0x00	; 0
    49b2:	41 e0       	ldi	r20, 0x01	; 1
    49b4:	50 e0       	ldi	r21, 0x00	; 0
    49b6:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
}

if(cmd==0xAC) //clear screen
    49ba:	80 91 68 04 	lds	r24, 0x0468
    49be:	8c 3a       	cpi	r24, 0xAC	; 172
    49c0:	99 f4       	brne	.+38     	; 0x49e8 <main+0x1d4>
{
read_batt();
    49c2:	0e 94 49 19 	call	0x3292	; 0x3292 <read_batt>
    49c6:	ef ec       	ldi	r30, 0xCF	; 207
    49c8:	f4 e0       	ldi	r31, 0x04	; 4


void init_disp()
{
uint8_t cntr;
for(cntr=0;cntr<max_char;cntr++){disp[cntr]=0;}
    49ca:	11 92       	st	Z+, r1
    49cc:	85 e0       	ldi	r24, 0x05	; 5
    49ce:	ef 33       	cpi	r30, 0x3F	; 63
    49d0:	f8 07       	cpc	r31, r24
    49d2:	d9 f7       	brne	.-10     	; 0x49ca <main+0x1b6>

if(cmd==0xAC) //clear screen
{
read_batt();
init_disp();
glcd_puts(disp,0,1);
    49d4:	8f ec       	ldi	r24, 0xCF	; 207
    49d6:	94 e0       	ldi	r25, 0x04	; 4
    49d8:	60 e0       	ldi	r22, 0x00	; 0
    49da:	70 e0       	ldi	r23, 0x00	; 0
    49dc:	41 e0       	ldi	r20, 0x01	; 1
    49de:	50 e0       	ldi	r21, 0x00	; 0
    49e0:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
char_cnt=0;
    49e4:	10 92 69 04 	sts	0x0469, r1
}

if(cmd==0xFF)//display main menu
    49e8:	80 91 68 04 	lds	r24, 0x0468
    49ec:	8f 3f       	cpi	r24, 0xFF	; 255
    49ee:	31 f4       	brne	.+12     	; 0x49fc <main+0x1e8>
{
glcd_clear();
    49f0:	0e 94 ee 12 	call	0x25dc	; 0x25dc <glcd_clear>
read_batt();
    49f4:	0e 94 49 19 	call	0x3292	; 0x3292 <read_batt>
menu();
    49f8:	0e 94 a2 22 	call	0x4544	; 0x4544 <menu>
}

if(cmd==0x1F)//display main menu
    49fc:	80 91 68 04 	lds	r24, 0x0468
    4a00:	8f 31       	cpi	r24, 0x1F	; 31
    4a02:	31 f4       	brne	.+12     	; 0x4a10 <main+0x1fc>
{
glcd_clear();
    4a04:	0e 94 ee 12 	call	0x25dc	; 0x25dc <glcd_clear>
read_batt();
    4a08:	0e 94 49 19 	call	0x3292	; 0x3292 <read_batt>
submenu();
    4a0c:	0e 94 79 22 	call	0x44f2	; 0x44f2 <submenu>
}

if(cmd==0x2F)//display mouse menu
    4a10:	80 91 68 04 	lds	r24, 0x0468
    4a14:	8f 32       	cpi	r24, 0x2F	; 47
    4a16:	31 f4       	brne	.+12     	; 0x4a24 <main+0x210>
{
glcd_clear();
    4a18:	0e 94 ee 12 	call	0x25dc	; 0x25dc <glcd_clear>
read_batt();
    4a1c:	0e 94 49 19 	call	0x3292	; 0x3292 <read_batt>
mouse_menu();
    4a20:	0e 94 48 22 	call	0x4490	; 0x4490 <mouse_menu>
}

if(cmd==0xAA)//display USER CHOICE
    4a24:	80 91 68 04 	lds	r24, 0x0468
    4a28:	8a 3a       	cpi	r24, 0xAA	; 170
    4a2a:	31 f4       	brne	.+12     	; 0x4a38 <main+0x224>
{
glcd_clear();
    4a2c:	0e 94 ee 12 	call	0x25dc	; 0x25dc <glcd_clear>
read_batt();
    4a30:	0e 94 49 19 	call	0x3292	; 0x3292 <read_batt>
user_ch();
    4a34:	0e 94 d3 22 	call	0x45a6	; 0x45a6 <user_ch>
}

if(cmd==0xAF)// MAIN MENU response
    4a38:	80 91 68 04 	lds	r24, 0x0468
    4a3c:	8f 3a       	cpi	r24, 0xAF	; 175
    4a3e:	09 f0       	breq	.+2      	; 0x4a42 <main+0x22e>
    4a40:	6f c0       	rjmp	.+222    	; 0x4b20 <main+0x30c>
{
read_batt();
    4a42:	0e 94 49 19 	call	0x3292	; 0x3292 <read_batt>
inp=rxBuffer[1];
    4a46:	80 91 bf 04 	lds	r24, 0x04BF
    4a4a:	80 93 6a 04 	sts	0x046A, r24
switch(inp)
    4a4e:	82 30       	cpi	r24, 0x02	; 2
    4a50:	f1 f0       	breq	.+60     	; 0x4a8e <main+0x27a>
    4a52:	83 30       	cpi	r24, 0x03	; 3
    4a54:	20 f4       	brcc	.+8      	; 0x4a5e <main+0x24a>
    4a56:	81 30       	cpi	r24, 0x01	; 1
    4a58:	09 f0       	breq	.+2      	; 0x4a5c <main+0x248>
    4a5a:	62 c0       	rjmp	.+196    	; 0x4b20 <main+0x30c>
    4a5c:	06 c0       	rjmp	.+12     	; 0x4a6a <main+0x256>
    4a5e:	83 30       	cpi	r24, 0x03	; 3
    4a60:	51 f1       	breq	.+84     	; 0x4ab6 <main+0x2a2>
    4a62:	84 30       	cpi	r24, 0x04	; 4
    4a64:	09 f0       	breq	.+2      	; 0x4a68 <main+0x254>
    4a66:	5c c0       	rjmp	.+184    	; 0x4b20 <main+0x30c>
    4a68:	44 c0       	rjmp	.+136    	; 0x4af2 <main+0x2de>
{
case 1: glcd_clear();
    4a6a:	0e 94 ee 12 	call	0x25dc	; 0x25dc <glcd_clear>
        glcd_puts("Selected...      TEXT MODE",0,3);
    4a6e:	8d ef       	ldi	r24, 0xFD	; 253
    4a70:	91 e0       	ldi	r25, 0x01	; 1
    4a72:	60 e0       	ldi	r22, 0x00	; 0
    4a74:	70 e0       	ldi	r23, 0x00	; 0
    4a76:	43 e0       	ldi	r20, 0x03	; 3
    4a78:	50 e0       	ldi	r21, 0x00	; 0
    4a7a:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
    4a7e:	80 e1       	ldi	r24, 0x10	; 16
    4a80:	97 e2       	ldi	r25, 0x27	; 39
    4a82:	fe 01       	movw	r30, r28
    4a84:	31 97       	sbiw	r30, 0x01	; 1
    4a86:	f1 f7       	brne	.-4      	; 0x4a84 <main+0x270>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4a88:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4a8a:	d9 f7       	brne	.-10     	; 0x4a82 <main+0x26e>
    4a8c:	11 c0       	rjmp	.+34     	; 0x4ab0 <main+0x29c>
		_delay_ms(1000);
		glcd_clear();
        break;

case 2:glcd_clear();
    4a8e:	0e 94 ee 12 	call	0x25dc	; 0x25dc <glcd_clear>
        glcd_puts("Selected...      MOUSE/KEYBOARD   MODE",0,3);
    4a92:	88 e1       	ldi	r24, 0x18	; 24
    4a94:	92 e0       	ldi	r25, 0x02	; 2
    4a96:	60 e0       	ldi	r22, 0x00	; 0
    4a98:	70 e0       	ldi	r23, 0x00	; 0
    4a9a:	43 e0       	ldi	r20, 0x03	; 3
    4a9c:	50 e0       	ldi	r21, 0x00	; 0
    4a9e:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
    4aa2:	80 e1       	ldi	r24, 0x10	; 16
    4aa4:	97 e2       	ldi	r25, 0x27	; 39
    4aa6:	fe 01       	movw	r30, r28
    4aa8:	31 97       	sbiw	r30, 0x01	; 1
    4aaa:	f1 f7       	brne	.-4      	; 0x4aa8 <main+0x294>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4aac:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4aae:	d9 f7       	brne	.-10     	; 0x4aa6 <main+0x292>
		_delay_ms(1000);
		glcd_clear();
    4ab0:	0e 94 ee 12 	call	0x25dc	; 0x25dc <glcd_clear>
    4ab4:	35 c0       	rjmp	.+106    	; 0x4b20 <main+0x30c>
       break;

case 3: glcd_clear();
    4ab6:	0e 94 ee 12 	call	0x25dc	; 0x25dc <glcd_clear>
        glcd_puts("Selected...      DEVICE CONTROL   MODE",0,3);
    4aba:	8f e3       	ldi	r24, 0x3F	; 63
    4abc:	92 e0       	ldi	r25, 0x02	; 2
    4abe:	60 e0       	ldi	r22, 0x00	; 0
    4ac0:	70 e0       	ldi	r23, 0x00	; 0
    4ac2:	43 e0       	ldi	r20, 0x03	; 3
    4ac4:	50 e0       	ldi	r21, 0x00	; 0
    4ac6:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
    4aca:	80 e1       	ldi	r24, 0x10	; 16
    4acc:	97 e2       	ldi	r25, 0x27	; 39
    4ace:	fe 01       	movw	r30, r28
    4ad0:	31 97       	sbiw	r30, 0x01	; 1
    4ad2:	f1 f7       	brne	.-4      	; 0x4ad0 <main+0x2bc>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4ad4:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4ad6:	d9 f7       	brne	.-10     	; 0x4ace <main+0x2ba>
		_delay_ms(1000);
		glcd_clear();
    4ad8:	0e 94 ee 12 	call	0x25dc	; 0x25dc <glcd_clear>
		glcd_puts("DEVICE CTRL",0,0);
    4adc:	8b ea       	ldi	r24, 0xAB	; 171
    4ade:	90 e0       	ldi	r25, 0x00	; 0
    4ae0:	60 e0       	ldi	r22, 0x00	; 0
    4ae2:	70 e0       	ldi	r23, 0x00	; 0
    4ae4:	40 e0       	ldi	r20, 0x00	; 0
    4ae6:	50 e0       	ldi	r21, 0x00	; 0
    4ae8:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
		dev_status();
    4aec:	0e 94 e4 21 	call	0x43c8	; 0x43c8 <dev_status>
    4af0:	17 c0       	rjmp	.+46     	; 0x4b20 <main+0x30c>
        break;

case 4:glcd_clear();
    4af2:	0e 94 ee 12 	call	0x25dc	; 0x25dc <glcd_clear>
        glcd_puts("Selected...      ROBOT CONTROL    MODE",0,3);
    4af6:	86 e6       	ldi	r24, 0x66	; 102
    4af8:	92 e0       	ldi	r25, 0x02	; 2
    4afa:	60 e0       	ldi	r22, 0x00	; 0
    4afc:	70 e0       	ldi	r23, 0x00	; 0
    4afe:	43 e0       	ldi	r20, 0x03	; 3
    4b00:	50 e0       	ldi	r21, 0x00	; 0
    4b02:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
    4b06:	80 e1       	ldi	r24, 0x10	; 16
    4b08:	97 e2       	ldi	r25, 0x27	; 39
    4b0a:	fe 01       	movw	r30, r28
    4b0c:	31 97       	sbiw	r30, 0x01	; 1
    4b0e:	f1 f7       	brne	.-4      	; 0x4b0c <main+0x2f8>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4b10:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4b12:	d9 f7       	brne	.-10     	; 0x4b0a <main+0x2f6>
		_delay_ms(1000);
		glcd_clear();
    4b14:	0e 94 ee 12 	call	0x25dc	; 0x25dc <glcd_clear>
		refresh_robo_screen();
    4b18:	0e 94 bb 21 	call	0x4376	; 0x4376 <refresh_robo_screen>
		read_batt();
    4b1c:	0e 94 49 19 	call	0x3292	; 0x3292 <read_batt>


}


if(cmd==0xAE)// USER SETTINGS response
    4b20:	80 91 68 04 	lds	r24, 0x0468
    4b24:	8e 3a       	cpi	r24, 0xAE	; 174
    4b26:	09 f0       	breq	.+2      	; 0x4b2a <main+0x316>
    4b28:	5c c0       	rjmp	.+184    	; 0x4be2 <main+0x3ce>
{
read_batt();
    4b2a:	0e 94 49 19 	call	0x3292	; 0x3292 <read_batt>
inp=rxBuffer[1];
    4b2e:	80 91 bf 04 	lds	r24, 0x04BF
    4b32:	80 93 6a 04 	sts	0x046A, r24

switch(inp)
    4b36:	82 30       	cpi	r24, 0x02	; 2
    4b38:	f9 f0       	breq	.+62     	; 0x4b78 <main+0x364>
    4b3a:	83 30       	cpi	r24, 0x03	; 3
    4b3c:	b9 f1       	breq	.+110    	; 0x4bac <main+0x398>
    4b3e:	81 30       	cpi	r24, 0x01	; 1
    4b40:	09 f0       	breq	.+2      	; 0x4b44 <main+0x330>
    4b42:	4f c0       	rjmp	.+158    	; 0x4be2 <main+0x3ce>
{
case 1: glcd_clear();
    4b44:	0e 94 ee 12 	call	0x25dc	; 0x25dc <glcd_clear>
        glcd_puts("WELCOME ANIRUDDH",0,3);
    4b48:	8d e8       	ldi	r24, 0x8D	; 141
    4b4a:	92 e0       	ldi	r25, 0x02	; 2
    4b4c:	60 e0       	ldi	r22, 0x00	; 0
    4b4e:	70 e0       	ldi	r23, 0x00	; 0
    4b50:	43 e0       	ldi	r20, 0x03	; 3
    4b52:	50 e0       	ldi	r21, 0x00	; 0
    4b54:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
        glcd_puts("LOADING YOUR    SETTINGS....",0,5);
    4b58:	8e e9       	ldi	r24, 0x9E	; 158
    4b5a:	92 e0       	ldi	r25, 0x02	; 2
    4b5c:	60 e0       	ldi	r22, 0x00	; 0
    4b5e:	70 e0       	ldi	r23, 0x00	; 0
    4b60:	45 e0       	ldi	r20, 0x05	; 5
    4b62:	50 e0       	ldi	r21, 0x00	; 0
    4b64:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
    4b68:	80 e2       	ldi	r24, 0x20	; 32
    4b6a:	9e e4       	ldi	r25, 0x4E	; 78
    4b6c:	fe 01       	movw	r30, r28
    4b6e:	31 97       	sbiw	r30, 0x01	; 1
    4b70:	f1 f7       	brne	.-4      	; 0x4b6e <main+0x35a>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4b72:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4b74:	d9 f7       	brne	.-10     	; 0x4b6c <main+0x358>
    4b76:	33 c0       	rjmp	.+102    	; 0x4bde <main+0x3ca>
		_delay_ms(2000);
		glcd_clear();
        break;

case 2:glcd_clear();
    4b78:	0e 94 ee 12 	call	0x25dc	; 0x25dc <glcd_clear>
        glcd_puts("WELCOME SIDDESH",0,3);
    4b7c:	8b eb       	ldi	r24, 0xBB	; 187
    4b7e:	92 e0       	ldi	r25, 0x02	; 2
    4b80:	60 e0       	ldi	r22, 0x00	; 0
    4b82:	70 e0       	ldi	r23, 0x00	; 0
    4b84:	43 e0       	ldi	r20, 0x03	; 3
    4b86:	50 e0       	ldi	r21, 0x00	; 0
    4b88:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
        glcd_puts("LOADING YOUR    SETTINGS....",0,5);
    4b8c:	8e e9       	ldi	r24, 0x9E	; 158
    4b8e:	92 e0       	ldi	r25, 0x02	; 2
    4b90:	60 e0       	ldi	r22, 0x00	; 0
    4b92:	70 e0       	ldi	r23, 0x00	; 0
    4b94:	45 e0       	ldi	r20, 0x05	; 5
    4b96:	50 e0       	ldi	r21, 0x00	; 0
    4b98:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
    4b9c:	80 e2       	ldi	r24, 0x20	; 32
    4b9e:	9e e4       	ldi	r25, 0x4E	; 78
    4ba0:	fe 01       	movw	r30, r28
    4ba2:	31 97       	sbiw	r30, 0x01	; 1
    4ba4:	f1 f7       	brne	.-4      	; 0x4ba2 <main+0x38e>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4ba6:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4ba8:	d9 f7       	brne	.-10     	; 0x4ba0 <main+0x38c>
    4baa:	19 c0       	rjmp	.+50     	; 0x4bde <main+0x3ca>
		_delay_ms(2000);
		glcd_clear();
       break;

case 3: glcd_clear();
    4bac:	0e 94 ee 12 	call	0x25dc	; 0x25dc <glcd_clear>
        glcd_puts("WELCOME SHAWN",0,3);
    4bb0:	8b ec       	ldi	r24, 0xCB	; 203
    4bb2:	92 e0       	ldi	r25, 0x02	; 2
    4bb4:	60 e0       	ldi	r22, 0x00	; 0
    4bb6:	70 e0       	ldi	r23, 0x00	; 0
    4bb8:	43 e0       	ldi	r20, 0x03	; 3
    4bba:	50 e0       	ldi	r21, 0x00	; 0
    4bbc:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
        glcd_puts("LOADING YOUR    SETTINGS....",0,5);
    4bc0:	8e e9       	ldi	r24, 0x9E	; 158
    4bc2:	92 e0       	ldi	r25, 0x02	; 2
    4bc4:	60 e0       	ldi	r22, 0x00	; 0
    4bc6:	70 e0       	ldi	r23, 0x00	; 0
    4bc8:	45 e0       	ldi	r20, 0x05	; 5
    4bca:	50 e0       	ldi	r21, 0x00	; 0
    4bcc:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
    4bd0:	80 e2       	ldi	r24, 0x20	; 32
    4bd2:	9e e4       	ldi	r25, 0x4E	; 78
    4bd4:	fe 01       	movw	r30, r28
    4bd6:	31 97       	sbiw	r30, 0x01	; 1
    4bd8:	f1 f7       	brne	.-4      	; 0x4bd6 <main+0x3c2>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4bda:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4bdc:	d9 f7       	brne	.-10     	; 0x4bd4 <main+0x3c0>
		_delay_ms(2000);
		glcd_clear();
    4bde:	0e 94 ee 12 	call	0x25dc	; 0x25dc <glcd_clear>

}
}


if(cmd==0xBF)// SUBMENU response 
    4be2:	80 91 68 04 	lds	r24, 0x0468
    4be6:	8f 3b       	cpi	r24, 0xBF	; 191
    4be8:	09 f0       	breq	.+2      	; 0x4bec <main+0x3d8>
    4bea:	4e c0       	rjmp	.+156    	; 0x4c88 <main+0x474>
{
read_batt();
    4bec:	0e 94 49 19 	call	0x3292	; 0x3292 <read_batt>
inp=rxBuffer[1];
    4bf0:	80 91 bf 04 	lds	r24, 0x04BF
    4bf4:	80 93 6a 04 	sts	0x046A, r24
switch(inp)
    4bf8:	82 30       	cpi	r24, 0x02	; 2
    4bfa:	91 f0       	breq	.+36     	; 0x4c20 <main+0x40c>
    4bfc:	83 30       	cpi	r24, 0x03	; 3
    4bfe:	20 f4       	brcc	.+8      	; 0x4c08 <main+0x3f4>
    4c00:	81 30       	cpi	r24, 0x01	; 1
    4c02:	09 f0       	breq	.+2      	; 0x4c06 <main+0x3f2>
    4c04:	41 c0       	rjmp	.+130    	; 0x4c88 <main+0x474>
    4c06:	05 c0       	rjmp	.+10     	; 0x4c12 <main+0x3fe>
    4c08:	83 30       	cpi	r24, 0x03	; 3
    4c0a:	f9 f0       	breq	.+62     	; 0x4c4a <main+0x436>
    4c0c:	84 30       	cpi	r24, 0x04	; 4
    4c0e:	e1 f5       	brne	.+120    	; 0x4c88 <main+0x474>
    4c10:	23 c0       	rjmp	.+70     	; 0x4c58 <main+0x444>
{
case 1:glcd_clear();
    4c12:	0e 94 ee 12 	call	0x25dc	; 0x25dc <glcd_clear>
       read_batt();
    4c16:	0e 94 49 19 	call	0x3292	; 0x3292 <read_batt>
       glcd_puts("CHARACTER  ",0,0);
    4c1a:	89 ed       	ldi	r24, 0xD9	; 217
    4c1c:	91 e0       	ldi	r25, 0x01	; 1
    4c1e:	06 c0       	rjmp	.+12     	; 0x4c2c <main+0x418>
	   glcd_puts(disp,0,1);
       break;

case 2:glcd_clear();
    4c20:	0e 94 ee 12 	call	0x25dc	; 0x25dc <glcd_clear>
       read_batt();
    4c24:	0e 94 49 19 	call	0x3292	; 0x3292 <read_batt>
       glcd_puts("NUMBER     ",0,0);
    4c28:	85 ee       	ldi	r24, 0xE5	; 229
    4c2a:	91 e0       	ldi	r25, 0x01	; 1
    4c2c:	60 e0       	ldi	r22, 0x00	; 0
    4c2e:	70 e0       	ldi	r23, 0x00	; 0
    4c30:	40 e0       	ldi	r20, 0x00	; 0
    4c32:	50 e0       	ldi	r21, 0x00	; 0
    4c34:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
	   glcd_puts(disp,0,1);
    4c38:	8f ec       	ldi	r24, 0xCF	; 207
    4c3a:	94 e0       	ldi	r25, 0x04	; 4
    4c3c:	60 e0       	ldi	r22, 0x00	; 0
    4c3e:	70 e0       	ldi	r23, 0x00	; 0
    4c40:	41 e0       	ldi	r20, 0x01	; 1
    4c42:	50 e0       	ldi	r21, 0x00	; 0
    4c44:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
    4c48:	1f c0       	rjmp	.+62     	; 0x4c88 <main+0x474>
       break;

case 3:glcd_clear();
    4c4a:	0e 94 ee 12 	call	0x25dc	; 0x25dc <glcd_clear>
       read_batt();
    4c4e:	0e 94 49 19 	call	0x3292	; 0x3292 <read_batt>
       glcd_puts("SP SYMBOL  ",0,0);
    4c52:	81 ef       	ldi	r24, 0xF1	; 241
    4c54:	91 e0       	ldi	r25, 0x01	; 1
    4c56:	ea cf       	rjmp	.-44     	; 0x4c2c <main+0x418>
	   glcd_puts(disp,0,1);
       break;

case 4:glcd_clear();
    4c58:	0e 94 ee 12 	call	0x25dc	; 0x25dc <glcd_clear>
       read_batt();
    4c5c:	0e 94 49 19 	call	0x3292	; 0x3292 <read_batt>
       glcd_puts("MOUSE      ",0,0);
    4c60:	89 ed       	ldi	r24, 0xD9	; 217
    4c62:	92 e0       	ldi	r25, 0x02	; 2
    4c64:	60 e0       	ldi	r22, 0x00	; 0
    4c66:	70 e0       	ldi	r23, 0x00	; 0
    4c68:	40 e0       	ldi	r20, 0x00	; 0
    4c6a:	50 e0       	ldi	r21, 0x00	; 0
    4c6c:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
	   glcd_puts(disp,0,1);
    4c70:	8f ec       	ldi	r24, 0xCF	; 207
    4c72:	94 e0       	ldi	r25, 0x04	; 4
    4c74:	60 e0       	ldi	r22, 0x00	; 0
    4c76:	70 e0       	ldi	r23, 0x00	; 0
    4c78:	41 e0       	ldi	r20, 0x01	; 1
    4c7a:	50 e0       	ldi	r21, 0x00	; 0
    4c7c:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
	   uart_puts("<m>");
    4c80:	85 ee       	ldi	r24, 0xE5	; 229
    4c82:	92 e0       	ldi	r25, 0x02	; 2
    4c84:	0e 94 04 2d 	call	0x5a08	; 0x5a08 <uart_puts>

}



if(cmd==0x1A)//control devices
    4c88:	80 91 68 04 	lds	r24, 0x0468
    4c8c:	8a 31       	cpi	r24, 0x1A	; 26
    4c8e:	09 f0       	breq	.+2      	; 0x4c92 <main+0x47e>
    4c90:	aa c0       	rjmp	.+340    	; 0x4de6 <main+0x5d2>
{
read_batt();
    4c92:	0e 94 49 19 	call	0x3292	; 0x3292 <read_batt>
dev_status();
    4c96:	0e 94 e4 21 	call	0x43c8	; 0x43c8 <dev_status>
cbi(PORTA,0);
    4c9a:	d8 98       	cbi	0x1b, 0	; 27

switch(rxBuffer[1])
    4c9c:	10 91 bf 04 	lds	r17, 0x04BF
    4ca0:	13 30       	cpi	r17, 0x03	; 3
    4ca2:	09 f4       	brne	.+2      	; 0x4ca6 <main+0x492>
    4ca4:	48 c0       	rjmp	.+144    	; 0x4d36 <main+0x522>
    4ca6:	14 30       	cpi	r17, 0x04	; 4
    4ca8:	30 f4       	brcc	.+12     	; 0x4cb6 <main+0x4a2>
    4caa:	11 30       	cpi	r17, 0x01	; 1
    4cac:	59 f0       	breq	.+22     	; 0x4cc4 <main+0x4b0>
    4cae:	12 30       	cpi	r17, 0x02	; 2
    4cb0:	09 f0       	breq	.+2      	; 0x4cb4 <main+0x4a0>
    4cb2:	99 c0       	rjmp	.+306    	; 0x4de6 <main+0x5d2>
    4cb4:	23 c0       	rjmp	.+70     	; 0x4cfc <main+0x4e8>
    4cb6:	14 30       	cpi	r17, 0x04	; 4
    4cb8:	09 f4       	brne	.+2      	; 0x4cbc <main+0x4a8>
    4cba:	5a c0       	rjmp	.+180    	; 0x4d70 <main+0x55c>
    4cbc:	15 30       	cpi	r17, 0x05	; 5
    4cbe:	09 f0       	breq	.+2      	; 0x4cc2 <main+0x4ae>
    4cc0:	92 c0       	rjmp	.+292    	; 0x4de6 <main+0x5d2>
    4cc2:	73 c0       	rjmp	.+230    	; 0x4daa <main+0x596>
{
case 1: glcd_puts("1",17,3);
    4cc4:	89 ee       	ldi	r24, 0xE9	; 233
    4cc6:	92 e0       	ldi	r25, 0x02	; 2
    4cc8:	61 e1       	ldi	r22, 0x11	; 17
    4cca:	70 e0       	ldi	r23, 0x00	; 0
    4ccc:	43 e0       	ldi	r20, 0x03	; 3
    4cce:	50 e0       	ldi	r21, 0x00	; 0
    4cd0:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
        if(tog[0]==0){sbi(PORTA,1);tog[0]=1;glcd_puts("ON ",89,3);}
    4cd4:	80 91 6b 04 	lds	r24, 0x046B
    4cd8:	88 23       	and	r24, r24
    4cda:	31 f4       	brne	.+12     	; 0x4ce8 <main+0x4d4>
    4cdc:	d9 9a       	sbi	0x1b, 1	; 27
    4cde:	10 93 6b 04 	sts	0x046B, r17
    4ce2:	85 ec       	ldi	r24, 0xC5	; 197
    4ce4:	90 e0       	ldi	r25, 0x00	; 0
    4ce6:	05 c0       	rjmp	.+10     	; 0x4cf2 <main+0x4de>
        else{cbi(PORTA,1);tog[0]=0;glcd_puts("OFF",89,3);}
    4ce8:	d9 98       	cbi	0x1b, 1	; 27
    4cea:	10 92 6b 04 	sts	0x046B, r1
    4cee:	89 ec       	ldi	r24, 0xC9	; 201
    4cf0:	90 e0       	ldi	r25, 0x00	; 0
    4cf2:	69 e5       	ldi	r22, 0x59	; 89
    4cf4:	70 e0       	ldi	r23, 0x00	; 0
    4cf6:	43 e0       	ldi	r20, 0x03	; 3
    4cf8:	50 e0       	ldi	r21, 0x00	; 0
    4cfa:	73 c0       	rjmp	.+230    	; 0x4de2 <main+0x5ce>
		break;

case 2: glcd_puts("2",17,4);
    4cfc:	8b ee       	ldi	r24, 0xEB	; 235
    4cfe:	92 e0       	ldi	r25, 0x02	; 2
    4d00:	61 e1       	ldi	r22, 0x11	; 17
    4d02:	70 e0       	ldi	r23, 0x00	; 0
    4d04:	44 e0       	ldi	r20, 0x04	; 4
    4d06:	50 e0       	ldi	r21, 0x00	; 0
    4d08:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
        if(tog[1]==0){sbi(PORTA,2);tog[1]=1;glcd_puts("ON ",89,4);}
    4d0c:	80 91 6c 04 	lds	r24, 0x046C
    4d10:	88 23       	and	r24, r24
    4d12:	39 f4       	brne	.+14     	; 0x4d22 <main+0x50e>
    4d14:	da 9a       	sbi	0x1b, 2	; 27
    4d16:	81 e0       	ldi	r24, 0x01	; 1
    4d18:	80 93 6c 04 	sts	0x046C, r24
    4d1c:	85 ec       	ldi	r24, 0xC5	; 197
    4d1e:	90 e0       	ldi	r25, 0x00	; 0
    4d20:	05 c0       	rjmp	.+10     	; 0x4d2c <main+0x518>
        else{cbi(PORTA,2);tog[1]=0;glcd_puts("OFF",89,4);}
    4d22:	da 98       	cbi	0x1b, 2	; 27
    4d24:	10 92 6c 04 	sts	0x046C, r1
    4d28:	89 ec       	ldi	r24, 0xC9	; 201
    4d2a:	90 e0       	ldi	r25, 0x00	; 0
    4d2c:	69 e5       	ldi	r22, 0x59	; 89
    4d2e:	70 e0       	ldi	r23, 0x00	; 0
    4d30:	44 e0       	ldi	r20, 0x04	; 4
    4d32:	50 e0       	ldi	r21, 0x00	; 0
    4d34:	56 c0       	rjmp	.+172    	; 0x4de2 <main+0x5ce>
		break;

case 3: glcd_puts("3",17,5);
    4d36:	8d ee       	ldi	r24, 0xED	; 237
    4d38:	92 e0       	ldi	r25, 0x02	; 2
    4d3a:	61 e1       	ldi	r22, 0x11	; 17
    4d3c:	70 e0       	ldi	r23, 0x00	; 0
    4d3e:	45 e0       	ldi	r20, 0x05	; 5
    4d40:	50 e0       	ldi	r21, 0x00	; 0
    4d42:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
        if(tog[2]==0){sbi(PORTA,3);tog[2]=1;glcd_puts("ON ",89,5);}
    4d46:	80 91 6d 04 	lds	r24, 0x046D
    4d4a:	88 23       	and	r24, r24
    4d4c:	39 f4       	brne	.+14     	; 0x4d5c <main+0x548>
    4d4e:	db 9a       	sbi	0x1b, 3	; 27
    4d50:	81 e0       	ldi	r24, 0x01	; 1
    4d52:	80 93 6d 04 	sts	0x046D, r24
    4d56:	85 ec       	ldi	r24, 0xC5	; 197
    4d58:	90 e0       	ldi	r25, 0x00	; 0
    4d5a:	05 c0       	rjmp	.+10     	; 0x4d66 <main+0x552>
        else{cbi(PORTA,3);tog[2]=0;glcd_puts("OFF",89,5);}
    4d5c:	db 98       	cbi	0x1b, 3	; 27
    4d5e:	10 92 6d 04 	sts	0x046D, r1
    4d62:	89 ec       	ldi	r24, 0xC9	; 201
    4d64:	90 e0       	ldi	r25, 0x00	; 0
    4d66:	69 e5       	ldi	r22, 0x59	; 89
    4d68:	70 e0       	ldi	r23, 0x00	; 0
    4d6a:	45 e0       	ldi	r20, 0x05	; 5
    4d6c:	50 e0       	ldi	r21, 0x00	; 0
    4d6e:	39 c0       	rjmp	.+114    	; 0x4de2 <main+0x5ce>
		break;

case 4: glcd_puts("4",17,6);
    4d70:	8f ee       	ldi	r24, 0xEF	; 239
    4d72:	92 e0       	ldi	r25, 0x02	; 2
    4d74:	61 e1       	ldi	r22, 0x11	; 17
    4d76:	70 e0       	ldi	r23, 0x00	; 0
    4d78:	46 e0       	ldi	r20, 0x06	; 6
    4d7a:	50 e0       	ldi	r21, 0x00	; 0
    4d7c:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
        if(tog[3]==0){sbi(PORTA,4);tog[3]=1;glcd_puts("ON ",89,6);}
    4d80:	80 91 6e 04 	lds	r24, 0x046E
    4d84:	88 23       	and	r24, r24
    4d86:	39 f4       	brne	.+14     	; 0x4d96 <main+0x582>
    4d88:	dc 9a       	sbi	0x1b, 4	; 27
    4d8a:	81 e0       	ldi	r24, 0x01	; 1
    4d8c:	80 93 6e 04 	sts	0x046E, r24
    4d90:	85 ec       	ldi	r24, 0xC5	; 197
    4d92:	90 e0       	ldi	r25, 0x00	; 0
    4d94:	05 c0       	rjmp	.+10     	; 0x4da0 <main+0x58c>
        else{cbi(PORTA,4);tog[3]=0;glcd_puts("OFF",89,6);}
    4d96:	dc 98       	cbi	0x1b, 4	; 27
    4d98:	10 92 6e 04 	sts	0x046E, r1
    4d9c:	89 ec       	ldi	r24, 0xC9	; 201
    4d9e:	90 e0       	ldi	r25, 0x00	; 0
    4da0:	69 e5       	ldi	r22, 0x59	; 89
    4da2:	70 e0       	ldi	r23, 0x00	; 0
    4da4:	46 e0       	ldi	r20, 0x06	; 6
    4da6:	50 e0       	ldi	r21, 0x00	; 0
    4da8:	1c c0       	rjmp	.+56     	; 0x4de2 <main+0x5ce>
		break;

case 5: glcd_puts("5",17,7);
    4daa:	81 ef       	ldi	r24, 0xF1	; 241
    4dac:	92 e0       	ldi	r25, 0x02	; 2
    4dae:	61 e1       	ldi	r22, 0x11	; 17
    4db0:	70 e0       	ldi	r23, 0x00	; 0
    4db2:	47 e0       	ldi	r20, 0x07	; 7
    4db4:	50 e0       	ldi	r21, 0x00	; 0
    4db6:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
        if(tog[4]==0){sbi(PORTA,5);tog[4]=1;glcd_puts("ON ",89,7);}
    4dba:	80 91 6f 04 	lds	r24, 0x046F
    4dbe:	88 23       	and	r24, r24
    4dc0:	39 f4       	brne	.+14     	; 0x4dd0 <main+0x5bc>
    4dc2:	dd 9a       	sbi	0x1b, 5	; 27
    4dc4:	81 e0       	ldi	r24, 0x01	; 1
    4dc6:	80 93 6f 04 	sts	0x046F, r24
    4dca:	85 ec       	ldi	r24, 0xC5	; 197
    4dcc:	90 e0       	ldi	r25, 0x00	; 0
    4dce:	05 c0       	rjmp	.+10     	; 0x4dda <main+0x5c6>
        else{cbi(PORTA,5);tog[4]=0;glcd_puts("OFF",89,7);}
    4dd0:	dd 98       	cbi	0x1b, 5	; 27
    4dd2:	10 92 6f 04 	sts	0x046F, r1
    4dd6:	89 ec       	ldi	r24, 0xC9	; 201
    4dd8:	90 e0       	ldi	r25, 0x00	; 0
    4dda:	69 e5       	ldi	r22, 0x59	; 89
    4ddc:	70 e0       	ldi	r23, 0x00	; 0
    4dde:	47 e0       	ldi	r20, 0x07	; 7
    4de0:	50 e0       	ldi	r21, 0x00	; 0
    4de2:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
		break;*/

}
}

if(cmd==0xCF)//mouse control
    4de6:	80 91 68 04 	lds	r24, 0x0468
    4dea:	8f 3c       	cpi	r24, 0xCF	; 207
    4dec:	09 f0       	breq	.+2      	; 0x4df0 <main+0x5dc>
    4dee:	74 c0       	rjmp	.+232    	; 0x4ed8 <main+0x6c4>
    4df0:	6e c0       	rjmp	.+220    	; 0x4ece <main+0x6ba>
{

while(cmd==0xCF)
{

if(data_rx()==1)
    4df2:	0e 94 e0 18 	call	0x31c0	; 0x31c0 <data_rx>
    4df6:	81 30       	cpi	r24, 0x01	; 1
    4df8:	c1 f4       	brne	.+48     	; 0x4e2a <main+0x616>
{
cmd=rxBuffer[0];
    4dfa:	80 91 be 04 	lds	r24, 0x04BE
    4dfe:	80 93 68 04 	sts	0x0468, r24
x=rxBuffer[1];
    4e02:	80 91 bf 04 	lds	r24, 0x04BF
    4e06:	80 93 ba 04 	sts	0x04BA, r24
    4e0a:	10 92 bb 04 	sts	0x04BB, r1
y=rxBuffer[2];
    4e0e:	80 91 c0 04 	lds	r24, 0x04C0
    4e12:	80 93 c3 04 	sts	0x04C3, r24
    4e16:	10 92 c4 04 	sts	0x04C4, r1
lc=rxBuffer[3];
    4e1a:	80 91 c1 04 	lds	r24, 0x04C1
    4e1e:	80 93 cd 04 	sts	0x04CD, r24
rc=rxBuffer[4];
    4e22:	80 91 c2 04 	lds	r24, 0x04C2
    4e26:	80 93 b9 04 	sts	0x04B9, r24
}

chk_click();
    4e2a:	0e 94 6d 21 	call	0x42da	; 0x42da <chk_click>

//right
if(x==1){x_movep(6000);}
    4e2e:	80 91 ba 04 	lds	r24, 0x04BA
    4e32:	90 91 bb 04 	lds	r25, 0x04BB
    4e36:	01 97       	sbiw	r24, 0x01	; 1
    4e38:	21 f4       	brne	.+8      	; 0x4e42 <main+0x62e>
    4e3a:	80 e7       	ldi	r24, 0x70	; 112
    4e3c:	97 e1       	ldi	r25, 0x17	; 23
    4e3e:	0e 94 ef 1d 	call	0x3bde	; 0x3bde <x_movep>
if(x==2){x_movep(1000);}
    4e42:	80 91 ba 04 	lds	r24, 0x04BA
    4e46:	90 91 bb 04 	lds	r25, 0x04BB
    4e4a:	02 97       	sbiw	r24, 0x02	; 2
    4e4c:	21 f4       	brne	.+8      	; 0x4e56 <main+0x642>
    4e4e:	88 ee       	ldi	r24, 0xE8	; 232
    4e50:	93 e0       	ldi	r25, 0x03	; 3
    4e52:	0e 94 ef 1d 	call	0x3bde	; 0x3bde <x_movep>

//left
if(x==3){x_moven(6000);}
    4e56:	80 91 ba 04 	lds	r24, 0x04BA
    4e5a:	90 91 bb 04 	lds	r25, 0x04BB
    4e5e:	03 97       	sbiw	r24, 0x03	; 3
    4e60:	21 f4       	brne	.+8      	; 0x4e6a <main+0x656>
    4e62:	80 e7       	ldi	r24, 0x70	; 112
    4e64:	97 e1       	ldi	r25, 0x17	; 23
    4e66:	0e 94 ae 1f 	call	0x3f5c	; 0x3f5c <x_moven>
if(x==4){x_moven(1000);}
    4e6a:	80 91 ba 04 	lds	r24, 0x04BA
    4e6e:	90 91 bb 04 	lds	r25, 0x04BB
    4e72:	04 97       	sbiw	r24, 0x04	; 4
    4e74:	21 f4       	brne	.+8      	; 0x4e7e <main+0x66a>
    4e76:	88 ee       	ldi	r24, 0xE8	; 232
    4e78:	93 e0       	ldi	r25, 0x03	; 3
    4e7a:	0e 94 ae 1f 	call	0x3f5c	; 0x3f5c <x_moven>

//down
if(y==1){y_moven(6000);}
    4e7e:	80 91 c3 04 	lds	r24, 0x04C3
    4e82:	90 91 c4 04 	lds	r25, 0x04C4
    4e86:	01 97       	sbiw	r24, 0x01	; 1
    4e88:	21 f4       	brne	.+8      	; 0x4e92 <main+0x67e>
    4e8a:	80 e7       	ldi	r24, 0x70	; 112
    4e8c:	97 e1       	ldi	r25, 0x17	; 23
    4e8e:	0e 94 30 1c 	call	0x3860	; 0x3860 <y_moven>
if(y==2){y_moven(1000);}
    4e92:	80 91 c3 04 	lds	r24, 0x04C3
    4e96:	90 91 c4 04 	lds	r25, 0x04C4
    4e9a:	02 97       	sbiw	r24, 0x02	; 2
    4e9c:	21 f4       	brne	.+8      	; 0x4ea6 <main+0x692>
    4e9e:	88 ee       	ldi	r24, 0xE8	; 232
    4ea0:	93 e0       	ldi	r25, 0x03	; 3
    4ea2:	0e 94 30 1c 	call	0x3860	; 0x3860 <y_moven>

//up
if(y==3){y_movep(6000);}
    4ea6:	80 91 c3 04 	lds	r24, 0x04C3
    4eaa:	90 91 c4 04 	lds	r25, 0x04C4
    4eae:	03 97       	sbiw	r24, 0x03	; 3
    4eb0:	21 f4       	brne	.+8      	; 0x4eba <main+0x6a6>
    4eb2:	80 e7       	ldi	r24, 0x70	; 112
    4eb4:	97 e1       	ldi	r25, 0x17	; 23
    4eb6:	0e 94 71 1a 	call	0x34e2	; 0x34e2 <y_movep>
if(y==4){y_movep(1000);}
    4eba:	80 91 c3 04 	lds	r24, 0x04C3
    4ebe:	90 91 c4 04 	lds	r25, 0x04C4
    4ec2:	04 97       	sbiw	r24, 0x04	; 4
    4ec4:	21 f4       	brne	.+8      	; 0x4ece <main+0x6ba>
    4ec6:	88 ee       	ldi	r24, 0xE8	; 232
    4ec8:	93 e0       	ldi	r25, 0x03	; 3
    4eca:	0e 94 71 1a 	call	0x34e2	; 0x34e2 <y_movep>
}

if(cmd==0xCF)//mouse control
{

while(cmd==0xCF)
    4ece:	80 91 68 04 	lds	r24, 0x0468
    4ed2:	8f 3c       	cpi	r24, 0xCF	; 207
    4ed4:	09 f4       	brne	.+2      	; 0x4ed8 <main+0x6c4>
    4ed6:	8d cf       	rjmp	.-230    	; 0x4df2 <main+0x5de>
}

}


if((cmd==0x1B)||(cmd==0x2B))//robot control
    4ed8:	80 91 68 04 	lds	r24, 0x0468
    4edc:	8b 31       	cpi	r24, 0x1B	; 27
    4ede:	11 f0       	breq	.+4      	; 0x4ee4 <main+0x6d0>
    4ee0:	8b 32       	cpi	r24, 0x2B	; 43
    4ee2:	11 f5       	brne	.+68     	; 0x4f28 <main+0x714>
{


switch(rxBuffer[1])
    4ee4:	80 91 bf 04 	lds	r24, 0x04BF
    4ee8:	8b 3b       	cpi	r24, 0xBB	; 187
    4eea:	99 f0       	breq	.+38     	; 0x4f12 <main+0x6fe>
    4eec:	8c 3b       	cpi	r24, 0xBC	; 188
    4eee:	18 f4       	brcc	.+6      	; 0x4ef6 <main+0x6e2>
    4ef0:	8b 3a       	cpi	r24, 0xAB	; 171
    4ef2:	91 f4       	brne	.+36     	; 0x4f18 <main+0x704>
    4ef4:	05 c0       	rjmp	.+10     	; 0x4f00 <main+0x6ec>
    4ef6:	8b 3c       	cpi	r24, 0xCB	; 203
    4ef8:	31 f0       	breq	.+12     	; 0x4f06 <main+0x6f2>
    4efa:	8b 3d       	cpi	r24, 0xDB	; 219
    4efc:	69 f4       	brne	.+26     	; 0x4f18 <main+0x704>
    4efe:	06 c0       	rjmp	.+12     	; 0x4f0c <main+0x6f8>
{

//cbi(PORTA,0);

case 0xAB: glcd_puts(" FORWARD",0,7);
    4f00:	83 ef       	ldi	r24, 0xF3	; 243
    4f02:	92 e0       	ldi	r25, 0x02	; 2
    4f04:	0b c0       	rjmp	.+22     	; 0x4f1c <main+0x708>
           //sbi(PORTA,4);
           break;

case 0xCB: glcd_puts(" LEFT   ",0,7);
    4f06:	8c ef       	ldi	r24, 0xFC	; 252
    4f08:	92 e0       	ldi	r25, 0x02	; 2
    4f0a:	08 c0       	rjmp	.+16     	; 0x4f1c <main+0x708>
           //sbi(PORTA,3);
           break;

case 0xDB: glcd_puts(" RIGHT  ",0,7);
    4f0c:	85 e0       	ldi	r24, 0x05	; 5
    4f0e:	93 e0       	ldi	r25, 0x03	; 3
    4f10:	05 c0       	rjmp	.+10     	; 0x4f1c <main+0x708>
           //sbi(PORTA,2);
           break;

case 0xBB: glcd_puts(" REVERSE",0,7);
    4f12:	8e e0       	ldi	r24, 0x0E	; 14
    4f14:	93 e0       	ldi	r25, 0x03	; 3
    4f16:	02 c0       	rjmp	.+4      	; 0x4f1c <main+0x708>
           //sbi(PORTA,1);
           break;

default:   glcd_puts(" STOP   ",0,7);
    4f18:	87 e1       	ldi	r24, 0x17	; 23
    4f1a:	93 e0       	ldi	r25, 0x03	; 3
    4f1c:	60 e0       	ldi	r22, 0x00	; 0
    4f1e:	70 e0       	ldi	r23, 0x00	; 0
    4f20:	47 e0       	ldi	r20, 0x07	; 7
    4f22:	50 e0       	ldi	r21, 0x00	; 0
    4f24:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>

}

} 

if(cmd==0x9B)//response from robot
    4f28:	80 91 68 04 	lds	r24, 0x0468
    4f2c:	8b 39       	cpi	r24, 0x9B	; 155
    4f2e:	09 f0       	breq	.+2      	; 0x4f32 <main+0x71e>
    4f30:	9b cc       	rjmp	.-1738   	; 0x4868 <main+0x54>
{
switch(rxBuffer[1])
    4f32:	80 91 bf 04 	lds	r24, 0x04BF
    4f36:	8b 32       	cpi	r24, 0x2B	; 43
    4f38:	69 f0       	breq	.+26     	; 0x4f54 <main+0x740>
    4f3a:	8c 32       	cpi	r24, 0x2C	; 44
    4f3c:	18 f4       	brcc	.+6      	; 0x4f44 <main+0x730>
    4f3e:	8b 31       	cpi	r24, 0x1B	; 27
    4f40:	09 f5       	brne	.+66     	; 0x4f84 <main+0x770>
    4f42:	05 c0       	rjmp	.+10     	; 0x4f4e <main+0x73a>
    4f44:	8b 33       	cpi	r24, 0x3B	; 59
    4f46:	49 f0       	breq	.+18     	; 0x4f5a <main+0x746>
    4f48:	8b 34       	cpi	r24, 0x4B	; 75
    4f4a:	e1 f4       	brne	.+56     	; 0x4f84 <main+0x770>
    4f4c:	0b c0       	rjmp	.+22     	; 0x4f64 <main+0x750>
{

case 0x1B: glcd_puts(" U.Ctrl ",65,7);
    4f4e:	80 e2       	ldi	r24, 0x20	; 32
    4f50:	93 e0       	ldi	r25, 0x03	; 3
    4f52:	05 c0       	rjmp	.+10     	; 0x4f5e <main+0x74a>
           
           break;

case 0x2B: glcd_puts("  Train ",65,7);
    4f54:	89 e2       	ldi	r24, 0x29	; 41
    4f56:	93 e0       	ldi	r25, 0x03	; 3
    4f58:	02 c0       	rjmp	.+4      	; 0x4f5e <main+0x74a>
           
           break;

case 0x3B: glcd_puts("  Auto  ",65,7);
    4f5a:	82 e3       	ldi	r24, 0x32	; 50
    4f5c:	93 e0       	ldi	r25, 0x03	; 3
    4f5e:	61 e4       	ldi	r22, 0x41	; 65
    4f60:	70 e0       	ldi	r23, 0x00	; 0
    4f62:	23 c0       	rjmp	.+70     	; 0x4faa <main+0x796>
           
           break;

case 0x4B: glcd_puts("MEMORY CLEARED!!",0,7);
    4f64:	8b e3       	ldi	r24, 0x3B	; 59
    4f66:	93 e0       	ldi	r25, 0x03	; 3
    4f68:	60 e0       	ldi	r22, 0x00	; 0
    4f6a:	70 e0       	ldi	r23, 0x00	; 0
    4f6c:	47 e0       	ldi	r20, 0x07	; 7
    4f6e:	50 e0       	ldi	r21, 0x00	; 0
    4f70:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
    4f74:	80 e2       	ldi	r24, 0x20	; 32
    4f76:	9e e4       	ldi	r25, 0x4E	; 78
    4f78:	fe 01       	movw	r30, r28
    4f7a:	31 97       	sbiw	r30, 0x01	; 1
    4f7c:	f1 f7       	brne	.-4      	; 0x4f7a <main+0x766>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4f7e:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4f80:	d9 f7       	brne	.-10     	; 0x4f78 <main+0x764>
    4f82:	72 cc       	rjmp	.-1820   	; 0x4868 <main+0x54>
           _delay_ms(2000);
           break;

default:   glcd_puts("PLEASE WAIT.....",0,7);
    4f84:	8c e4       	ldi	r24, 0x4C	; 76
    4f86:	93 e0       	ldi	r25, 0x03	; 3
    4f88:	60 e0       	ldi	r22, 0x00	; 0
    4f8a:	70 e0       	ldi	r23, 0x00	; 0
    4f8c:	47 e0       	ldi	r20, 0x07	; 7
    4f8e:	50 e0       	ldi	r21, 0x00	; 0
    4f90:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
    4f94:	80 e1       	ldi	r24, 0x10	; 16
    4f96:	97 e2       	ldi	r25, 0x27	; 39
    4f98:	fe 01       	movw	r30, r28
    4f9a:	31 97       	sbiw	r30, 0x01	; 1
    4f9c:	f1 f7       	brne	.-4      	; 0x4f9a <main+0x786>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4f9e:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4fa0:	d9 f7       	brne	.-10     	; 0x4f98 <main+0x784>
           _delay_ms(1000);
		   glcd_puts("                ",0,7);
    4fa2:	88 ec       	ldi	r24, 0xC8	; 200
    4fa4:	91 e0       	ldi	r25, 0x01	; 1
    4fa6:	60 e0       	ldi	r22, 0x00	; 0
    4fa8:	70 e0       	ldi	r23, 0x00	; 0
    4faa:	47 e0       	ldi	r20, 0x07	; 7
    4fac:	50 e0       	ldi	r21, 0x00	; 0
    4fae:	0e 94 84 21 	call	0x4308	; 0x4308 <glcd_puts>
    4fb2:	5a cc       	rjmp	.-1868   	; 0x4868 <main+0x54>

00004fb4 <line>:
}
//-----------------------
void line(unsigned int x1,unsigned int y1,
          unsigned int x2,unsigned int y2,
          byte s,byte c)//line (x1,y1,x2,y2,space between points,color)
{
    4fb4:	2f 92       	push	r2
    4fb6:	3f 92       	push	r3
    4fb8:	4f 92       	push	r4
    4fba:	5f 92       	push	r5
    4fbc:	6f 92       	push	r6
    4fbe:	7f 92       	push	r7
    4fc0:	8f 92       	push	r8
    4fc2:	9f 92       	push	r9
    4fc4:	af 92       	push	r10
    4fc6:	bf 92       	push	r11
    4fc8:	cf 92       	push	r12
    4fca:	df 92       	push	r13
    4fcc:	ef 92       	push	r14
    4fce:	ff 92       	push	r15
    4fd0:	0f 93       	push	r16
    4fd2:	1f 93       	push	r17
    4fd4:	df 93       	push	r29
    4fd6:	cf 93       	push	r28
    4fd8:	00 d0       	rcall	.+0      	; 0x4fda <line+0x26>
    4fda:	00 d0       	rcall	.+0      	; 0x4fdc <line+0x28>
    4fdc:	00 d0       	rcall	.+0      	; 0x4fde <line+0x2a>
    4fde:	cd b7       	in	r28, 0x3d	; 61
    4fe0:	de b7       	in	r29, 0x3e	; 62
    4fe2:	6c 01       	movw	r12, r24
    4fe4:	3b 01       	movw	r6, r22
    4fe6:	5a 01       	movw	r10, r20
    4fe8:	49 01       	movw	r8, r18
    4fea:	20 2e       	mov	r2, r16
    4fec:	3e 2c       	mov	r3, r14
    float b;
    
    byte y00;
    byte y010;
    
    if(x1==x2) 
    4fee:	84 17       	cp	r24, r20
    4ff0:	95 07       	cpc	r25, r21
    4ff2:	19 f5       	brne	.+70     	; 0x503a <line+0x86>
    {    
        v_line(x1,fmin(y1,y2),abs(y2-y1)+1,s,c);
    4ff4:	80 e0       	ldi	r24, 0x00	; 0
    4ff6:	90 e0       	ldi	r25, 0x00	; 0
    4ff8:	0e 94 f2 31 	call	0x63e4	; 0x63e4 <__floatunsisf>
    4ffc:	7b 01       	movw	r14, r22
    4ffe:	8c 01       	movw	r16, r24
    5000:	b4 01       	movw	r22, r8
    5002:	80 e0       	ldi	r24, 0x00	; 0
    5004:	90 e0       	ldi	r25, 0x00	; 0
    5006:	0e 94 f2 31 	call	0x63e4	; 0x63e4 <__floatunsisf>
    500a:	9b 01       	movw	r18, r22
    500c:	ac 01       	movw	r20, r24
    500e:	c8 01       	movw	r24, r16
    5010:	b7 01       	movw	r22, r14
    5012:	0e 94 b6 34 	call	0x696c	; 0x696c <fmin>
    5016:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    501a:	a4 01       	movw	r20, r8
    501c:	46 19       	sub	r20, r6
    501e:	57 09       	sbc	r21, r7
    5020:	57 ff       	sbrs	r21, 7
    5022:	03 c0       	rjmp	.+6      	; 0x502a <line+0x76>
    5024:	50 95       	com	r21
    5026:	41 95       	neg	r20
    5028:	5f 4f       	sbci	r21, 0xFF	; 255
    502a:	4f 5f       	subi	r20, 0xFF	; 255
    502c:	5f 4f       	sbci	r21, 0xFF	; 255
    502e:	c6 01       	movw	r24, r12
    5030:	22 2d       	mov	r18, r2
    5032:	03 2d       	mov	r16, r3
    5034:	0e 94 94 13 	call	0x2728	; 0x2728 <v_line>
    5038:	e7 c0       	rjmp	.+462    	; 0x5208 <line+0x254>
    }
    else if(y1==y2)
    503a:	62 17       	cp	r22, r18
    503c:	73 07       	cpc	r23, r19
    503e:	21 f5       	brne	.+72     	; 0x5088 <line+0xd4>
    {
        h_line(fmin(x1,x2),y1,abs(x2-x1)+1,s,c);
    5040:	bc 01       	movw	r22, r24
    5042:	80 e0       	ldi	r24, 0x00	; 0
    5044:	90 e0       	ldi	r25, 0x00	; 0
    5046:	0e 94 f2 31 	call	0x63e4	; 0x63e4 <__floatunsisf>
    504a:	7b 01       	movw	r14, r22
    504c:	8c 01       	movw	r16, r24
    504e:	b5 01       	movw	r22, r10
    5050:	80 e0       	ldi	r24, 0x00	; 0
    5052:	90 e0       	ldi	r25, 0x00	; 0
    5054:	0e 94 f2 31 	call	0x63e4	; 0x63e4 <__floatunsisf>
    5058:	9b 01       	movw	r18, r22
    505a:	ac 01       	movw	r20, r24
    505c:	c8 01       	movw	r24, r16
    505e:	b7 01       	movw	r22, r14
    5060:	0e 94 b6 34 	call	0x696c	; 0x696c <fmin>
    5064:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    5068:	cb 01       	movw	r24, r22
    506a:	a5 01       	movw	r20, r10
    506c:	4c 19       	sub	r20, r12
    506e:	5d 09       	sbc	r21, r13
    5070:	57 ff       	sbrs	r21, 7
    5072:	03 c0       	rjmp	.+6      	; 0x507a <line+0xc6>
    5074:	50 95       	com	r21
    5076:	41 95       	neg	r20
    5078:	5f 4f       	sbci	r21, 0xFF	; 255
    507a:	4f 5f       	subi	r20, 0xFF	; 255
    507c:	b3 01       	movw	r22, r6
    507e:	22 2d       	mov	r18, r2
    5080:	03 2d       	mov	r16, r3
    5082:	0e 94 6d 13 	call	0x26da	; 0x26da <h_line>
    5086:	c0 c0       	rjmp	.+384    	; 0x5208 <line+0x254>
    }
    else    
    {
        if(x1>x2)
    5088:	48 17       	cp	r20, r24
    508a:	59 07       	cpc	r21, r25
    508c:	38 f4       	brcc	.+14     	; 0x509c <line+0xe8>
            temp = x1;
            x1 = x2;
            x2 = temp;
            temp = y1;
            y1 = y2;
            y2 = temp;
    508e:	65 01       	movw	r12, r10
    5090:	39 01       	movw	r6, r18
    5092:	30 e0       	ldi	r19, 0x00	; 0
    5094:	93 2f       	mov	r25, r19
    5096:	5c 01       	movw	r10, r24
    5098:	86 2f       	mov	r24, r22
    509a:	4c 01       	movw	r8, r24
        }
        
        a = (float)(signed)(y2-y1)/(x2-x1);
    509c:	b4 01       	movw	r22, r8
    509e:	66 19       	sub	r22, r6
    50a0:	77 09       	sbc	r23, r7
    50a2:	88 27       	eor	r24, r24
    50a4:	77 fd       	sbrc	r23, 7
    50a6:	80 95       	com	r24
    50a8:	98 2f       	mov	r25, r24
    50aa:	0e 94 40 31 	call	0x6280	; 0x6280 <__floatsisf>
    50ae:	7b 01       	movw	r14, r22
    50b0:	8c 01       	movw	r16, r24
    50b2:	b5 01       	movw	r22, r10
    50b4:	6c 19       	sub	r22, r12
    50b6:	7d 09       	sbc	r23, r13
    50b8:	80 e0       	ldi	r24, 0x00	; 0
    50ba:	90 e0       	ldi	r25, 0x00	; 0
    50bc:	0e 94 f2 31 	call	0x63e4	; 0x63e4 <__floatunsisf>
    50c0:	9b 01       	movw	r18, r22
    50c2:	ac 01       	movw	r20, r24
    50c4:	c8 01       	movw	r24, r16
    50c6:	b7 01       	movw	r22, r14
    50c8:	0e 94 04 30 	call	0x6008	; 0x6008 <__divsf3>
    50cc:	69 83       	std	Y+1, r22	; 0x01
    50ce:	7a 83       	std	Y+2, r23	; 0x02
    50d0:	8b 83       	std	Y+3, r24	; 0x03
    50d2:	9c 83       	std	Y+4, r25	; 0x04
        b = y1 - a*x1;
    50d4:	b6 01       	movw	r22, r12
    50d6:	80 e0       	ldi	r24, 0x00	; 0
    50d8:	90 e0       	ldi	r25, 0x00	; 0
    50da:	0e 94 f2 31 	call	0x63e4	; 0x63e4 <__floatunsisf>
    50de:	9b 01       	movw	r18, r22
    50e0:	ac 01       	movw	r20, r24
    50e2:	69 81       	ldd	r22, Y+1	; 0x01
    50e4:	7a 81       	ldd	r23, Y+2	; 0x02
    50e6:	8b 81       	ldd	r24, Y+3	; 0x03
    50e8:	9c 81       	ldd	r25, Y+4	; 0x04
    50ea:	0e 94 0a 2f 	call	0x5e14	; 0x5e14 <__mulsf3>
    50ee:	7b 01       	movw	r14, r22
    50f0:	8c 01       	movw	r16, r24
    50f2:	b3 01       	movw	r22, r6
    50f4:	80 e0       	ldi	r24, 0x00	; 0
    50f6:	90 e0       	ldi	r25, 0x00	; 0
    50f8:	0e 94 f2 31 	call	0x63e4	; 0x63e4 <__floatunsisf>
    50fc:	a8 01       	movw	r20, r16
    50fe:	97 01       	movw	r18, r14
    5100:	0e 94 ac 2e 	call	0x5d58	; 0x5d58 <__subsf3>
    5104:	2b 01       	movw	r4, r22
    5106:	3c 01       	movw	r6, r24
        y00 = a*x1 + b;
    5108:	c8 01       	movw	r24, r16
    510a:	b7 01       	movw	r22, r14
    510c:	a3 01       	movw	r20, r6
    510e:	92 01       	movw	r18, r4
    5110:	0e 94 dd 2e 	call	0x5dba	; 0x5dba <__addsf3>
    5114:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    5118:	16 2f       	mov	r17, r22
        y010 = y00;    
                   
        for(i=(x1+1); i<=x2; i ++)
    511a:	fc 2c       	mov	r15, r12
    511c:	f3 94       	inc	r15
    511e:	06 2f       	mov	r16, r22
    5120:	66 c0       	rjmp	.+204    	; 0x51ee <line+0x23a>
        {
            y01 = a*i + b + 0.5; //+ 0.5 to approximate to the nearest integer
    5122:	2d 81       	ldd	r18, Y+5	; 0x05
    5124:	3e 81       	ldd	r19, Y+6	; 0x06
    5126:	b9 01       	movw	r22, r18
    5128:	88 27       	eor	r24, r24
    512a:	77 fd       	sbrc	r23, 7
    512c:	80 95       	com	r24
    512e:	98 2f       	mov	r25, r24
    5130:	0e 94 40 31 	call	0x6280	; 0x6280 <__floatsisf>
    5134:	9b 01       	movw	r18, r22
    5136:	ac 01       	movw	r20, r24
    5138:	69 81       	ldd	r22, Y+1	; 0x01
    513a:	7a 81       	ldd	r23, Y+2	; 0x02
    513c:	8b 81       	ldd	r24, Y+3	; 0x03
    513e:	9c 81       	ldd	r25, Y+4	; 0x04
    5140:	0e 94 0a 2f 	call	0x5e14	; 0x5e14 <__mulsf3>
    5144:	a3 01       	movw	r20, r6
    5146:	92 01       	movw	r18, r4
    5148:	0e 94 dd 2e 	call	0x5dba	; 0x5dba <__addsf3>
    514c:	20 e0       	ldi	r18, 0x00	; 0
    514e:	30 e0       	ldi	r19, 0x00	; 0
    5150:	40 e0       	ldi	r20, 0x00	; 0
    5152:	5f e3       	ldi	r21, 0x3F	; 63
    5154:	0e 94 dd 2e 	call	0x5dba	; 0x5dba <__addsf3>
    5158:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    515c:	e6 2e       	mov	r14, r22
                
            if( (signed char)(y01 - y010) > 1 )
    515e:	86 2f       	mov	r24, r22
    5160:	80 1b       	sub	r24, r16
    5162:	82 30       	cpi	r24, 0x02	; 2
    5164:	64 f0       	brlt	.+24     	; 0x517e <line+0x1ca>
            {
                v_line((i-1),(byte)(y010+1),(y01-y010-1),s,c);
    5166:	40 2f       	mov	r20, r16
    5168:	50 e0       	ldi	r21, 0x00	; 0
    516a:	40 95       	com	r20
    516c:	50 95       	com	r21
    516e:	4e 0d       	add	r20, r14
    5170:	51 1d       	adc	r21, r1
    5172:	8d 81       	ldd	r24, Y+5	; 0x05
    5174:	9e 81       	ldd	r25, Y+6	; 0x06
    5176:	01 97       	sbiw	r24, 0x01	; 1
    5178:	0f 5f       	subi	r16, 0xFF	; 255
    517a:	60 2f       	mov	r22, r16
    517c:	0f c0       	rjmp	.+30     	; 0x519c <line+0x1e8>
            }
            else if( (signed char)(y010 - y01) > 1 )
    517e:	80 2f       	mov	r24, r16
    5180:	8e 19       	sub	r24, r14
    5182:	82 30       	cpi	r24, 0x02	; 2
    5184:	84 f0       	brlt	.+32     	; 0x51a6 <line+0x1f2>
            {
                v_line((i-1),(byte)(y01+1),(y010-y01-1),s,c);
    5186:	6e 2d       	mov	r22, r14
    5188:	6f 5f       	subi	r22, 0xFF	; 255
    518a:	40 2f       	mov	r20, r16
    518c:	50 e0       	ldi	r21, 0x00	; 0
    518e:	41 50       	subi	r20, 0x01	; 1
    5190:	50 40       	sbci	r21, 0x00	; 0
    5192:	4e 19       	sub	r20, r14
    5194:	51 09       	sbc	r21, r1
    5196:	8d 81       	ldd	r24, Y+5	; 0x05
    5198:	9e 81       	ldd	r25, Y+6	; 0x06
    519a:	01 97       	sbiw	r24, 0x01	; 1
    519c:	70 e0       	ldi	r23, 0x00	; 0
    519e:	22 2d       	mov	r18, r2
    51a0:	03 2d       	mov	r16, r3
    51a2:	0e 94 94 13 	call	0x2728	; 0x2728 <v_line>
            } 
                       
            if((i==x2) && (y00 == y01)) h_line(x1,y01,(x2-x1),0,c);                                  
    51a6:	8d 81       	ldd	r24, Y+5	; 0x05
    51a8:	9e 81       	ldd	r25, Y+6	; 0x06
    51aa:	8a 15       	cp	r24, r10
    51ac:	9b 05       	cpc	r25, r11
    51ae:	61 f4       	brne	.+24     	; 0x51c8 <line+0x214>
    51b0:	1e 15       	cp	r17, r14
    51b2:	79 f4       	brne	.+30     	; 0x51d2 <line+0x21e>
    51b4:	4d 81       	ldd	r20, Y+5	; 0x05
    51b6:	4c 19       	sub	r20, r12
    51b8:	c6 01       	movw	r24, r12
    51ba:	61 2f       	mov	r22, r17
    51bc:	70 e0       	ldi	r23, 0x00	; 0
    51be:	20 e0       	ldi	r18, 0x00	; 0
    51c0:	03 2d       	mov	r16, r3
    51c2:	0e 94 6d 13 	call	0x26da	; 0x26da <h_line>
    51c6:	02 c0       	rjmp	.+4      	; 0x51cc <line+0x218>
            y010 = y01;       
            if( y00 ==  y01) continue;
    51c8:	1e 15       	cp	r17, r14
    51ca:	19 f4       	brne	.+6      	; 0x51d2 <line+0x21e>
    51cc:	de 82       	std	Y+6, r13	; 0x06
    51ce:	cd 82       	std	Y+5, r12	; 0x05
    51d0:	0a c0       	rjmp	.+20     	; 0x51e6 <line+0x232>
            h_line(x1,y00,(i-x1),0,c);
    51d2:	4f 2d       	mov	r20, r15
    51d4:	4c 19       	sub	r20, r12
    51d6:	c6 01       	movw	r24, r12
    51d8:	61 2f       	mov	r22, r17
    51da:	70 e0       	ldi	r23, 0x00	; 0
    51dc:	20 e0       	ldi	r18, 0x00	; 0
    51de:	03 2d       	mov	r16, r3
    51e0:	0e 94 6d 13 	call	0x26da	; 0x26da <h_line>
    51e4:	1e 2d       	mov	r17, r14
        a = (float)(signed)(y2-y1)/(x2-x1);
        b = y1 - a*x1;
        y00 = a*x1 + b;
        y010 = y00;    
                   
        for(i=(x1+1); i<=x2; i ++)
    51e6:	f3 94       	inc	r15
    51e8:	0e 2d       	mov	r16, r14
    51ea:	cd 80       	ldd	r12, Y+5	; 0x05
    51ec:	de 80       	ldd	r13, Y+6	; 0x06
    51ee:	ef 2d       	mov	r30, r15
    51f0:	f0 e0       	ldi	r31, 0x00	; 0
    51f2:	fe 83       	std	Y+6, r31	; 0x06
    51f4:	ed 83       	std	Y+5, r30	; 0x05
    51f6:	ae 16       	cp	r10, r30
    51f8:	bf 06       	cpc	r11, r31
    51fa:	08 f0       	brcs	.+2      	; 0x51fe <line+0x24a>
    51fc:	92 cf       	rjmp	.-220    	; 0x5122 <line+0x16e>
            if( y00 ==  y01) continue;
            h_line(x1,y00,(i-x1),0,c);
            x1 = i;
            y00 = y01;
        }
        point_at(x2,y2,c); 
    51fe:	c5 01       	movw	r24, r10
    5200:	b4 01       	movw	r22, r8
    5202:	43 2d       	mov	r20, r3
    5204:	0e 94 19 13 	call	0x2632	; 0x2632 <point_at>
    }          
}
    5208:	26 96       	adiw	r28, 0x06	; 6
    520a:	0f b6       	in	r0, 0x3f	; 63
    520c:	f8 94       	cli
    520e:	de bf       	out	0x3e, r29	; 62
    5210:	0f be       	out	0x3f, r0	; 63
    5212:	cd bf       	out	0x3d, r28	; 61
    5214:	cf 91       	pop	r28
    5216:	df 91       	pop	r29
    5218:	1f 91       	pop	r17
    521a:	0f 91       	pop	r16
    521c:	ff 90       	pop	r15
    521e:	ef 90       	pop	r14
    5220:	df 90       	pop	r13
    5222:	cf 90       	pop	r12
    5224:	bf 90       	pop	r11
    5226:	af 90       	pop	r10
    5228:	9f 90       	pop	r9
    522a:	8f 90       	pop	r8
    522c:	7f 90       	pop	r7
    522e:	6f 90       	pop	r6
    5230:	5f 90       	pop	r5
    5232:	4f 90       	pop	r4
    5234:	3f 90       	pop	r3
    5236:	2f 90       	pop	r2
    5238:	08 95       	ret

0000523a <v_parallelogram>:
}
//-----------------------
void v_parallelogram(unsigned int x1,unsigned int y1,
                     unsigned int x2,unsigned int y2,
                     byte l,byte s,byte c)
{
    523a:	2f 92       	push	r2
    523c:	3f 92       	push	r3
    523e:	4f 92       	push	r4
    5240:	5f 92       	push	r5
    5242:	6f 92       	push	r6
    5244:	7f 92       	push	r7
    5246:	8f 92       	push	r8
    5248:	9f 92       	push	r9
    524a:	af 92       	push	r10
    524c:	bf 92       	push	r11
    524e:	cf 92       	push	r12
    5250:	df 92       	push	r13
    5252:	ef 92       	push	r14
    5254:	ff 92       	push	r15
    5256:	0f 93       	push	r16
    5258:	1f 93       	push	r17
    525a:	2c 01       	movw	r4, r24
    525c:	3b 01       	movw	r6, r22
    525e:	1a 01       	movw	r2, r20
    5260:	49 01       	movw	r8, r18
    5262:	10 2f       	mov	r17, r16
    5264:	de 2c       	mov	r13, r14
    v_line(x1,y1,l,s,c);
    5266:	40 2f       	mov	r20, r16
    5268:	50 e0       	ldi	r21, 0x00	; 0
    526a:	2e 2d       	mov	r18, r14
    526c:	0c 2d       	mov	r16, r12
    526e:	0e 94 94 13 	call	0x2728	; 0x2728 <v_line>
    v_line(x2,(y2-l+1),l,s,c);
    5272:	a1 2e       	mov	r10, r17
    5274:	bb 24       	eor	r11, r11
    5276:	08 94       	sec
    5278:	81 1c       	adc	r8, r1
    527a:	91 1c       	adc	r9, r1
    527c:	74 01       	movw	r14, r8
    527e:	ea 18       	sub	r14, r10
    5280:	fb 08       	sbc	r15, r11
    5282:	08 94       	sec
    5284:	81 08       	sbc	r8, r1
    5286:	91 08       	sbc	r9, r1
    5288:	c1 01       	movw	r24, r2
    528a:	b7 01       	movw	r22, r14
    528c:	41 2f       	mov	r20, r17
    528e:	50 e0       	ldi	r21, 0x00	; 0
    5290:	2d 2d       	mov	r18, r13
    5292:	0e 94 94 13 	call	0x2728	; 0x2728 <v_line>
    line(x1,y1,x2,(y2-l+1),s,c);
    5296:	c2 01       	movw	r24, r4
    5298:	b3 01       	movw	r22, r6
    529a:	a1 01       	movw	r20, r2
    529c:	97 01       	movw	r18, r14
    529e:	0d 2d       	mov	r16, r13
    52a0:	ec 2c       	mov	r14, r12
    52a2:	0e 94 da 27 	call	0x4fb4	; 0x4fb4 <line>
    line(x1,(y1+l-1),x2,y2,s,c);
    52a6:	08 94       	sec
    52a8:	61 08       	sbc	r6, r1
    52aa:	71 08       	sbc	r7, r1
    52ac:	a6 0c       	add	r10, r6
    52ae:	b7 1c       	adc	r11, r7
    52b0:	c2 01       	movw	r24, r4
    52b2:	b5 01       	movw	r22, r10
    52b4:	a1 01       	movw	r20, r2
    52b6:	94 01       	movw	r18, r8
    52b8:	0e 94 da 27 	call	0x4fb4	; 0x4fb4 <line>
}
    52bc:	1f 91       	pop	r17
    52be:	0f 91       	pop	r16
    52c0:	ff 90       	pop	r15
    52c2:	ef 90       	pop	r14
    52c4:	df 90       	pop	r13
    52c6:	cf 90       	pop	r12
    52c8:	bf 90       	pop	r11
    52ca:	af 90       	pop	r10
    52cc:	9f 90       	pop	r9
    52ce:	8f 90       	pop	r8
    52d0:	7f 90       	pop	r7
    52d2:	6f 90       	pop	r6
    52d4:	5f 90       	pop	r5
    52d6:	4f 90       	pop	r4
    52d8:	3f 90       	pop	r3
    52da:	2f 90       	pop	r2
    52dc:	08 95       	ret

000052de <v_parallelepiped>:
void v_parallelepiped(unsigned int x11,unsigned int y11,
                      unsigned int x12,unsigned int y12,byte l1,
                      unsigned int x21,unsigned int y21,
                      unsigned int x22,unsigned int y22,byte l2,
                      byte s,byte c)
{
    52de:	2f 92       	push	r2
    52e0:	3f 92       	push	r3
    52e2:	4f 92       	push	r4
    52e4:	5f 92       	push	r5
    52e6:	6f 92       	push	r6
    52e8:	7f 92       	push	r7
    52ea:	8f 92       	push	r8
    52ec:	9f 92       	push	r9
    52ee:	af 92       	push	r10
    52f0:	bf 92       	push	r11
    52f2:	cf 92       	push	r12
    52f4:	df 92       	push	r13
    52f6:	ef 92       	push	r14
    52f8:	ff 92       	push	r15
    52fa:	0f 93       	push	r16
    52fc:	1f 93       	push	r17
    52fe:	df 93       	push	r29
    5300:	cf 93       	push	r28
    5302:	cd b7       	in	r28, 0x3d	; 61
    5304:	de b7       	in	r29, 0x3e	; 62
    5306:	29 97       	sbiw	r28, 0x09	; 9
    5308:	0f b6       	in	r0, 0x3f	; 63
    530a:	f8 94       	cli
    530c:	de bf       	out	0x3e, r29	; 62
    530e:	0f be       	out	0x3f, r0	; 63
    5310:	cd bf       	out	0x3d, r28	; 61
    5312:	9c 83       	std	Y+4, r25	; 0x04
    5314:	8b 83       	std	Y+3, r24	; 0x03
    5316:	2b 01       	movw	r4, r22
    5318:	5e 83       	std	Y+6, r21	; 0x06
    531a:	4d 83       	std	Y+5, r20	; 0x05
    531c:	19 01       	movw	r2, r18
    531e:	0f 83       	std	Y+7, r16	; 0x07
    5320:	f9 86       	std	Y+9, r15	; 0x09
    5322:	e8 86       	std	Y+8, r14	; 0x08
    5324:	36 01       	movw	r6, r12
    5326:	1f 8d       	ldd	r17, Y+31	; 0x1f
    5328:	f8 a0       	ldd	r15, Y+32	; 0x20
    v_parallelogram(x11,y11,x12,y12,l1,s,c);
    532a:	e1 2e       	mov	r14, r17
    532c:	cf 2c       	mov	r12, r15
    532e:	0e 94 1d 29 	call	0x523a	; 0x523a <v_parallelogram>
    v_parallelogram(x21,y21,x22,y22,l2,s,c);
    5332:	88 85       	ldd	r24, Y+8	; 0x08
    5334:	99 85       	ldd	r25, Y+9	; 0x09
    5336:	b3 01       	movw	r22, r6
    5338:	a5 01       	movw	r20, r10
    533a:	94 01       	movw	r18, r8
    533c:	0e 8d       	ldd	r16, Y+30	; 0x1e
    533e:	0e 94 1d 29 	call	0x523a	; 0x523a <v_parallelogram>
    line(x11,y11,x21,y21,s,c);
    5342:	8b 81       	ldd	r24, Y+3	; 0x03
    5344:	9c 81       	ldd	r25, Y+4	; 0x04
    5346:	b2 01       	movw	r22, r4
    5348:	48 85       	ldd	r20, Y+8	; 0x08
    534a:	59 85       	ldd	r21, Y+9	; 0x09
    534c:	93 01       	movw	r18, r6
    534e:	01 2f       	mov	r16, r17
    5350:	ef 2c       	mov	r14, r15
    5352:	0e 94 da 27 	call	0x4fb4	; 0x4fb4 <line>
    line(x12,y12,x22,y22,s,c);
    5356:	8d 81       	ldd	r24, Y+5	; 0x05
    5358:	9e 81       	ldd	r25, Y+6	; 0x06
    535a:	b1 01       	movw	r22, r2
    535c:	a5 01       	movw	r20, r10
    535e:	94 01       	movw	r18, r8
    5360:	0e 94 da 27 	call	0x4fb4	; 0x4fb4 <line>
    line(x11,(y11+l1-1),x21,(y21+l2-1),s,c);
    5364:	8f 81       	ldd	r24, Y+7	; 0x07
    5366:	c8 2e       	mov	r12, r24
    5368:	dd 24       	eor	r13, r13
    536a:	9e 8d       	ldd	r25, Y+30	; 0x1e
    536c:	89 2f       	mov	r24, r25
    536e:	90 e0       	ldi	r25, 0x00	; 0
    5370:	9a 83       	std	Y+2, r25	; 0x02
    5372:	89 83       	std	Y+1, r24	; 0x01
    5374:	08 94       	sec
    5376:	41 08       	sbc	r4, r1
    5378:	51 08       	sbc	r5, r1
    537a:	4c 0c       	add	r4, r12
    537c:	5d 1c       	adc	r5, r13
    537e:	08 94       	sec
    5380:	61 08       	sbc	r6, r1
    5382:	71 08       	sbc	r7, r1
    5384:	68 0e       	add	r6, r24
    5386:	79 1e       	adc	r7, r25
    5388:	8b 81       	ldd	r24, Y+3	; 0x03
    538a:	9c 81       	ldd	r25, Y+4	; 0x04
    538c:	b2 01       	movw	r22, r4
    538e:	48 85       	ldd	r20, Y+8	; 0x08
    5390:	59 85       	ldd	r21, Y+9	; 0x09
    5392:	93 01       	movw	r18, r6
    5394:	0e 94 da 27 	call	0x4fb4	; 0x4fb4 <line>
    line(x12,(y12-l1+1),x22,(y22-l2+1),s,c);
    5398:	08 94       	sec
    539a:	21 1c       	adc	r2, r1
    539c:	31 1c       	adc	r3, r1
    539e:	2c 18       	sub	r2, r12
    53a0:	3d 08       	sbc	r3, r13
    53a2:	08 94       	sec
    53a4:	81 1c       	adc	r8, r1
    53a6:	91 1c       	adc	r9, r1
    53a8:	89 81       	ldd	r24, Y+1	; 0x01
    53aa:	9a 81       	ldd	r25, Y+2	; 0x02
    53ac:	88 1a       	sub	r8, r24
    53ae:	99 0a       	sbc	r9, r25
    53b0:	8d 81       	ldd	r24, Y+5	; 0x05
    53b2:	9e 81       	ldd	r25, Y+6	; 0x06
    53b4:	b1 01       	movw	r22, r2
    53b6:	a5 01       	movw	r20, r10
    53b8:	94 01       	movw	r18, r8
    53ba:	0e 94 da 27 	call	0x4fb4	; 0x4fb4 <line>
}
    53be:	29 96       	adiw	r28, 0x09	; 9
    53c0:	0f b6       	in	r0, 0x3f	; 63
    53c2:	f8 94       	cli
    53c4:	de bf       	out	0x3e, r29	; 62
    53c6:	0f be       	out	0x3f, r0	; 63
    53c8:	cd bf       	out	0x3d, r28	; 61
    53ca:	cf 91       	pop	r28
    53cc:	df 91       	pop	r29
    53ce:	1f 91       	pop	r17
    53d0:	0f 91       	pop	r16
    53d2:	ff 90       	pop	r15
    53d4:	ef 90       	pop	r14
    53d6:	df 90       	pop	r13
    53d8:	cf 90       	pop	r12
    53da:	bf 90       	pop	r11
    53dc:	af 90       	pop	r10
    53de:	9f 90       	pop	r9
    53e0:	8f 90       	pop	r8
    53e2:	7f 90       	pop	r7
    53e4:	6f 90       	pop	r6
    53e6:	5f 90       	pop	r5
    53e8:	4f 90       	pop	r4
    53ea:	3f 90       	pop	r3
    53ec:	2f 90       	pop	r2
    53ee:	08 95       	ret

000053f0 <h_parallelogram>:
}
//-----------------------
void h_parallelogram(unsigned int x1,unsigned int y1,
                     unsigned int x2,unsigned int y2,
                     byte l,byte s,byte c)// horizontal parallelogram (x,y,length,space between points,color)
{
    53f0:	2f 92       	push	r2
    53f2:	3f 92       	push	r3
    53f4:	4f 92       	push	r4
    53f6:	5f 92       	push	r5
    53f8:	6f 92       	push	r6
    53fa:	7f 92       	push	r7
    53fc:	8f 92       	push	r8
    53fe:	9f 92       	push	r9
    5400:	af 92       	push	r10
    5402:	bf 92       	push	r11
    5404:	cf 92       	push	r12
    5406:	df 92       	push	r13
    5408:	ef 92       	push	r14
    540a:	ff 92       	push	r15
    540c:	0f 93       	push	r16
    540e:	1f 93       	push	r17
    5410:	4c 01       	movw	r8, r24
    5412:	3b 01       	movw	r6, r22
    5414:	5a 01       	movw	r10, r20
    5416:	29 01       	movw	r4, r18
    5418:	10 2f       	mov	r17, r16
    541a:	de 2c       	mov	r13, r14
    h_line(x1,y1,l,s,c);
    541c:	40 2f       	mov	r20, r16
    541e:	2e 2d       	mov	r18, r14
    5420:	0c 2d       	mov	r16, r12
    5422:	0e 94 6d 13 	call	0x26da	; 0x26da <h_line>
    h_line((x2-l+1),y2,l,s,c);
    5426:	21 2e       	mov	r2, r17
    5428:	33 24       	eor	r3, r3
    542a:	08 94       	sec
    542c:	a1 1c       	adc	r10, r1
    542e:	b1 1c       	adc	r11, r1
    5430:	75 01       	movw	r14, r10
    5432:	e2 18       	sub	r14, r2
    5434:	f3 08       	sbc	r15, r3
    5436:	08 94       	sec
    5438:	a1 08       	sbc	r10, r1
    543a:	b1 08       	sbc	r11, r1
    543c:	c7 01       	movw	r24, r14
    543e:	b2 01       	movw	r22, r4
    5440:	41 2f       	mov	r20, r17
    5442:	2d 2d       	mov	r18, r13
    5444:	0e 94 6d 13 	call	0x26da	; 0x26da <h_line>
    line(x1,y1,(x2-l+1),y2,s,c);
    5448:	c4 01       	movw	r24, r8
    544a:	b3 01       	movw	r22, r6
    544c:	a7 01       	movw	r20, r14
    544e:	92 01       	movw	r18, r4
    5450:	0d 2d       	mov	r16, r13
    5452:	ec 2c       	mov	r14, r12
    5454:	0e 94 da 27 	call	0x4fb4	; 0x4fb4 <line>
    line((x1+l-1),y1,x2,y2,s,c);
    5458:	08 94       	sec
    545a:	81 08       	sbc	r8, r1
    545c:	91 08       	sbc	r9, r1
    545e:	c4 01       	movw	r24, r8
    5460:	82 0d       	add	r24, r2
    5462:	93 1d       	adc	r25, r3
    5464:	b3 01       	movw	r22, r6
    5466:	a5 01       	movw	r20, r10
    5468:	92 01       	movw	r18, r4
    546a:	0e 94 da 27 	call	0x4fb4	; 0x4fb4 <line>
}
    546e:	1f 91       	pop	r17
    5470:	0f 91       	pop	r16
    5472:	ff 90       	pop	r15
    5474:	ef 90       	pop	r14
    5476:	df 90       	pop	r13
    5478:	cf 90       	pop	r12
    547a:	bf 90       	pop	r11
    547c:	af 90       	pop	r10
    547e:	9f 90       	pop	r9
    5480:	8f 90       	pop	r8
    5482:	7f 90       	pop	r7
    5484:	6f 90       	pop	r6
    5486:	5f 90       	pop	r5
    5488:	4f 90       	pop	r4
    548a:	3f 90       	pop	r3
    548c:	2f 90       	pop	r2
    548e:	08 95       	ret

00005490 <h_parallelepiped>:
void h_parallelepiped(unsigned int x11,unsigned int y11,
                      unsigned int x12,unsigned int y12,byte l1,
                      unsigned int x21,unsigned int y21,
                      unsigned int x22,unsigned int y22,byte l2,
                      byte s,byte c)
{
    5490:	2f 92       	push	r2
    5492:	3f 92       	push	r3
    5494:	4f 92       	push	r4
    5496:	5f 92       	push	r5
    5498:	6f 92       	push	r6
    549a:	7f 92       	push	r7
    549c:	8f 92       	push	r8
    549e:	9f 92       	push	r9
    54a0:	af 92       	push	r10
    54a2:	bf 92       	push	r11
    54a4:	cf 92       	push	r12
    54a6:	df 92       	push	r13
    54a8:	ef 92       	push	r14
    54aa:	ff 92       	push	r15
    54ac:	0f 93       	push	r16
    54ae:	1f 93       	push	r17
    54b0:	df 93       	push	r29
    54b2:	cf 93       	push	r28
    54b4:	cd b7       	in	r28, 0x3d	; 61
    54b6:	de b7       	in	r29, 0x3e	; 62
    54b8:	28 97       	sbiw	r28, 0x08	; 8
    54ba:	0f b6       	in	r0, 0x3f	; 63
    54bc:	f8 94       	cli
    54be:	de bf       	out	0x3e, r29	; 62
    54c0:	0f be       	out	0x3f, r0	; 63
    54c2:	cd bf       	out	0x3d, r28	; 61
    54c4:	2c 01       	movw	r4, r24
    54c6:	7a 83       	std	Y+2, r23	; 0x02
    54c8:	69 83       	std	Y+1, r22	; 0x01
    54ca:	5c 83       	std	Y+4, r21	; 0x04
    54cc:	4b 83       	std	Y+3, r20	; 0x03
    54ce:	3e 83       	std	Y+6, r19	; 0x06
    54d0:	2d 83       	std	Y+5, r18	; 0x05
    54d2:	30 2e       	mov	r3, r16
    54d4:	37 01       	movw	r6, r14
    54d6:	d8 86       	std	Y+8, r13	; 0x08
    54d8:	cf 82       	std	Y+7, r12	; 0x07
    54da:	2d 8c       	ldd	r2, Y+29	; 0x1d
    54dc:	1e 8d       	ldd	r17, Y+30	; 0x1e
    54de:	ff 8c       	ldd	r15, Y+31	; 0x1f
    h_parallelogram(x11,y11,x12,y12,l1,s,c);
    54e0:	e1 2e       	mov	r14, r17
    54e2:	cf 2c       	mov	r12, r15
    54e4:	0e 94 f8 29 	call	0x53f0	; 0x53f0 <h_parallelogram>
    h_parallelogram(x21,y21,x22,y22,l2,s,c);
    54e8:	c3 01       	movw	r24, r6
    54ea:	6f 81       	ldd	r22, Y+7	; 0x07
    54ec:	78 85       	ldd	r23, Y+8	; 0x08
    54ee:	a5 01       	movw	r20, r10
    54f0:	94 01       	movw	r18, r8
    54f2:	02 2d       	mov	r16, r2
    54f4:	0e 94 f8 29 	call	0x53f0	; 0x53f0 <h_parallelogram>
    line(x11,y11,x21,y21,s,c);
    54f8:	c2 01       	movw	r24, r4
    54fa:	69 81       	ldd	r22, Y+1	; 0x01
    54fc:	7a 81       	ldd	r23, Y+2	; 0x02
    54fe:	a3 01       	movw	r20, r6
    5500:	2f 81       	ldd	r18, Y+7	; 0x07
    5502:	38 85       	ldd	r19, Y+8	; 0x08
    5504:	01 2f       	mov	r16, r17
    5506:	ef 2c       	mov	r14, r15
    5508:	0e 94 da 27 	call	0x4fb4	; 0x4fb4 <line>
    line(x12,y12,x22,y22,s,c);
    550c:	8b 81       	ldd	r24, Y+3	; 0x03
    550e:	9c 81       	ldd	r25, Y+4	; 0x04
    5510:	6d 81       	ldd	r22, Y+5	; 0x05
    5512:	7e 81       	ldd	r23, Y+6	; 0x06
    5514:	a5 01       	movw	r20, r10
    5516:	94 01       	movw	r18, r8
    5518:	0e 94 da 27 	call	0x4fb4	; 0x4fb4 <line>
    line((x11+l1-1),y11,(x21+l2-1),y21,s,c);
    551c:	c3 2c       	mov	r12, r3
    551e:	dd 24       	eor	r13, r13
    5520:	33 24       	eor	r3, r3
    5522:	08 94       	sec
    5524:	41 08       	sbc	r4, r1
    5526:	51 08       	sbc	r5, r1
    5528:	08 94       	sec
    552a:	61 08       	sbc	r6, r1
    552c:	71 08       	sbc	r7, r1
    552e:	62 0c       	add	r6, r2
    5530:	73 1c       	adc	r7, r3
    5532:	c2 01       	movw	r24, r4
    5534:	8c 0d       	add	r24, r12
    5536:	9d 1d       	adc	r25, r13
    5538:	69 81       	ldd	r22, Y+1	; 0x01
    553a:	7a 81       	ldd	r23, Y+2	; 0x02
    553c:	a3 01       	movw	r20, r6
    553e:	2f 81       	ldd	r18, Y+7	; 0x07
    5540:	38 85       	ldd	r19, Y+8	; 0x08
    5542:	0e 94 da 27 	call	0x4fb4	; 0x4fb4 <line>
    line((x12-l1+1),y12,(x22-l2+1),y22,s,c);
    5546:	8b 81       	ldd	r24, Y+3	; 0x03
    5548:	9c 81       	ldd	r25, Y+4	; 0x04
    554a:	01 96       	adiw	r24, 0x01	; 1
    554c:	9c 83       	std	Y+4, r25	; 0x04
    554e:	8b 83       	std	Y+3, r24	; 0x03
    5550:	08 94       	sec
    5552:	a1 1c       	adc	r10, r1
    5554:	b1 1c       	adc	r11, r1
    5556:	a2 18       	sub	r10, r2
    5558:	b3 08       	sbc	r11, r3
    555a:	8c 19       	sub	r24, r12
    555c:	9d 09       	sbc	r25, r13
    555e:	6d 81       	ldd	r22, Y+5	; 0x05
    5560:	7e 81       	ldd	r23, Y+6	; 0x06
    5562:	a5 01       	movw	r20, r10
    5564:	94 01       	movw	r18, r8
    5566:	0e 94 da 27 	call	0x4fb4	; 0x4fb4 <line>
}
    556a:	28 96       	adiw	r28, 0x08	; 8
    556c:	0f b6       	in	r0, 0x3f	; 63
    556e:	f8 94       	cli
    5570:	de bf       	out	0x3e, r29	; 62
    5572:	0f be       	out	0x3f, r0	; 63
    5574:	cd bf       	out	0x3d, r28	; 61
    5576:	cf 91       	pop	r28
    5578:	df 91       	pop	r29
    557a:	1f 91       	pop	r17
    557c:	0f 91       	pop	r16
    557e:	ff 90       	pop	r15
    5580:	ef 90       	pop	r14
    5582:	df 90       	pop	r13
    5584:	cf 90       	pop	r12
    5586:	bf 90       	pop	r11
    5588:	af 90       	pop	r10
    558a:	9f 90       	pop	r9
    558c:	8f 90       	pop	r8
    558e:	7f 90       	pop	r7
    5590:	6f 90       	pop	r6
    5592:	5f 90       	pop	r5
    5594:	4f 90       	pop	r4
    5596:	3f 90       	pop	r3
    5598:	2f 90       	pop	r2
    559a:	08 95       	ret

0000559c <cuboid>:
void cuboid(unsigned int x11,unsigned int y11,
            unsigned int x12,unsigned int y12,
            unsigned int x21,unsigned int y21,
            unsigned int x22,unsigned int y22,
            byte s,byte c)
{
    559c:	2f 92       	push	r2
    559e:	3f 92       	push	r3
    55a0:	4f 92       	push	r4
    55a2:	5f 92       	push	r5
    55a4:	6f 92       	push	r6
    55a6:	7f 92       	push	r7
    55a8:	8f 92       	push	r8
    55aa:	af 92       	push	r10
    55ac:	bf 92       	push	r11
    55ae:	cf 92       	push	r12
    55b0:	df 92       	push	r13
    55b2:	ef 92       	push	r14
    55b4:	ff 92       	push	r15
    55b6:	0f 93       	push	r16
    55b8:	1f 93       	push	r17
    55ba:	df 93       	push	r29
    55bc:	cf 93       	push	r28
    55be:	00 d0       	rcall	.+0      	; 0x55c0 <cuboid+0x24>
    55c0:	00 d0       	rcall	.+0      	; 0x55c2 <cuboid+0x26>
    55c2:	00 d0       	rcall	.+0      	; 0x55c4 <cuboid+0x28>
    55c4:	cd b7       	in	r28, 0x3d	; 61
    55c6:	de b7       	in	r29, 0x3e	; 62
    55c8:	9a 83       	std	Y+2, r25	; 0x02
    55ca:	89 83       	std	Y+1, r24	; 0x01
    55cc:	2b 01       	movw	r4, r22
    55ce:	5c 83       	std	Y+4, r21	; 0x04
    55d0:	4b 83       	std	Y+3, r20	; 0x03
    55d2:	3e 83       	std	Y+6, r19	; 0x06
    55d4:	2d 83       	std	Y+5, r18	; 0x05
    55d6:	18 01       	movw	r2, r16
    55d8:	37 01       	movw	r6, r14
    55da:	1a 8d       	ldd	r17, Y+26	; 0x1a
    rectangle(x11,y11,x12,y12,s,c);
    55dc:	08 2d       	mov	r16, r8
    55de:	e1 2e       	mov	r14, r17
    55e0:	0e 94 bb 13 	call	0x2776	; 0x2776 <rectangle>
    rectangle(x21,y21,x22,y22,s,c);
    55e4:	c1 01       	movw	r24, r2
    55e6:	b3 01       	movw	r22, r6
    55e8:	a6 01       	movw	r20, r12
    55ea:	95 01       	movw	r18, r10
    55ec:	0e 94 bb 13 	call	0x2776	; 0x2776 <rectangle>
    line(x11,y11,x21,y21,s,c);
    55f0:	89 81       	ldd	r24, Y+1	; 0x01
    55f2:	9a 81       	ldd	r25, Y+2	; 0x02
    55f4:	b2 01       	movw	r22, r4
    55f6:	a1 01       	movw	r20, r2
    55f8:	93 01       	movw	r18, r6
    55fa:	0e 94 da 27 	call	0x4fb4	; 0x4fb4 <line>
    line(x12,y11,x22,y21,s,c);
    55fe:	8b 81       	ldd	r24, Y+3	; 0x03
    5600:	9c 81       	ldd	r25, Y+4	; 0x04
    5602:	b2 01       	movw	r22, r4
    5604:	a6 01       	movw	r20, r12
    5606:	93 01       	movw	r18, r6
    5608:	0e 94 da 27 	call	0x4fb4	; 0x4fb4 <line>
    line(x11,y12,x21,y22,s,c);
    560c:	89 81       	ldd	r24, Y+1	; 0x01
    560e:	9a 81       	ldd	r25, Y+2	; 0x02
    5610:	6d 81       	ldd	r22, Y+5	; 0x05
    5612:	7e 81       	ldd	r23, Y+6	; 0x06
    5614:	a1 01       	movw	r20, r2
    5616:	95 01       	movw	r18, r10
    5618:	0e 94 da 27 	call	0x4fb4	; 0x4fb4 <line>
    line(x12,y12,x22,y22,s,c);
    561c:	8b 81       	ldd	r24, Y+3	; 0x03
    561e:	9c 81       	ldd	r25, Y+4	; 0x04
    5620:	6d 81       	ldd	r22, Y+5	; 0x05
    5622:	7e 81       	ldd	r23, Y+6	; 0x06
    5624:	a6 01       	movw	r20, r12
    5626:	95 01       	movw	r18, r10
    5628:	0e 94 da 27 	call	0x4fb4	; 0x4fb4 <line>
}
    562c:	26 96       	adiw	r28, 0x06	; 6
    562e:	0f b6       	in	r0, 0x3f	; 63
    5630:	f8 94       	cli
    5632:	de bf       	out	0x3e, r29	; 62
    5634:	0f be       	out	0x3f, r0	; 63
    5636:	cd bf       	out	0x3d, r28	; 61
    5638:	cf 91       	pop	r28
    563a:	df 91       	pop	r29
    563c:	1f 91       	pop	r17
    563e:	0f 91       	pop	r16
    5640:	ff 90       	pop	r15
    5642:	ef 90       	pop	r14
    5644:	df 90       	pop	r13
    5646:	cf 90       	pop	r12
    5648:	bf 90       	pop	r11
    564a:	af 90       	pop	r10
    564c:	8f 90       	pop	r8
    564e:	7f 90       	pop	r7
    5650:	6f 90       	pop	r6
    5652:	5f 90       	pop	r5
    5654:	4f 90       	pop	r4
    5656:	3f 90       	pop	r3
    5658:	2f 90       	pop	r2
    565a:	08 95       	ret

0000565c <circle>:
    line(x12,(y12-l1+1),x22,(y22-l2+1),s,c);
}
//-----------------------
void circle(unsigned int x0,unsigned int y0,
            unsigned int r,byte s,byte c)
{
    565c:	2f 92       	push	r2
    565e:	3f 92       	push	r3
    5660:	4f 92       	push	r4
    5662:	5f 92       	push	r5
    5664:	6f 92       	push	r6
    5666:	8f 92       	push	r8
    5668:	9f 92       	push	r9
    566a:	af 92       	push	r10
    566c:	bf 92       	push	r11
    566e:	cf 92       	push	r12
    5670:	df 92       	push	r13
    5672:	ef 92       	push	r14
    5674:	ff 92       	push	r15
    5676:	0f 93       	push	r16
    5678:	1f 93       	push	r17
    567a:	df 93       	push	r29
    567c:	cf 93       	push	r28
    567e:	cd b7       	in	r28, 0x3d	; 61
    5680:	de b7       	in	r29, 0x3e	; 62
    5682:	69 97       	sbiw	r28, 0x19	; 25
    5684:	0f b6       	in	r0, 0x3f	; 63
    5686:	f8 94       	cli
    5688:	de bf       	out	0x3e, r29	; 62
    568a:	0f be       	out	0x3f, r0	; 63
    568c:	cd bf       	out	0x3d, r28	; 61
    568e:	9b 87       	std	Y+11, r25	; 0x0b
    5690:	8a 87       	std	Y+10, r24	; 0x0a
    5692:	7d 87       	std	Y+13, r23	; 0x0d
    5694:	6c 87       	std	Y+12, r22	; 0x0c
    5696:	5f 87       	std	Y+15, r21	; 0x0f
    5698:	4e 87       	std	Y+14, r20	; 0x0e
    569a:	62 2e       	mov	r6, r18
    569c:	40 2e       	mov	r4, r16
    byte i,y,y00;
    y00 = r;            //Point (0,r) is the 1st point
    569e:	ae 84       	ldd	r10, Y+14	; 0x0e
    for(i=0; i<r; i++)
    {
        y = sqrt((int)r*r - (int)i*i);
    56a0:	44 9f       	mul	r20, r20
    56a2:	90 01       	movw	r18, r0
    56a4:	45 9f       	mul	r20, r21
    56a6:	30 0d       	add	r19, r0
    56a8:	54 9f       	mul	r21, r20
    56aa:	30 0d       	add	r19, r0
    56ac:	11 24       	eor	r1, r1
    56ae:	39 87       	std	Y+9, r19	; 0x09
    56b0:	28 87       	std	Y+8, r18	; 0x08
    56b2:	19 82       	std	Y+1, r1	; 0x01
        point_at((x0+i),(y0-y),c);
        point_at((x0-i),(y0+y),c);
        point_at((x0-i),(y0-y),c);        
        if(abs(y00-y)>1)
        {
            v_line(x0+(i-1),y0+fmin(y00,y)+1,abs(y00-y),s,c);
    56b4:	cb 01       	movw	r24, r22
    56b6:	a0 e0       	ldi	r26, 0x00	; 0
    56b8:	b0 e0       	ldi	r27, 0x00	; 0
    56ba:	8c 8b       	std	Y+20, r24	; 0x14
    56bc:	9d 8b       	std	Y+21, r25	; 0x15
    56be:	ae 8b       	std	Y+22, r26	; 0x16
    56c0:	bf 8b       	std	Y+23, r27	; 0x17
    56c2:	c0 c0       	rjmp	.+384    	; 0x5844 <circle+0x1e8>
{
    byte i,y,y00;
    y00 = r;            //Point (0,r) is the 1st point
    for(i=0; i<r; i++)
    {
        y = sqrt((int)r*r - (int)i*i);
    56c4:	88 9c       	mul	r8, r8
    56c6:	c0 01       	movw	r24, r0
    56c8:	89 9c       	mul	r8, r9
    56ca:	90 0d       	add	r25, r0
    56cc:	98 9c       	mul	r9, r8
    56ce:	90 0d       	add	r25, r0
    56d0:	11 24       	eor	r1, r1
    56d2:	68 85       	ldd	r22, Y+8	; 0x08
    56d4:	79 85       	ldd	r23, Y+9	; 0x09
    56d6:	68 1b       	sub	r22, r24
    56d8:	79 0b       	sbc	r23, r25
    56da:	80 e0       	ldi	r24, 0x00	; 0
    56dc:	90 e0       	ldi	r25, 0x00	; 0
    56de:	0e 94 f2 31 	call	0x63e4	; 0x63e4 <__floatunsisf>
    56e2:	0e 94 d9 34 	call	0x69b2	; 0x69b2 <sqrt>
    56e6:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    56ea:	56 2e       	mov	r5, r22
        point_at((x0+i),(y0+y),c);
    56ec:	2a 84       	ldd	r2, Y+10	; 0x0a
    56ee:	3b 84       	ldd	r3, Y+11	; 0x0b
    56f0:	28 0c       	add	r2, r8
    56f2:	39 1c       	adc	r3, r9
    56f4:	06 2f       	mov	r16, r22
    56f6:	10 e0       	ldi	r17, 0x00	; 0
    56f8:	cc 84       	ldd	r12, Y+12	; 0x0c
    56fa:	dd 84       	ldd	r13, Y+13	; 0x0d
    56fc:	c0 0e       	add	r12, r16
    56fe:	d1 1e       	adc	r13, r17
    5700:	c1 01       	movw	r24, r2
    5702:	b6 01       	movw	r22, r12
    5704:	44 2d       	mov	r20, r4
    5706:	0e 94 19 13 	call	0x2632	; 0x2632 <point_at>
        point_at((x0+i),(y0-y),c);
    570a:	ec 84       	ldd	r14, Y+12	; 0x0c
    570c:	fd 84       	ldd	r15, Y+13	; 0x0d
    570e:	e0 1a       	sub	r14, r16
    5710:	f1 0a       	sbc	r15, r17
    5712:	c1 01       	movw	r24, r2
    5714:	b7 01       	movw	r22, r14
    5716:	44 2d       	mov	r20, r4
    5718:	0e 94 19 13 	call	0x2632	; 0x2632 <point_at>
        point_at((x0-i),(y0+y),c);
    571c:	ea 85       	ldd	r30, Y+10	; 0x0a
    571e:	fb 85       	ldd	r31, Y+11	; 0x0b
    5720:	e8 19       	sub	r30, r8
    5722:	f9 09       	sbc	r31, r9
    5724:	ff 83       	std	Y+7, r31	; 0x07
    5726:	ee 83       	std	Y+6, r30	; 0x06
    5728:	cf 01       	movw	r24, r30
    572a:	b6 01       	movw	r22, r12
    572c:	44 2d       	mov	r20, r4
    572e:	0e 94 19 13 	call	0x2632	; 0x2632 <point_at>
        point_at((x0-i),(y0-y),c);        
    5732:	8e 81       	ldd	r24, Y+6	; 0x06
    5734:	9f 81       	ldd	r25, Y+7	; 0x07
    5736:	b7 01       	movw	r22, r14
    5738:	44 2d       	mov	r20, r4
    573a:	0e 94 19 13 	call	0x2632	; 0x2632 <point_at>
        if(abs(y00-y)>1)
    573e:	2a 2d       	mov	r18, r10
    5740:	30 e0       	ldi	r19, 0x00	; 0
    5742:	20 1b       	sub	r18, r16
    5744:	31 0b       	sbc	r19, r17
    5746:	39 8f       	std	Y+25, r19	; 0x19
    5748:	28 8f       	std	Y+24, r18	; 0x18
    574a:	37 ff       	sbrs	r19, 7
    574c:	05 c0       	rjmp	.+10     	; 0x5758 <circle+0xfc>
    574e:	30 95       	com	r19
    5750:	21 95       	neg	r18
    5752:	3f 4f       	sbci	r19, 0xFF	; 255
    5754:	39 8f       	std	Y+25, r19	; 0x19
    5756:	28 8f       	std	Y+24, r18	; 0x18
    5758:	88 8d       	ldd	r24, Y+24	; 0x18
    575a:	99 8d       	ldd	r25, Y+25	; 0x19
    575c:	02 97       	sbiw	r24, 0x02	; 2
    575e:	0c f4       	brge	.+2      	; 0x5762 <circle+0x106>
    5760:	6d c0       	rjmp	.+218    	; 0x583c <circle+0x1e0>
        {
            v_line(x0+(i-1),y0+fmin(y00,y)+1,abs(y00-y),s,c);
    5762:	08 94       	sec
    5764:	21 08       	sbc	r2, r1
    5766:	31 08       	sbc	r3, r1
    5768:	6c 89       	ldd	r22, Y+20	; 0x14
    576a:	7d 89       	ldd	r23, Y+21	; 0x15
    576c:	8e 89       	ldd	r24, Y+22	; 0x16
    576e:	9f 89       	ldd	r25, Y+23	; 0x17
    5770:	0e 94 f2 31 	call	0x63e4	; 0x63e4 <__floatunsisf>
    5774:	6a 83       	std	Y+2, r22	; 0x02
    5776:	7b 83       	std	Y+3, r23	; 0x03
    5778:	8c 83       	std	Y+4, r24	; 0x04
    577a:	9d 83       	std	Y+5, r25	; 0x05
    577c:	6a 2d       	mov	r22, r10
    577e:	70 e0       	ldi	r23, 0x00	; 0
    5780:	80 e0       	ldi	r24, 0x00	; 0
    5782:	90 e0       	ldi	r25, 0x00	; 0
    5784:	0e 94 f2 31 	call	0x63e4	; 0x63e4 <__floatunsisf>
    5788:	4b 01       	movw	r8, r22
    578a:	5c 01       	movw	r10, r24
    578c:	65 2d       	mov	r22, r5
    578e:	70 e0       	ldi	r23, 0x00	; 0
    5790:	80 e0       	ldi	r24, 0x00	; 0
    5792:	90 e0       	ldi	r25, 0x00	; 0
    5794:	0e 94 f2 31 	call	0x63e4	; 0x63e4 <__floatunsisf>
    5798:	6b 01       	movw	r12, r22
    579a:	7c 01       	movw	r14, r24
    579c:	c5 01       	movw	r24, r10
    579e:	b4 01       	movw	r22, r8
    57a0:	a7 01       	movw	r20, r14
    57a2:	96 01       	movw	r18, r12
    57a4:	0e 94 b6 34 	call	0x696c	; 0x696c <fmin>
    57a8:	9b 01       	movw	r18, r22
    57aa:	ac 01       	movw	r20, r24
    57ac:	6a 81       	ldd	r22, Y+2	; 0x02
    57ae:	7b 81       	ldd	r23, Y+3	; 0x03
    57b0:	8c 81       	ldd	r24, Y+4	; 0x04
    57b2:	9d 81       	ldd	r25, Y+5	; 0x05
    57b4:	0e 94 dd 2e 	call	0x5dba	; 0x5dba <__addsf3>
    57b8:	20 e0       	ldi	r18, 0x00	; 0
    57ba:	30 e0       	ldi	r19, 0x00	; 0
    57bc:	40 e8       	ldi	r20, 0x80	; 128
    57be:	5f e3       	ldi	r21, 0x3F	; 63
    57c0:	0e 94 dd 2e 	call	0x5dba	; 0x5dba <__addsf3>
    57c4:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    57c8:	68 8b       	std	Y+16, r22	; 0x10
    57ca:	79 8b       	std	Y+17, r23	; 0x11
    57cc:	8a 8b       	std	Y+18, r24	; 0x12
    57ce:	9b 8b       	std	Y+19, r25	; 0x13
    57d0:	c1 01       	movw	r24, r2
    57d2:	68 89       	ldd	r22, Y+16	; 0x10
    57d4:	79 89       	ldd	r23, Y+17	; 0x11
    57d6:	48 8d       	ldd	r20, Y+24	; 0x18
    57d8:	59 8d       	ldd	r21, Y+25	; 0x19
    57da:	26 2d       	mov	r18, r6
    57dc:	04 2d       	mov	r16, r4
    57de:	0e 94 94 13 	call	0x2728	; 0x2728 <v_line>
            v_line(x0+(i-1),y0-fmax(y00,y),abs(y00-y),s,c);
    57e2:	c5 01       	movw	r24, r10
    57e4:	b4 01       	movw	r22, r8
    57e6:	a7 01       	movw	r20, r14
    57e8:	96 01       	movw	r18, r12
    57ea:	0e 94 97 34 	call	0x692e	; 0x692e <fmax>
    57ee:	9b 01       	movw	r18, r22
    57f0:	ac 01       	movw	r20, r24
    57f2:	6a 81       	ldd	r22, Y+2	; 0x02
    57f4:	7b 81       	ldd	r23, Y+3	; 0x03
    57f6:	8c 81       	ldd	r24, Y+4	; 0x04
    57f8:	9d 81       	ldd	r25, Y+5	; 0x05
    57fa:	0e 94 ac 2e 	call	0x5d58	; 0x5d58 <__subsf3>
    57fe:	0e 94 34 2d 	call	0x5a68	; 0x5a68 <__fixunssfsi>
    5802:	5b 01       	movw	r10, r22
    5804:	6c 01       	movw	r12, r24
    5806:	c1 01       	movw	r24, r2
    5808:	b5 01       	movw	r22, r10
    580a:	48 8d       	ldd	r20, Y+24	; 0x18
    580c:	59 8d       	ldd	r21, Y+25	; 0x19
    580e:	26 2d       	mov	r18, r6
    5810:	0e 94 94 13 	call	0x2728	; 0x2728 <v_line>
            v_line(x0-(i-1),y0+fmin(y00,y)+1,abs(y00-y),s,c);
    5814:	ee 80       	ldd	r14, Y+6	; 0x06
    5816:	ff 80       	ldd	r15, Y+7	; 0x07
    5818:	08 94       	sec
    581a:	e1 1c       	adc	r14, r1
    581c:	f1 1c       	adc	r15, r1
    581e:	c7 01       	movw	r24, r14
    5820:	68 89       	ldd	r22, Y+16	; 0x10
    5822:	79 89       	ldd	r23, Y+17	; 0x11
    5824:	48 8d       	ldd	r20, Y+24	; 0x18
    5826:	59 8d       	ldd	r21, Y+25	; 0x19
    5828:	26 2d       	mov	r18, r6
    582a:	0e 94 94 13 	call	0x2728	; 0x2728 <v_line>
            v_line(x0-(i-1),y0-fmax(y00,y),abs(y00-y),s,c);
    582e:	c7 01       	movw	r24, r14
    5830:	b5 01       	movw	r22, r10
    5832:	48 8d       	ldd	r20, Y+24	; 0x18
    5834:	59 8d       	ldd	r21, Y+25	; 0x19
    5836:	26 2d       	mov	r18, r6
    5838:	0e 94 94 13 	call	0x2728	; 0x2728 <v_line>
void circle(unsigned int x0,unsigned int y0,
            unsigned int r,byte s,byte c)
{
    byte i,y,y00;
    y00 = r;            //Point (0,r) is the 1st point
    for(i=0; i<r; i++)
    583c:	99 81       	ldd	r25, Y+1	; 0x01
    583e:	9f 5f       	subi	r25, 0xFF	; 255
    5840:	99 83       	std	Y+1, r25	; 0x01
    5842:	a5 2c       	mov	r10, r5
    5844:	a9 81       	ldd	r26, Y+1	; 0x01
    5846:	8a 2e       	mov	r8, r26
    5848:	99 24       	eor	r9, r9
    584a:	ee 85       	ldd	r30, Y+14	; 0x0e
    584c:	ff 85       	ldd	r31, Y+15	; 0x0f
    584e:	8e 16       	cp	r8, r30
    5850:	9f 06       	cpc	r9, r31
    5852:	08 f4       	brcc	.+2      	; 0x5856 <circle+0x1fa>
    5854:	37 cf       	rjmp	.-402    	; 0x56c4 <circle+0x68>
            v_line(x0-(i-1),y0+fmin(y00,y)+1,abs(y00-y),s,c);
            v_line(x0-(i-1),y0-fmax(y00,y),abs(y00-y),s,c);
        }
        y00 = y;   
    }
    v_line(x0+(i-1) ,y0,y ,s,c);
    5856:	2a 85       	ldd	r18, Y+10	; 0x0a
    5858:	3b 85       	ldd	r19, Y+11	; 0x0b
    585a:	21 50       	subi	r18, 0x01	; 1
    585c:	30 40       	sbci	r19, 0x00	; 0
    585e:	3b 87       	std	Y+11, r19	; 0x0b
    5860:	2a 87       	std	Y+10, r18	; 0x0a
    5862:	79 01       	movw	r14, r18
    5864:	e8 0c       	add	r14, r8
    5866:	f9 1c       	adc	r15, r9
    5868:	c7 01       	movw	r24, r14
    586a:	6c 85       	ldd	r22, Y+12	; 0x0c
    586c:	7d 85       	ldd	r23, Y+13	; 0x0d
    586e:	45 2d       	mov	r20, r5
    5870:	50 e0       	ldi	r21, 0x00	; 0
    5872:	26 2d       	mov	r18, r6
    5874:	04 2d       	mov	r16, r4
    5876:	0e 94 94 13 	call	0x2728	; 0x2728 <v_line>
    v_line(x0+(i-1) ,y0-y ,y,s,c);
    587a:	cc 84       	ldd	r12, Y+12	; 0x0c
    587c:	dd 84       	ldd	r13, Y+13	; 0x0d
    587e:	c5 18       	sub	r12, r5
    5880:	d1 08       	sbc	r13, r1
    5882:	c7 01       	movw	r24, r14
    5884:	b6 01       	movw	r22, r12
    5886:	45 2d       	mov	r20, r5
    5888:	50 e0       	ldi	r21, 0x00	; 0
    588a:	26 2d       	mov	r18, r6
    588c:	0e 94 94 13 	call	0x2728	; 0x2728 <v_line>
    v_line(x0-(i-1) ,y0,y ,s,c);
    5890:	ea 84       	ldd	r14, Y+10	; 0x0a
    5892:	fb 84       	ldd	r15, Y+11	; 0x0b
    5894:	82 e0       	ldi	r24, 0x02	; 2
    5896:	90 e0       	ldi	r25, 0x00	; 0
    5898:	e8 0e       	add	r14, r24
    589a:	f9 1e       	adc	r15, r25
    589c:	e8 18       	sub	r14, r8
    589e:	f9 08       	sbc	r15, r9
    58a0:	c7 01       	movw	r24, r14
    58a2:	6c 85       	ldd	r22, Y+12	; 0x0c
    58a4:	7d 85       	ldd	r23, Y+13	; 0x0d
    58a6:	45 2d       	mov	r20, r5
    58a8:	50 e0       	ldi	r21, 0x00	; 0
    58aa:	26 2d       	mov	r18, r6
    58ac:	0e 94 94 13 	call	0x2728	; 0x2728 <v_line>
    v_line(x0-(i-1) ,y0-y ,y,s,c);    
    58b0:	c7 01       	movw	r24, r14
    58b2:	b6 01       	movw	r22, r12
    58b4:	45 2d       	mov	r20, r5
    58b6:	50 e0       	ldi	r21, 0x00	; 0
    58b8:	26 2d       	mov	r18, r6
    58ba:	0e 94 94 13 	call	0x2728	; 0x2728 <v_line>
}
    58be:	69 96       	adiw	r28, 0x19	; 25
    58c0:	0f b6       	in	r0, 0x3f	; 63
    58c2:	f8 94       	cli
    58c4:	de bf       	out	0x3e, r29	; 62
    58c6:	0f be       	out	0x3f, r0	; 63
    58c8:	cd bf       	out	0x3d, r28	; 61
    58ca:	cf 91       	pop	r28
    58cc:	df 91       	pop	r29
    58ce:	1f 91       	pop	r17
    58d0:	0f 91       	pop	r16
    58d2:	ff 90       	pop	r15
    58d4:	ef 90       	pop	r14
    58d6:	df 90       	pop	r13
    58d8:	cf 90       	pop	r12
    58da:	bf 90       	pop	r11
    58dc:	af 90       	pop	r10
    58de:	9f 90       	pop	r9
    58e0:	8f 90       	pop	r8
    58e2:	6f 90       	pop	r6
    58e4:	5f 90       	pop	r5
    58e6:	4f 90       	pop	r4
    58e8:	3f 90       	pop	r3
    58ea:	2f 90       	pop	r2
    58ec:	08 95       	ret

000058ee <__vector_13>:
SIGNAL(UART0_RECEIVE_INTERRUPT)
/*************************************************************************
Function: UART Receive Complete interrupt
Purpose:  called when the UART has received a character
**************************************************************************/
{
    58ee:	1f 92       	push	r1
    58f0:	0f 92       	push	r0
    58f2:	0f b6       	in	r0, 0x3f	; 63
    58f4:	0f 92       	push	r0
    58f6:	11 24       	eor	r1, r1
    58f8:	2f 93       	push	r18
    58fa:	8f 93       	push	r24
    58fc:	9f 93       	push	r25
    58fe:	ef 93       	push	r30
    5900:	ff 93       	push	r31
    unsigned char usr;
    unsigned char lastRxError;
 
 
    /* read UART status register and UART data register */ 
    usr  = UART0_STATUS;
    5902:	9b b1       	in	r25, 0x0b	; 11
    data = UART0_DATA;
    5904:	2c b1       	in	r18, 0x0c	; 12
#elif defined ( ATMEGA_UART )
    lastRxError = (usr & (_BV(FE)|_BV(DOR)) );
#endif
        
    /* calculate buffer index */ 
    tmphead = ( UART_RxHead + 1) & UART_RX_BUFFER_MASK;
    5906:	e0 91 b4 04 	lds	r30, 0x04B4
    590a:	ef 5f       	subi	r30, 0xFF	; 255
    590c:	ef 71       	andi	r30, 0x1F	; 31
    
    if ( tmphead == UART_RxTail ) {
    590e:	80 91 b5 04 	lds	r24, 0x04B5
    5912:	e8 17       	cp	r30, r24
    5914:	11 f4       	brne	.+4      	; 0x591a <__vector_13+0x2c>
    5916:	82 e0       	ldi	r24, 0x02	; 2
    5918:	08 c0       	rjmp	.+16     	; 0x592a <__vector_13+0x3c>
    
    /* */
#if defined( AT90_UART )
    lastRxError = (usr & (_BV(FE)|_BV(DOR)) );
#elif defined( ATMEGA_USART )
    lastRxError = (usr & (_BV(FE)|_BV(DOR)) );
    591a:	89 2f       	mov	r24, r25
    591c:	88 71       	andi	r24, 0x18	; 24
    if ( tmphead == UART_RxTail ) {
        /* error: receive buffer overflow */
        lastRxError = UART_BUFFER_OVERFLOW >> 8;
    }else{
        /* store new index */
        UART_RxHead = tmphead;
    591e:	e0 93 b4 04 	sts	0x04B4, r30
        /* store received data in buffer */
        UART_RxBuf[tmphead] = data;
    5922:	f0 e0       	ldi	r31, 0x00	; 0
    5924:	ee 56       	subi	r30, 0x6E	; 110
    5926:	fb 4f       	sbci	r31, 0xFB	; 251
    5928:	20 83       	st	Z, r18
    }
    UART_LastRxError = lastRxError;   
    592a:	80 93 b6 04 	sts	0x04B6, r24
}
    592e:	ff 91       	pop	r31
    5930:	ef 91       	pop	r30
    5932:	9f 91       	pop	r25
    5934:	8f 91       	pop	r24
    5936:	2f 91       	pop	r18
    5938:	0f 90       	pop	r0
    593a:	0f be       	out	0x3f, r0	; 63
    593c:	0f 90       	pop	r0
    593e:	1f 90       	pop	r1
    5940:	18 95       	reti

00005942 <__vector_14>:
SIGNAL(UART0_TRANSMIT_INTERRUPT)
/*************************************************************************
Function: UART Data Register Empty interrupt
Purpose:  called when the UART is ready to transmit the next byte
**************************************************************************/
{
    5942:	1f 92       	push	r1
    5944:	0f 92       	push	r0
    5946:	0f b6       	in	r0, 0x3f	; 63
    5948:	0f 92       	push	r0
    594a:	11 24       	eor	r1, r1
    594c:	8f 93       	push	r24
    594e:	9f 93       	push	r25
    5950:	ef 93       	push	r30
    5952:	ff 93       	push	r31
    unsigned char tmptail;

    
    if ( UART_TxHead != UART_TxTail) {
    5954:	90 91 b2 04 	lds	r25, 0x04B2
    5958:	80 91 b3 04 	lds	r24, 0x04B3
    595c:	98 17       	cp	r25, r24
    595e:	61 f0       	breq	.+24     	; 0x5978 <__vector_14+0x36>
        /* calculate and store new buffer index */
        tmptail = (UART_TxTail + 1) & UART_TX_BUFFER_MASK;
    5960:	e0 91 b3 04 	lds	r30, 0x04B3
    5964:	ef 5f       	subi	r30, 0xFF	; 255
    5966:	ef 71       	andi	r30, 0x1F	; 31
        UART_TxTail = tmptail;
    5968:	e0 93 b3 04 	sts	0x04B3, r30
        /* get one byte from buffer and write it to UART */
        UART0_DATA = UART_TxBuf[tmptail];  /* start transmission */
    596c:	f0 e0       	ldi	r31, 0x00	; 0
    596e:	ee 58       	subi	r30, 0x8E	; 142
    5970:	fb 4f       	sbci	r31, 0xFB	; 251
    5972:	80 81       	ld	r24, Z
    5974:	8c b9       	out	0x0c, r24	; 12
    5976:	01 c0       	rjmp	.+2      	; 0x597a <__vector_14+0x38>
    }else{
        /* tx buffer empty, disable UDRE interrupt */
        UART0_CONTROL &= ~_BV(UART0_UDRIE);
    5978:	55 98       	cbi	0x0a, 5	; 10
    }
}
    597a:	ff 91       	pop	r31
    597c:	ef 91       	pop	r30
    597e:	9f 91       	pop	r25
    5980:	8f 91       	pop	r24
    5982:	0f 90       	pop	r0
    5984:	0f be       	out	0x3f, r0	; 63
    5986:	0f 90       	pop	r0
    5988:	1f 90       	pop	r1
    598a:	18 95       	reti

0000598c <uart_init>:
Purpose:  initialize UART and set baudrate
Input:    baudrate using macro UART_BAUD_SELECT()
Returns:  none
**************************************************************************/
void uart_init(unsigned int baudrate)
{
    598c:	9c 01       	movw	r18, r24
    UART_TxHead = 0;
    598e:	10 92 b2 04 	sts	0x04B2, r1
    UART_TxTail = 0;
    5992:	10 92 b3 04 	sts	0x04B3, r1
    UART_RxHead = 0;
    5996:	10 92 b4 04 	sts	0x04B4, r1
    UART_RxTail = 0;
    599a:	10 92 b5 04 	sts	0x04B5, r1
    /* enable UART receiver and transmmitter and receive complete interrupt */
    UART0_CONTROL = _BV(RXCIE)|_BV(RXEN)|_BV(TXEN);

#elif defined (ATMEGA_USART)
    /* Set baud rate */
    if ( baudrate & 0x8000 )
    599e:	97 ff       	sbrs	r25, 7
    59a0:	03 c0       	rjmp	.+6      	; 0x59a8 <uart_init+0x1c>
    {
    	 UART0_STATUS = (1<<U2X);  //Enable 2x speed 
    59a2:	82 e0       	ldi	r24, 0x02	; 2
    59a4:	8b b9       	out	0x0b, r24	; 11
    	 baudrate &= ~0x8000;
    59a6:	3f 77       	andi	r19, 0x7F	; 127
    }
    UBRRH = (unsigned char)(baudrate>>8);
    59a8:	30 bd       	out	0x20, r19	; 32
    UBRRL = (unsigned char) baudrate;
    59aa:	29 b9       	out	0x09, r18	; 9
   
    /* Enable USART receiver and transmitter and receive complete interrupt */
    UART0_CONTROL = _BV(RXCIE)|(1<<RXEN)|(1<<TXEN);
    59ac:	88 e9       	ldi	r24, 0x98	; 152
    59ae:	8a b9       	out	0x0a, r24	; 10
    
    /* Set frame format: asynchronous, 8data, no parity, 1stop bit */
    #ifdef URSEL
    UCSRC = (1<<URSEL)|(3<<UCSZ0);
    59b0:	86 e8       	ldi	r24, 0x86	; 134
    59b2:	80 bd       	out	0x20, r24	; 32
    /* Enable UART receiver and transmitter and receive complete interrupt */
    UART0_CONTROL = _BV(RXCIE)|(1<<RXEN)|(1<<TXEN);

#endif

}/* uart_init */
    59b4:	08 95       	ret

000059b6 <uart_getc>:
{    
    unsigned char tmptail;
    unsigned char data;


    if ( UART_RxHead == UART_RxTail ) {
    59b6:	90 91 b4 04 	lds	r25, 0x04B4
    59ba:	80 91 b5 04 	lds	r24, 0x04B5
    59be:	98 17       	cp	r25, r24
    59c0:	19 f4       	brne	.+6      	; 0x59c8 <uart_getc+0x12>
    59c2:	20 e0       	ldi	r18, 0x00	; 0
    59c4:	31 e0       	ldi	r19, 0x01	; 1
    59c6:	0c c0       	rjmp	.+24     	; 0x59e0 <uart_getc+0x2a>
        return UART_NO_DATA;   /* no data available */
    }
    
    /* calculate /store buffer index */
    tmptail = (UART_RxTail + 1) & UART_RX_BUFFER_MASK;
    59c8:	e0 91 b5 04 	lds	r30, 0x04B5
    59cc:	ef 5f       	subi	r30, 0xFF	; 255
    59ce:	ef 71       	andi	r30, 0x1F	; 31
    UART_RxTail = tmptail; 
    59d0:	e0 93 b5 04 	sts	0x04B5, r30
    
    /* get data from receive buffer */
    data = UART_RxBuf[tmptail];
    59d4:	f0 e0       	ldi	r31, 0x00	; 0
    59d6:	ee 56       	subi	r30, 0x6E	; 110
    59d8:	fb 4f       	sbci	r31, 0xFB	; 251
    59da:	80 81       	ld	r24, Z
    
    //return (UART_LastRxError << 8) + data;
      return (data);
    59dc:	28 2f       	mov	r18, r24
    59de:	30 e0       	ldi	r19, 0x00	; 0
}/* uart_getc */
    59e0:	c9 01       	movw	r24, r18
    59e2:	08 95       	ret

000059e4 <uart_putc>:
Purpose:  write byte to ringbuffer for transmitting via UART
Input:    byte to be transmitted
Returns:  none          
**************************************************************************/
void uart_putc(unsigned char data)
{
    59e4:	28 2f       	mov	r18, r24
    unsigned char tmphead;

    
    tmphead  = (UART_TxHead + 1) & UART_TX_BUFFER_MASK;
    59e6:	90 91 b2 04 	lds	r25, 0x04B2
    59ea:	9f 5f       	subi	r25, 0xFF	; 255
    59ec:	9f 71       	andi	r25, 0x1F	; 31
    
    while ( tmphead == UART_TxTail ){
    59ee:	80 91 b3 04 	lds	r24, 0x04B3
    59f2:	98 17       	cp	r25, r24
    59f4:	e1 f3       	breq	.-8      	; 0x59ee <uart_putc+0xa>
        ;/* wait for free space in buffer */
    }
    
    UART_TxBuf[tmphead] = data;
    59f6:	e9 2f       	mov	r30, r25
    59f8:	f0 e0       	ldi	r31, 0x00	; 0
    59fa:	ee 58       	subi	r30, 0x8E	; 142
    59fc:	fb 4f       	sbci	r31, 0xFB	; 251
    59fe:	20 83       	st	Z, r18
    UART_TxHead = tmphead;
    5a00:	90 93 b2 04 	sts	0x04B2, r25

    /* enable UDRE interrupt */
    UART0_CONTROL    |= _BV(UART0_UDRIE);
    5a04:	55 9a       	sbi	0x0a, 5	; 10

}/* uart_putc */
    5a06:	08 95       	ret

00005a08 <uart_puts>:
Purpose:  transmit string to UART
Input:    string to be transmitted
Returns:  none          
**************************************************************************/
void uart_puts(const char *s )
{
    5a08:	dc 01       	movw	r26, r24
    5a0a:	11 c0       	rjmp	.+34     	; 0x5a2e <uart_puts+0x26>
void uart_putc(unsigned char data)
{
    unsigned char tmphead;

    
    tmphead  = (UART_TxHead + 1) & UART_TX_BUFFER_MASK;
    5a0c:	90 91 b2 04 	lds	r25, 0x04B2
    5a10:	9f 5f       	subi	r25, 0xFF	; 255
    5a12:	9f 71       	andi	r25, 0x1F	; 31
    
    while ( tmphead == UART_TxTail ){
    5a14:	80 91 b3 04 	lds	r24, 0x04B3
    5a18:	98 17       	cp	r25, r24
    5a1a:	e1 f3       	breq	.-8      	; 0x5a14 <uart_puts+0xc>
Returns:  none          
**************************************************************************/
void uart_puts(const char *s )
{
    while (*s) 
      uart_putc(*s++);
    5a1c:	11 96       	adiw	r26, 0x01	; 1
    
    while ( tmphead == UART_TxTail ){
        ;/* wait for free space in buffer */
    }
    
    UART_TxBuf[tmphead] = data;
    5a1e:	e9 2f       	mov	r30, r25
    5a20:	f0 e0       	ldi	r31, 0x00	; 0
    5a22:	ee 58       	subi	r30, 0x8E	; 142
    5a24:	fb 4f       	sbci	r31, 0xFB	; 251
    5a26:	20 83       	st	Z, r18
    UART_TxHead = tmphead;
    5a28:	90 93 b2 04 	sts	0x04B2, r25

    /* enable UDRE interrupt */
    UART0_CONTROL    |= _BV(UART0_UDRIE);
    5a2c:	55 9a       	sbi	0x0a, 5	; 10
Input:    string to be transmitted
Returns:  none          
**************************************************************************/
void uart_puts(const char *s )
{
    while (*s) 
    5a2e:	2c 91       	ld	r18, X
    5a30:	22 23       	and	r18, r18
    5a32:	61 f7       	brne	.-40     	; 0x5a0c <uart_puts+0x4>
      uart_putc(*s++);

}/* uart_puts */
    5a34:	08 95       	ret

00005a36 <uart_puts_p>:
Purpose:  transmit string from program memory to UART
Input:    program memory string to be transmitted
Returns:  none
**************************************************************************/
void uart_puts_p(const char *progmem_s )
{
    5a36:	ac 01       	movw	r20, r24
    5a38:	10 c0       	rjmp	.+32     	; 0x5a5a <uart_puts_p+0x24>
void uart_putc(unsigned char data)
{
    unsigned char tmphead;

    
    tmphead  = (UART_TxHead + 1) & UART_TX_BUFFER_MASK;
    5a3a:	20 91 b2 04 	lds	r18, 0x04B2
    5a3e:	2f 5f       	subi	r18, 0xFF	; 255
    5a40:	2f 71       	andi	r18, 0x1F	; 31
    
    while ( tmphead == UART_TxTail ){
    5a42:	80 91 b3 04 	lds	r24, 0x04B3
    5a46:	28 17       	cp	r18, r24
    5a48:	e1 f3       	breq	.-8      	; 0x5a42 <uart_puts_p+0xc>
        ;/* wait for free space in buffer */
    }
    
    UART_TxBuf[tmphead] = data;
    5a4a:	e2 2f       	mov	r30, r18
    5a4c:	f0 e0       	ldi	r31, 0x00	; 0
    5a4e:	ee 58       	subi	r30, 0x8E	; 142
    5a50:	fb 4f       	sbci	r31, 0xFB	; 251
    5a52:	90 83       	st	Z, r25
    UART_TxHead = tmphead;
    5a54:	20 93 b2 04 	sts	0x04B2, r18

    /* enable UDRE interrupt */
    UART0_CONTROL    |= _BV(UART0_UDRIE);
    5a58:	55 9a       	sbi	0x0a, 5	; 10
    5a5a:	fa 01       	movw	r30, r20
**************************************************************************/
void uart_puts_p(const char *progmem_s )
{
    register char c;
    
    while ( (c = pgm_read_byte(progmem_s++)) ) 
    5a5c:	4f 5f       	subi	r20, 0xFF	; 255
    5a5e:	5f 4f       	sbci	r21, 0xFF	; 255
    5a60:	94 91       	lpm	r25, Z+
    5a62:	99 23       	and	r25, r25
    5a64:	51 f7       	brne	.-44     	; 0x5a3a <uart_puts_p+0x4>
      uart_putc(c);

}/* uart_puts_p */
    5a66:	08 95       	ret

00005a68 <__fixunssfsi>:
    5a68:	ef 92       	push	r14
    5a6a:	ff 92       	push	r15
    5a6c:	0f 93       	push	r16
    5a6e:	1f 93       	push	r17
    5a70:	7b 01       	movw	r14, r22
    5a72:	8c 01       	movw	r16, r24
    5a74:	20 e0       	ldi	r18, 0x00	; 0
    5a76:	30 e0       	ldi	r19, 0x00	; 0
    5a78:	40 e0       	ldi	r20, 0x00	; 0
    5a7a:	5f e4       	ldi	r21, 0x4F	; 79
    5a7c:	0e 94 e0 30 	call	0x61c0	; 0x61c0 <__gesf2>
    5a80:	88 23       	and	r24, r24
    5a82:	8c f0       	brlt	.+34     	; 0x5aa6 <__fixunssfsi+0x3e>
    5a84:	c8 01       	movw	r24, r16
    5a86:	b7 01       	movw	r22, r14
    5a88:	20 e0       	ldi	r18, 0x00	; 0
    5a8a:	30 e0       	ldi	r19, 0x00	; 0
    5a8c:	40 e0       	ldi	r20, 0x00	; 0
    5a8e:	5f e4       	ldi	r21, 0x4F	; 79
    5a90:	0e 94 ac 2e 	call	0x5d58	; 0x5d58 <__subsf3>
    5a94:	0e 94 9e 31 	call	0x633c	; 0x633c <__fixsfsi>
    5a98:	9b 01       	movw	r18, r22
    5a9a:	ac 01       	movw	r20, r24
    5a9c:	20 50       	subi	r18, 0x00	; 0
    5a9e:	30 40       	sbci	r19, 0x00	; 0
    5aa0:	40 40       	sbci	r20, 0x00	; 0
    5aa2:	50 48       	sbci	r21, 0x80	; 128
    5aa4:	06 c0       	rjmp	.+12     	; 0x5ab2 <__fixunssfsi+0x4a>
    5aa6:	c8 01       	movw	r24, r16
    5aa8:	b7 01       	movw	r22, r14
    5aaa:	0e 94 9e 31 	call	0x633c	; 0x633c <__fixsfsi>
    5aae:	9b 01       	movw	r18, r22
    5ab0:	ac 01       	movw	r20, r24
    5ab2:	b9 01       	movw	r22, r18
    5ab4:	ca 01       	movw	r24, r20
    5ab6:	1f 91       	pop	r17
    5ab8:	0f 91       	pop	r16
    5aba:	ff 90       	pop	r15
    5abc:	ef 90       	pop	r14
    5abe:	08 95       	ret

00005ac0 <_fpadd_parts>:
    5ac0:	a0 e0       	ldi	r26, 0x00	; 0
    5ac2:	b0 e0       	ldi	r27, 0x00	; 0
    5ac4:	e6 e6       	ldi	r30, 0x66	; 102
    5ac6:	fd e2       	ldi	r31, 0x2D	; 45
    5ac8:	0c 94 60 34 	jmp	0x68c0	; 0x68c0 <__prologue_saves__>
    5acc:	dc 01       	movw	r26, r24
    5ace:	2b 01       	movw	r4, r22
    5ad0:	fa 01       	movw	r30, r20
    5ad2:	9c 91       	ld	r25, X
    5ad4:	92 30       	cpi	r25, 0x02	; 2
    5ad6:	08 f4       	brcc	.+2      	; 0x5ada <_fpadd_parts+0x1a>
    5ad8:	39 c1       	rjmp	.+626    	; 0x5d4c <_fpadd_parts+0x28c>
    5ada:	eb 01       	movw	r28, r22
    5adc:	88 81       	ld	r24, Y
    5ade:	82 30       	cpi	r24, 0x02	; 2
    5ae0:	08 f4       	brcc	.+2      	; 0x5ae4 <_fpadd_parts+0x24>
    5ae2:	33 c1       	rjmp	.+614    	; 0x5d4a <_fpadd_parts+0x28a>
    5ae4:	94 30       	cpi	r25, 0x04	; 4
    5ae6:	69 f4       	brne	.+26     	; 0x5b02 <_fpadd_parts+0x42>
    5ae8:	84 30       	cpi	r24, 0x04	; 4
    5aea:	09 f0       	breq	.+2      	; 0x5aee <_fpadd_parts+0x2e>
    5aec:	2f c1       	rjmp	.+606    	; 0x5d4c <_fpadd_parts+0x28c>
    5aee:	11 96       	adiw	r26, 0x01	; 1
    5af0:	9c 91       	ld	r25, X
    5af2:	11 97       	sbiw	r26, 0x01	; 1
    5af4:	89 81       	ldd	r24, Y+1	; 0x01
    5af6:	98 17       	cp	r25, r24
    5af8:	09 f4       	brne	.+2      	; 0x5afc <_fpadd_parts+0x3c>
    5afa:	28 c1       	rjmp	.+592    	; 0x5d4c <_fpadd_parts+0x28c>
    5afc:	af e5       	ldi	r26, 0x5F	; 95
    5afe:	b3 e0       	ldi	r27, 0x03	; 3
    5b00:	25 c1       	rjmp	.+586    	; 0x5d4c <_fpadd_parts+0x28c>
    5b02:	84 30       	cpi	r24, 0x04	; 4
    5b04:	09 f4       	brne	.+2      	; 0x5b08 <_fpadd_parts+0x48>
    5b06:	21 c1       	rjmp	.+578    	; 0x5d4a <_fpadd_parts+0x28a>
    5b08:	82 30       	cpi	r24, 0x02	; 2
    5b0a:	a9 f4       	brne	.+42     	; 0x5b36 <_fpadd_parts+0x76>
    5b0c:	92 30       	cpi	r25, 0x02	; 2
    5b0e:	09 f0       	breq	.+2      	; 0x5b12 <_fpadd_parts+0x52>
    5b10:	1d c1       	rjmp	.+570    	; 0x5d4c <_fpadd_parts+0x28c>
    5b12:	9a 01       	movw	r18, r20
    5b14:	ad 01       	movw	r20, r26
    5b16:	88 e0       	ldi	r24, 0x08	; 8
    5b18:	ea 01       	movw	r28, r20
    5b1a:	09 90       	ld	r0, Y+
    5b1c:	ae 01       	movw	r20, r28
    5b1e:	e9 01       	movw	r28, r18
    5b20:	09 92       	st	Y+, r0
    5b22:	9e 01       	movw	r18, r28
    5b24:	81 50       	subi	r24, 0x01	; 1
    5b26:	c1 f7       	brne	.-16     	; 0x5b18 <_fpadd_parts+0x58>
    5b28:	e2 01       	movw	r28, r4
    5b2a:	89 81       	ldd	r24, Y+1	; 0x01
    5b2c:	11 96       	adiw	r26, 0x01	; 1
    5b2e:	9c 91       	ld	r25, X
    5b30:	89 23       	and	r24, r25
    5b32:	81 83       	std	Z+1, r24	; 0x01
    5b34:	08 c1       	rjmp	.+528    	; 0x5d46 <_fpadd_parts+0x286>
    5b36:	92 30       	cpi	r25, 0x02	; 2
    5b38:	09 f4       	brne	.+2      	; 0x5b3c <_fpadd_parts+0x7c>
    5b3a:	07 c1       	rjmp	.+526    	; 0x5d4a <_fpadd_parts+0x28a>
    5b3c:	12 96       	adiw	r26, 0x02	; 2
    5b3e:	2d 90       	ld	r2, X+
    5b40:	3c 90       	ld	r3, X
    5b42:	13 97       	sbiw	r26, 0x03	; 3
    5b44:	eb 01       	movw	r28, r22
    5b46:	8a 81       	ldd	r24, Y+2	; 0x02
    5b48:	9b 81       	ldd	r25, Y+3	; 0x03
    5b4a:	14 96       	adiw	r26, 0x04	; 4
    5b4c:	ad 90       	ld	r10, X+
    5b4e:	bd 90       	ld	r11, X+
    5b50:	cd 90       	ld	r12, X+
    5b52:	dc 90       	ld	r13, X
    5b54:	17 97       	sbiw	r26, 0x07	; 7
    5b56:	ec 80       	ldd	r14, Y+4	; 0x04
    5b58:	fd 80       	ldd	r15, Y+5	; 0x05
    5b5a:	0e 81       	ldd	r16, Y+6	; 0x06
    5b5c:	1f 81       	ldd	r17, Y+7	; 0x07
    5b5e:	91 01       	movw	r18, r2
    5b60:	28 1b       	sub	r18, r24
    5b62:	39 0b       	sbc	r19, r25
    5b64:	b9 01       	movw	r22, r18
    5b66:	37 ff       	sbrs	r19, 7
    5b68:	04 c0       	rjmp	.+8      	; 0x5b72 <_fpadd_parts+0xb2>
    5b6a:	66 27       	eor	r22, r22
    5b6c:	77 27       	eor	r23, r23
    5b6e:	62 1b       	sub	r22, r18
    5b70:	73 0b       	sbc	r23, r19
    5b72:	60 32       	cpi	r22, 0x20	; 32
    5b74:	71 05       	cpc	r23, r1
    5b76:	0c f0       	brlt	.+2      	; 0x5b7a <_fpadd_parts+0xba>
    5b78:	61 c0       	rjmp	.+194    	; 0x5c3c <_fpadd_parts+0x17c>
    5b7a:	12 16       	cp	r1, r18
    5b7c:	13 06       	cpc	r1, r19
    5b7e:	6c f5       	brge	.+90     	; 0x5bda <_fpadd_parts+0x11a>
    5b80:	37 01       	movw	r6, r14
    5b82:	48 01       	movw	r8, r16
    5b84:	06 2e       	mov	r0, r22
    5b86:	04 c0       	rjmp	.+8      	; 0x5b90 <_fpadd_parts+0xd0>
    5b88:	96 94       	lsr	r9
    5b8a:	87 94       	ror	r8
    5b8c:	77 94       	ror	r7
    5b8e:	67 94       	ror	r6
    5b90:	0a 94       	dec	r0
    5b92:	d2 f7       	brpl	.-12     	; 0x5b88 <_fpadd_parts+0xc8>
    5b94:	21 e0       	ldi	r18, 0x01	; 1
    5b96:	30 e0       	ldi	r19, 0x00	; 0
    5b98:	40 e0       	ldi	r20, 0x00	; 0
    5b9a:	50 e0       	ldi	r21, 0x00	; 0
    5b9c:	04 c0       	rjmp	.+8      	; 0x5ba6 <_fpadd_parts+0xe6>
    5b9e:	22 0f       	add	r18, r18
    5ba0:	33 1f       	adc	r19, r19
    5ba2:	44 1f       	adc	r20, r20
    5ba4:	55 1f       	adc	r21, r21
    5ba6:	6a 95       	dec	r22
    5ba8:	d2 f7       	brpl	.-12     	; 0x5b9e <_fpadd_parts+0xde>
    5baa:	21 50       	subi	r18, 0x01	; 1
    5bac:	30 40       	sbci	r19, 0x00	; 0
    5bae:	40 40       	sbci	r20, 0x00	; 0
    5bb0:	50 40       	sbci	r21, 0x00	; 0
    5bb2:	2e 21       	and	r18, r14
    5bb4:	3f 21       	and	r19, r15
    5bb6:	40 23       	and	r20, r16
    5bb8:	51 23       	and	r21, r17
    5bba:	21 15       	cp	r18, r1
    5bbc:	31 05       	cpc	r19, r1
    5bbe:	41 05       	cpc	r20, r1
    5bc0:	51 05       	cpc	r21, r1
    5bc2:	21 f0       	breq	.+8      	; 0x5bcc <_fpadd_parts+0x10c>
    5bc4:	21 e0       	ldi	r18, 0x01	; 1
    5bc6:	30 e0       	ldi	r19, 0x00	; 0
    5bc8:	40 e0       	ldi	r20, 0x00	; 0
    5bca:	50 e0       	ldi	r21, 0x00	; 0
    5bcc:	79 01       	movw	r14, r18
    5bce:	8a 01       	movw	r16, r20
    5bd0:	e6 28       	or	r14, r6
    5bd2:	f7 28       	or	r15, r7
    5bd4:	08 29       	or	r16, r8
    5bd6:	19 29       	or	r17, r9
    5bd8:	3c c0       	rjmp	.+120    	; 0x5c52 <_fpadd_parts+0x192>
    5bda:	23 2b       	or	r18, r19
    5bdc:	d1 f1       	breq	.+116    	; 0x5c52 <_fpadd_parts+0x192>
    5bde:	26 0e       	add	r2, r22
    5be0:	37 1e       	adc	r3, r23
    5be2:	35 01       	movw	r6, r10
    5be4:	46 01       	movw	r8, r12
    5be6:	06 2e       	mov	r0, r22
    5be8:	04 c0       	rjmp	.+8      	; 0x5bf2 <_fpadd_parts+0x132>
    5bea:	96 94       	lsr	r9
    5bec:	87 94       	ror	r8
    5bee:	77 94       	ror	r7
    5bf0:	67 94       	ror	r6
    5bf2:	0a 94       	dec	r0
    5bf4:	d2 f7       	brpl	.-12     	; 0x5bea <_fpadd_parts+0x12a>
    5bf6:	21 e0       	ldi	r18, 0x01	; 1
    5bf8:	30 e0       	ldi	r19, 0x00	; 0
    5bfa:	40 e0       	ldi	r20, 0x00	; 0
    5bfc:	50 e0       	ldi	r21, 0x00	; 0
    5bfe:	04 c0       	rjmp	.+8      	; 0x5c08 <_fpadd_parts+0x148>
    5c00:	22 0f       	add	r18, r18
    5c02:	33 1f       	adc	r19, r19
    5c04:	44 1f       	adc	r20, r20
    5c06:	55 1f       	adc	r21, r21
    5c08:	6a 95       	dec	r22
    5c0a:	d2 f7       	brpl	.-12     	; 0x5c00 <_fpadd_parts+0x140>
    5c0c:	21 50       	subi	r18, 0x01	; 1
    5c0e:	30 40       	sbci	r19, 0x00	; 0
    5c10:	40 40       	sbci	r20, 0x00	; 0
    5c12:	50 40       	sbci	r21, 0x00	; 0
    5c14:	2a 21       	and	r18, r10
    5c16:	3b 21       	and	r19, r11
    5c18:	4c 21       	and	r20, r12
    5c1a:	5d 21       	and	r21, r13
    5c1c:	21 15       	cp	r18, r1
    5c1e:	31 05       	cpc	r19, r1
    5c20:	41 05       	cpc	r20, r1
    5c22:	51 05       	cpc	r21, r1
    5c24:	21 f0       	breq	.+8      	; 0x5c2e <_fpadd_parts+0x16e>
    5c26:	21 e0       	ldi	r18, 0x01	; 1
    5c28:	30 e0       	ldi	r19, 0x00	; 0
    5c2a:	40 e0       	ldi	r20, 0x00	; 0
    5c2c:	50 e0       	ldi	r21, 0x00	; 0
    5c2e:	59 01       	movw	r10, r18
    5c30:	6a 01       	movw	r12, r20
    5c32:	a6 28       	or	r10, r6
    5c34:	b7 28       	or	r11, r7
    5c36:	c8 28       	or	r12, r8
    5c38:	d9 28       	or	r13, r9
    5c3a:	0b c0       	rjmp	.+22     	; 0x5c52 <_fpadd_parts+0x192>
    5c3c:	82 15       	cp	r24, r2
    5c3e:	93 05       	cpc	r25, r3
    5c40:	2c f0       	brlt	.+10     	; 0x5c4c <_fpadd_parts+0x18c>
    5c42:	1c 01       	movw	r2, r24
    5c44:	aa 24       	eor	r10, r10
    5c46:	bb 24       	eor	r11, r11
    5c48:	65 01       	movw	r12, r10
    5c4a:	03 c0       	rjmp	.+6      	; 0x5c52 <_fpadd_parts+0x192>
    5c4c:	ee 24       	eor	r14, r14
    5c4e:	ff 24       	eor	r15, r15
    5c50:	87 01       	movw	r16, r14
    5c52:	11 96       	adiw	r26, 0x01	; 1
    5c54:	9c 91       	ld	r25, X
    5c56:	d2 01       	movw	r26, r4
    5c58:	11 96       	adiw	r26, 0x01	; 1
    5c5a:	8c 91       	ld	r24, X
    5c5c:	98 17       	cp	r25, r24
    5c5e:	09 f4       	brne	.+2      	; 0x5c62 <_fpadd_parts+0x1a2>
    5c60:	45 c0       	rjmp	.+138    	; 0x5cec <_fpadd_parts+0x22c>
    5c62:	99 23       	and	r25, r25
    5c64:	39 f0       	breq	.+14     	; 0x5c74 <_fpadd_parts+0x1b4>
    5c66:	a8 01       	movw	r20, r16
    5c68:	97 01       	movw	r18, r14
    5c6a:	2a 19       	sub	r18, r10
    5c6c:	3b 09       	sbc	r19, r11
    5c6e:	4c 09       	sbc	r20, r12
    5c70:	5d 09       	sbc	r21, r13
    5c72:	06 c0       	rjmp	.+12     	; 0x5c80 <_fpadd_parts+0x1c0>
    5c74:	a6 01       	movw	r20, r12
    5c76:	95 01       	movw	r18, r10
    5c78:	2e 19       	sub	r18, r14
    5c7a:	3f 09       	sbc	r19, r15
    5c7c:	40 0b       	sbc	r20, r16
    5c7e:	51 0b       	sbc	r21, r17
    5c80:	57 fd       	sbrc	r21, 7
    5c82:	08 c0       	rjmp	.+16     	; 0x5c94 <_fpadd_parts+0x1d4>
    5c84:	11 82       	std	Z+1, r1	; 0x01
    5c86:	33 82       	std	Z+3, r3	; 0x03
    5c88:	22 82       	std	Z+2, r2	; 0x02
    5c8a:	24 83       	std	Z+4, r18	; 0x04
    5c8c:	35 83       	std	Z+5, r19	; 0x05
    5c8e:	46 83       	std	Z+6, r20	; 0x06
    5c90:	57 83       	std	Z+7, r21	; 0x07
    5c92:	1d c0       	rjmp	.+58     	; 0x5cce <_fpadd_parts+0x20e>
    5c94:	81 e0       	ldi	r24, 0x01	; 1
    5c96:	81 83       	std	Z+1, r24	; 0x01
    5c98:	33 82       	std	Z+3, r3	; 0x03
    5c9a:	22 82       	std	Z+2, r2	; 0x02
    5c9c:	88 27       	eor	r24, r24
    5c9e:	99 27       	eor	r25, r25
    5ca0:	dc 01       	movw	r26, r24
    5ca2:	82 1b       	sub	r24, r18
    5ca4:	93 0b       	sbc	r25, r19
    5ca6:	a4 0b       	sbc	r26, r20
    5ca8:	b5 0b       	sbc	r27, r21
    5caa:	84 83       	std	Z+4, r24	; 0x04
    5cac:	95 83       	std	Z+5, r25	; 0x05
    5cae:	a6 83       	std	Z+6, r26	; 0x06
    5cb0:	b7 83       	std	Z+7, r27	; 0x07
    5cb2:	0d c0       	rjmp	.+26     	; 0x5cce <_fpadd_parts+0x20e>
    5cb4:	22 0f       	add	r18, r18
    5cb6:	33 1f       	adc	r19, r19
    5cb8:	44 1f       	adc	r20, r20
    5cba:	55 1f       	adc	r21, r21
    5cbc:	24 83       	std	Z+4, r18	; 0x04
    5cbe:	35 83       	std	Z+5, r19	; 0x05
    5cc0:	46 83       	std	Z+6, r20	; 0x06
    5cc2:	57 83       	std	Z+7, r21	; 0x07
    5cc4:	82 81       	ldd	r24, Z+2	; 0x02
    5cc6:	93 81       	ldd	r25, Z+3	; 0x03
    5cc8:	01 97       	sbiw	r24, 0x01	; 1
    5cca:	93 83       	std	Z+3, r25	; 0x03
    5ccc:	82 83       	std	Z+2, r24	; 0x02
    5cce:	24 81       	ldd	r18, Z+4	; 0x04
    5cd0:	35 81       	ldd	r19, Z+5	; 0x05
    5cd2:	46 81       	ldd	r20, Z+6	; 0x06
    5cd4:	57 81       	ldd	r21, Z+7	; 0x07
    5cd6:	da 01       	movw	r26, r20
    5cd8:	c9 01       	movw	r24, r18
    5cda:	01 97       	sbiw	r24, 0x01	; 1
    5cdc:	a1 09       	sbc	r26, r1
    5cde:	b1 09       	sbc	r27, r1
    5ce0:	8f 5f       	subi	r24, 0xFF	; 255
    5ce2:	9f 4f       	sbci	r25, 0xFF	; 255
    5ce4:	af 4f       	sbci	r26, 0xFF	; 255
    5ce6:	bf 43       	sbci	r27, 0x3F	; 63
    5ce8:	28 f3       	brcs	.-54     	; 0x5cb4 <_fpadd_parts+0x1f4>
    5cea:	0b c0       	rjmp	.+22     	; 0x5d02 <_fpadd_parts+0x242>
    5cec:	91 83       	std	Z+1, r25	; 0x01
    5cee:	33 82       	std	Z+3, r3	; 0x03
    5cf0:	22 82       	std	Z+2, r2	; 0x02
    5cf2:	ea 0c       	add	r14, r10
    5cf4:	fb 1c       	adc	r15, r11
    5cf6:	0c 1d       	adc	r16, r12
    5cf8:	1d 1d       	adc	r17, r13
    5cfa:	e4 82       	std	Z+4, r14	; 0x04
    5cfc:	f5 82       	std	Z+5, r15	; 0x05
    5cfe:	06 83       	std	Z+6, r16	; 0x06
    5d00:	17 83       	std	Z+7, r17	; 0x07
    5d02:	83 e0       	ldi	r24, 0x03	; 3
    5d04:	80 83       	st	Z, r24
    5d06:	24 81       	ldd	r18, Z+4	; 0x04
    5d08:	35 81       	ldd	r19, Z+5	; 0x05
    5d0a:	46 81       	ldd	r20, Z+6	; 0x06
    5d0c:	57 81       	ldd	r21, Z+7	; 0x07
    5d0e:	57 ff       	sbrs	r21, 7
    5d10:	1a c0       	rjmp	.+52     	; 0x5d46 <_fpadd_parts+0x286>
    5d12:	c9 01       	movw	r24, r18
    5d14:	aa 27       	eor	r26, r26
    5d16:	97 fd       	sbrc	r25, 7
    5d18:	a0 95       	com	r26
    5d1a:	ba 2f       	mov	r27, r26
    5d1c:	81 70       	andi	r24, 0x01	; 1
    5d1e:	90 70       	andi	r25, 0x00	; 0
    5d20:	a0 70       	andi	r26, 0x00	; 0
    5d22:	b0 70       	andi	r27, 0x00	; 0
    5d24:	56 95       	lsr	r21
    5d26:	47 95       	ror	r20
    5d28:	37 95       	ror	r19
    5d2a:	27 95       	ror	r18
    5d2c:	82 2b       	or	r24, r18
    5d2e:	93 2b       	or	r25, r19
    5d30:	a4 2b       	or	r26, r20
    5d32:	b5 2b       	or	r27, r21
    5d34:	84 83       	std	Z+4, r24	; 0x04
    5d36:	95 83       	std	Z+5, r25	; 0x05
    5d38:	a6 83       	std	Z+6, r26	; 0x06
    5d3a:	b7 83       	std	Z+7, r27	; 0x07
    5d3c:	82 81       	ldd	r24, Z+2	; 0x02
    5d3e:	93 81       	ldd	r25, Z+3	; 0x03
    5d40:	01 96       	adiw	r24, 0x01	; 1
    5d42:	93 83       	std	Z+3, r25	; 0x03
    5d44:	82 83       	std	Z+2, r24	; 0x02
    5d46:	df 01       	movw	r26, r30
    5d48:	01 c0       	rjmp	.+2      	; 0x5d4c <_fpadd_parts+0x28c>
    5d4a:	d2 01       	movw	r26, r4
    5d4c:	cd 01       	movw	r24, r26
    5d4e:	cd b7       	in	r28, 0x3d	; 61
    5d50:	de b7       	in	r29, 0x3e	; 62
    5d52:	e2 e1       	ldi	r30, 0x12	; 18
    5d54:	0c 94 7c 34 	jmp	0x68f8	; 0x68f8 <__epilogue_restores__>

00005d58 <__subsf3>:
    5d58:	a0 e2       	ldi	r26, 0x20	; 32
    5d5a:	b0 e0       	ldi	r27, 0x00	; 0
    5d5c:	e2 eb       	ldi	r30, 0xB2	; 178
    5d5e:	fe e2       	ldi	r31, 0x2E	; 46
    5d60:	0c 94 6c 34 	jmp	0x68d8	; 0x68d8 <__prologue_saves__+0x18>
    5d64:	69 83       	std	Y+1, r22	; 0x01
    5d66:	7a 83       	std	Y+2, r23	; 0x02
    5d68:	8b 83       	std	Y+3, r24	; 0x03
    5d6a:	9c 83       	std	Y+4, r25	; 0x04
    5d6c:	2d 83       	std	Y+5, r18	; 0x05
    5d6e:	3e 83       	std	Y+6, r19	; 0x06
    5d70:	4f 83       	std	Y+7, r20	; 0x07
    5d72:	58 87       	std	Y+8, r21	; 0x08
    5d74:	e9 e0       	ldi	r30, 0x09	; 9
    5d76:	ee 2e       	mov	r14, r30
    5d78:	f1 2c       	mov	r15, r1
    5d7a:	ec 0e       	add	r14, r28
    5d7c:	fd 1e       	adc	r15, r29
    5d7e:	ce 01       	movw	r24, r28
    5d80:	01 96       	adiw	r24, 0x01	; 1
    5d82:	b7 01       	movw	r22, r14
    5d84:	0e 94 8f 33 	call	0x671e	; 0x671e <__unpack_f>
    5d88:	8e 01       	movw	r16, r28
    5d8a:	0f 5e       	subi	r16, 0xEF	; 239
    5d8c:	1f 4f       	sbci	r17, 0xFF	; 255
    5d8e:	ce 01       	movw	r24, r28
    5d90:	05 96       	adiw	r24, 0x05	; 5
    5d92:	b8 01       	movw	r22, r16
    5d94:	0e 94 8f 33 	call	0x671e	; 0x671e <__unpack_f>
    5d98:	8a 89       	ldd	r24, Y+18	; 0x12
    5d9a:	91 e0       	ldi	r25, 0x01	; 1
    5d9c:	89 27       	eor	r24, r25
    5d9e:	8a 8b       	std	Y+18, r24	; 0x12
    5da0:	c7 01       	movw	r24, r14
    5da2:	b8 01       	movw	r22, r16
    5da4:	ae 01       	movw	r20, r28
    5da6:	47 5e       	subi	r20, 0xE7	; 231
    5da8:	5f 4f       	sbci	r21, 0xFF	; 255
    5daa:	0e 94 60 2d 	call	0x5ac0	; 0x5ac0 <_fpadd_parts>
    5dae:	0e 94 ba 32 	call	0x6574	; 0x6574 <__pack_f>
    5db2:	a0 96       	adiw	r28, 0x20	; 32
    5db4:	e6 e0       	ldi	r30, 0x06	; 6
    5db6:	0c 94 88 34 	jmp	0x6910	; 0x6910 <__epilogue_restores__+0x18>

00005dba <__addsf3>:
    5dba:	a0 e2       	ldi	r26, 0x20	; 32
    5dbc:	b0 e0       	ldi	r27, 0x00	; 0
    5dbe:	e3 ee       	ldi	r30, 0xE3	; 227
    5dc0:	fe e2       	ldi	r31, 0x2E	; 46
    5dc2:	0c 94 6c 34 	jmp	0x68d8	; 0x68d8 <__prologue_saves__+0x18>
    5dc6:	69 83       	std	Y+1, r22	; 0x01
    5dc8:	7a 83       	std	Y+2, r23	; 0x02
    5dca:	8b 83       	std	Y+3, r24	; 0x03
    5dcc:	9c 83       	std	Y+4, r25	; 0x04
    5dce:	2d 83       	std	Y+5, r18	; 0x05
    5dd0:	3e 83       	std	Y+6, r19	; 0x06
    5dd2:	4f 83       	std	Y+7, r20	; 0x07
    5dd4:	58 87       	std	Y+8, r21	; 0x08
    5dd6:	f9 e0       	ldi	r31, 0x09	; 9
    5dd8:	ef 2e       	mov	r14, r31
    5dda:	f1 2c       	mov	r15, r1
    5ddc:	ec 0e       	add	r14, r28
    5dde:	fd 1e       	adc	r15, r29
    5de0:	ce 01       	movw	r24, r28
    5de2:	01 96       	adiw	r24, 0x01	; 1
    5de4:	b7 01       	movw	r22, r14
    5de6:	0e 94 8f 33 	call	0x671e	; 0x671e <__unpack_f>
    5dea:	8e 01       	movw	r16, r28
    5dec:	0f 5e       	subi	r16, 0xEF	; 239
    5dee:	1f 4f       	sbci	r17, 0xFF	; 255
    5df0:	ce 01       	movw	r24, r28
    5df2:	05 96       	adiw	r24, 0x05	; 5
    5df4:	b8 01       	movw	r22, r16
    5df6:	0e 94 8f 33 	call	0x671e	; 0x671e <__unpack_f>
    5dfa:	c7 01       	movw	r24, r14
    5dfc:	b8 01       	movw	r22, r16
    5dfe:	ae 01       	movw	r20, r28
    5e00:	47 5e       	subi	r20, 0xE7	; 231
    5e02:	5f 4f       	sbci	r21, 0xFF	; 255
    5e04:	0e 94 60 2d 	call	0x5ac0	; 0x5ac0 <_fpadd_parts>
    5e08:	0e 94 ba 32 	call	0x6574	; 0x6574 <__pack_f>
    5e0c:	a0 96       	adiw	r28, 0x20	; 32
    5e0e:	e6 e0       	ldi	r30, 0x06	; 6
    5e10:	0c 94 88 34 	jmp	0x6910	; 0x6910 <__epilogue_restores__+0x18>

00005e14 <__mulsf3>:
    5e14:	a0 e2       	ldi	r26, 0x20	; 32
    5e16:	b0 e0       	ldi	r27, 0x00	; 0
    5e18:	e0 e1       	ldi	r30, 0x10	; 16
    5e1a:	ff e2       	ldi	r31, 0x2F	; 47
    5e1c:	0c 94 60 34 	jmp	0x68c0	; 0x68c0 <__prologue_saves__>
    5e20:	69 83       	std	Y+1, r22	; 0x01
    5e22:	7a 83       	std	Y+2, r23	; 0x02
    5e24:	8b 83       	std	Y+3, r24	; 0x03
    5e26:	9c 83       	std	Y+4, r25	; 0x04
    5e28:	2d 83       	std	Y+5, r18	; 0x05
    5e2a:	3e 83       	std	Y+6, r19	; 0x06
    5e2c:	4f 83       	std	Y+7, r20	; 0x07
    5e2e:	58 87       	std	Y+8, r21	; 0x08
    5e30:	ce 01       	movw	r24, r28
    5e32:	01 96       	adiw	r24, 0x01	; 1
    5e34:	be 01       	movw	r22, r28
    5e36:	67 5f       	subi	r22, 0xF7	; 247
    5e38:	7f 4f       	sbci	r23, 0xFF	; 255
    5e3a:	0e 94 8f 33 	call	0x671e	; 0x671e <__unpack_f>
    5e3e:	ce 01       	movw	r24, r28
    5e40:	05 96       	adiw	r24, 0x05	; 5
    5e42:	be 01       	movw	r22, r28
    5e44:	6f 5e       	subi	r22, 0xEF	; 239
    5e46:	7f 4f       	sbci	r23, 0xFF	; 255
    5e48:	0e 94 8f 33 	call	0x671e	; 0x671e <__unpack_f>
    5e4c:	99 85       	ldd	r25, Y+9	; 0x09
    5e4e:	92 30       	cpi	r25, 0x02	; 2
    5e50:	88 f0       	brcs	.+34     	; 0x5e74 <__mulsf3+0x60>
    5e52:	89 89       	ldd	r24, Y+17	; 0x11
    5e54:	82 30       	cpi	r24, 0x02	; 2
    5e56:	c8 f0       	brcs	.+50     	; 0x5e8a <__mulsf3+0x76>
    5e58:	94 30       	cpi	r25, 0x04	; 4
    5e5a:	19 f4       	brne	.+6      	; 0x5e62 <__mulsf3+0x4e>
    5e5c:	82 30       	cpi	r24, 0x02	; 2
    5e5e:	51 f4       	brne	.+20     	; 0x5e74 <__mulsf3+0x60>
    5e60:	04 c0       	rjmp	.+8      	; 0x5e6a <__mulsf3+0x56>
    5e62:	84 30       	cpi	r24, 0x04	; 4
    5e64:	29 f4       	brne	.+10     	; 0x5e70 <__mulsf3+0x5c>
    5e66:	92 30       	cpi	r25, 0x02	; 2
    5e68:	81 f4       	brne	.+32     	; 0x5e8a <__mulsf3+0x76>
    5e6a:	8f e5       	ldi	r24, 0x5F	; 95
    5e6c:	93 e0       	ldi	r25, 0x03	; 3
    5e6e:	c6 c0       	rjmp	.+396    	; 0x5ffc <__mulsf3+0x1e8>
    5e70:	92 30       	cpi	r25, 0x02	; 2
    5e72:	49 f4       	brne	.+18     	; 0x5e86 <__mulsf3+0x72>
    5e74:	20 e0       	ldi	r18, 0x00	; 0
    5e76:	9a 85       	ldd	r25, Y+10	; 0x0a
    5e78:	8a 89       	ldd	r24, Y+18	; 0x12
    5e7a:	98 13       	cpse	r25, r24
    5e7c:	21 e0       	ldi	r18, 0x01	; 1
    5e7e:	2a 87       	std	Y+10, r18	; 0x0a
    5e80:	ce 01       	movw	r24, r28
    5e82:	09 96       	adiw	r24, 0x09	; 9
    5e84:	bb c0       	rjmp	.+374    	; 0x5ffc <__mulsf3+0x1e8>
    5e86:	82 30       	cpi	r24, 0x02	; 2
    5e88:	49 f4       	brne	.+18     	; 0x5e9c <__mulsf3+0x88>
    5e8a:	20 e0       	ldi	r18, 0x00	; 0
    5e8c:	9a 85       	ldd	r25, Y+10	; 0x0a
    5e8e:	8a 89       	ldd	r24, Y+18	; 0x12
    5e90:	98 13       	cpse	r25, r24
    5e92:	21 e0       	ldi	r18, 0x01	; 1
    5e94:	2a 8b       	std	Y+18, r18	; 0x12
    5e96:	ce 01       	movw	r24, r28
    5e98:	41 96       	adiw	r24, 0x11	; 17
    5e9a:	b0 c0       	rjmp	.+352    	; 0x5ffc <__mulsf3+0x1e8>
    5e9c:	2d 84       	ldd	r2, Y+13	; 0x0d
    5e9e:	3e 84       	ldd	r3, Y+14	; 0x0e
    5ea0:	4f 84       	ldd	r4, Y+15	; 0x0f
    5ea2:	58 88       	ldd	r5, Y+16	; 0x10
    5ea4:	6d 88       	ldd	r6, Y+21	; 0x15
    5ea6:	7e 88       	ldd	r7, Y+22	; 0x16
    5ea8:	8f 88       	ldd	r8, Y+23	; 0x17
    5eaa:	98 8c       	ldd	r9, Y+24	; 0x18
    5eac:	ee 24       	eor	r14, r14
    5eae:	ff 24       	eor	r15, r15
    5eb0:	87 01       	movw	r16, r14
    5eb2:	aa 24       	eor	r10, r10
    5eb4:	bb 24       	eor	r11, r11
    5eb6:	65 01       	movw	r12, r10
    5eb8:	40 e0       	ldi	r20, 0x00	; 0
    5eba:	50 e0       	ldi	r21, 0x00	; 0
    5ebc:	60 e0       	ldi	r22, 0x00	; 0
    5ebe:	70 e0       	ldi	r23, 0x00	; 0
    5ec0:	e0 e0       	ldi	r30, 0x00	; 0
    5ec2:	f0 e0       	ldi	r31, 0x00	; 0
    5ec4:	c1 01       	movw	r24, r2
    5ec6:	81 70       	andi	r24, 0x01	; 1
    5ec8:	90 70       	andi	r25, 0x00	; 0
    5eca:	89 2b       	or	r24, r25
    5ecc:	e9 f0       	breq	.+58     	; 0x5f08 <__mulsf3+0xf4>
    5ece:	e6 0c       	add	r14, r6
    5ed0:	f7 1c       	adc	r15, r7
    5ed2:	08 1d       	adc	r16, r8
    5ed4:	19 1d       	adc	r17, r9
    5ed6:	9a 01       	movw	r18, r20
    5ed8:	ab 01       	movw	r20, r22
    5eda:	2a 0d       	add	r18, r10
    5edc:	3b 1d       	adc	r19, r11
    5ede:	4c 1d       	adc	r20, r12
    5ee0:	5d 1d       	adc	r21, r13
    5ee2:	80 e0       	ldi	r24, 0x00	; 0
    5ee4:	90 e0       	ldi	r25, 0x00	; 0
    5ee6:	a0 e0       	ldi	r26, 0x00	; 0
    5ee8:	b0 e0       	ldi	r27, 0x00	; 0
    5eea:	e6 14       	cp	r14, r6
    5eec:	f7 04       	cpc	r15, r7
    5eee:	08 05       	cpc	r16, r8
    5ef0:	19 05       	cpc	r17, r9
    5ef2:	20 f4       	brcc	.+8      	; 0x5efc <__mulsf3+0xe8>
    5ef4:	81 e0       	ldi	r24, 0x01	; 1
    5ef6:	90 e0       	ldi	r25, 0x00	; 0
    5ef8:	a0 e0       	ldi	r26, 0x00	; 0
    5efa:	b0 e0       	ldi	r27, 0x00	; 0
    5efc:	ba 01       	movw	r22, r20
    5efe:	a9 01       	movw	r20, r18
    5f00:	48 0f       	add	r20, r24
    5f02:	59 1f       	adc	r21, r25
    5f04:	6a 1f       	adc	r22, r26
    5f06:	7b 1f       	adc	r23, r27
    5f08:	aa 0c       	add	r10, r10
    5f0a:	bb 1c       	adc	r11, r11
    5f0c:	cc 1c       	adc	r12, r12
    5f0e:	dd 1c       	adc	r13, r13
    5f10:	97 fe       	sbrs	r9, 7
    5f12:	08 c0       	rjmp	.+16     	; 0x5f24 <__mulsf3+0x110>
    5f14:	81 e0       	ldi	r24, 0x01	; 1
    5f16:	90 e0       	ldi	r25, 0x00	; 0
    5f18:	a0 e0       	ldi	r26, 0x00	; 0
    5f1a:	b0 e0       	ldi	r27, 0x00	; 0
    5f1c:	a8 2a       	or	r10, r24
    5f1e:	b9 2a       	or	r11, r25
    5f20:	ca 2a       	or	r12, r26
    5f22:	db 2a       	or	r13, r27
    5f24:	31 96       	adiw	r30, 0x01	; 1
    5f26:	e0 32       	cpi	r30, 0x20	; 32
    5f28:	f1 05       	cpc	r31, r1
    5f2a:	49 f0       	breq	.+18     	; 0x5f3e <__mulsf3+0x12a>
    5f2c:	66 0c       	add	r6, r6
    5f2e:	77 1c       	adc	r7, r7
    5f30:	88 1c       	adc	r8, r8
    5f32:	99 1c       	adc	r9, r9
    5f34:	56 94       	lsr	r5
    5f36:	47 94       	ror	r4
    5f38:	37 94       	ror	r3
    5f3a:	27 94       	ror	r2
    5f3c:	c3 cf       	rjmp	.-122    	; 0x5ec4 <__mulsf3+0xb0>
    5f3e:	fa 85       	ldd	r31, Y+10	; 0x0a
    5f40:	ea 89       	ldd	r30, Y+18	; 0x12
    5f42:	2b 89       	ldd	r18, Y+19	; 0x13
    5f44:	3c 89       	ldd	r19, Y+20	; 0x14
    5f46:	8b 85       	ldd	r24, Y+11	; 0x0b
    5f48:	9c 85       	ldd	r25, Y+12	; 0x0c
    5f4a:	28 0f       	add	r18, r24
    5f4c:	39 1f       	adc	r19, r25
    5f4e:	2e 5f       	subi	r18, 0xFE	; 254
    5f50:	3f 4f       	sbci	r19, 0xFF	; 255
    5f52:	17 c0       	rjmp	.+46     	; 0x5f82 <__mulsf3+0x16e>
    5f54:	ca 01       	movw	r24, r20
    5f56:	81 70       	andi	r24, 0x01	; 1
    5f58:	90 70       	andi	r25, 0x00	; 0
    5f5a:	89 2b       	or	r24, r25
    5f5c:	61 f0       	breq	.+24     	; 0x5f76 <__mulsf3+0x162>
    5f5e:	16 95       	lsr	r17
    5f60:	07 95       	ror	r16
    5f62:	f7 94       	ror	r15
    5f64:	e7 94       	ror	r14
    5f66:	80 e0       	ldi	r24, 0x00	; 0
    5f68:	90 e0       	ldi	r25, 0x00	; 0
    5f6a:	a0 e0       	ldi	r26, 0x00	; 0
    5f6c:	b0 e8       	ldi	r27, 0x80	; 128
    5f6e:	e8 2a       	or	r14, r24
    5f70:	f9 2a       	or	r15, r25
    5f72:	0a 2b       	or	r16, r26
    5f74:	1b 2b       	or	r17, r27
    5f76:	76 95       	lsr	r23
    5f78:	67 95       	ror	r22
    5f7a:	57 95       	ror	r21
    5f7c:	47 95       	ror	r20
    5f7e:	2f 5f       	subi	r18, 0xFF	; 255
    5f80:	3f 4f       	sbci	r19, 0xFF	; 255
    5f82:	77 fd       	sbrc	r23, 7
    5f84:	e7 cf       	rjmp	.-50     	; 0x5f54 <__mulsf3+0x140>
    5f86:	0c c0       	rjmp	.+24     	; 0x5fa0 <__mulsf3+0x18c>
    5f88:	44 0f       	add	r20, r20
    5f8a:	55 1f       	adc	r21, r21
    5f8c:	66 1f       	adc	r22, r22
    5f8e:	77 1f       	adc	r23, r23
    5f90:	17 fd       	sbrc	r17, 7
    5f92:	41 60       	ori	r20, 0x01	; 1
    5f94:	ee 0c       	add	r14, r14
    5f96:	ff 1c       	adc	r15, r15
    5f98:	00 1f       	adc	r16, r16
    5f9a:	11 1f       	adc	r17, r17
    5f9c:	21 50       	subi	r18, 0x01	; 1
    5f9e:	30 40       	sbci	r19, 0x00	; 0
    5fa0:	40 30       	cpi	r20, 0x00	; 0
    5fa2:	90 e0       	ldi	r25, 0x00	; 0
    5fa4:	59 07       	cpc	r21, r25
    5fa6:	90 e0       	ldi	r25, 0x00	; 0
    5fa8:	69 07       	cpc	r22, r25
    5faa:	90 e4       	ldi	r25, 0x40	; 64
    5fac:	79 07       	cpc	r23, r25
    5fae:	60 f3       	brcs	.-40     	; 0x5f88 <__mulsf3+0x174>
    5fb0:	2b 8f       	std	Y+27, r18	; 0x1b
    5fb2:	3c 8f       	std	Y+28, r19	; 0x1c
    5fb4:	db 01       	movw	r26, r22
    5fb6:	ca 01       	movw	r24, r20
    5fb8:	8f 77       	andi	r24, 0x7F	; 127
    5fba:	90 70       	andi	r25, 0x00	; 0
    5fbc:	a0 70       	andi	r26, 0x00	; 0
    5fbe:	b0 70       	andi	r27, 0x00	; 0
    5fc0:	80 34       	cpi	r24, 0x40	; 64
    5fc2:	91 05       	cpc	r25, r1
    5fc4:	a1 05       	cpc	r26, r1
    5fc6:	b1 05       	cpc	r27, r1
    5fc8:	61 f4       	brne	.+24     	; 0x5fe2 <__mulsf3+0x1ce>
    5fca:	47 fd       	sbrc	r20, 7
    5fcc:	0a c0       	rjmp	.+20     	; 0x5fe2 <__mulsf3+0x1ce>
    5fce:	e1 14       	cp	r14, r1
    5fd0:	f1 04       	cpc	r15, r1
    5fd2:	01 05       	cpc	r16, r1
    5fd4:	11 05       	cpc	r17, r1
    5fd6:	29 f0       	breq	.+10     	; 0x5fe2 <__mulsf3+0x1ce>
    5fd8:	40 5c       	subi	r20, 0xC0	; 192
    5fda:	5f 4f       	sbci	r21, 0xFF	; 255
    5fdc:	6f 4f       	sbci	r22, 0xFF	; 255
    5fde:	7f 4f       	sbci	r23, 0xFF	; 255
    5fe0:	40 78       	andi	r20, 0x80	; 128
    5fe2:	1a 8e       	std	Y+26, r1	; 0x1a
    5fe4:	fe 17       	cp	r31, r30
    5fe6:	11 f0       	breq	.+4      	; 0x5fec <__mulsf3+0x1d8>
    5fe8:	81 e0       	ldi	r24, 0x01	; 1
    5fea:	8a 8f       	std	Y+26, r24	; 0x1a
    5fec:	4d 8f       	std	Y+29, r20	; 0x1d
    5fee:	5e 8f       	std	Y+30, r21	; 0x1e
    5ff0:	6f 8f       	std	Y+31, r22	; 0x1f
    5ff2:	78 a3       	std	Y+32, r23	; 0x20
    5ff4:	83 e0       	ldi	r24, 0x03	; 3
    5ff6:	89 8f       	std	Y+25, r24	; 0x19
    5ff8:	ce 01       	movw	r24, r28
    5ffa:	49 96       	adiw	r24, 0x19	; 25
    5ffc:	0e 94 ba 32 	call	0x6574	; 0x6574 <__pack_f>
    6000:	a0 96       	adiw	r28, 0x20	; 32
    6002:	e2 e1       	ldi	r30, 0x12	; 18
    6004:	0c 94 7c 34 	jmp	0x68f8	; 0x68f8 <__epilogue_restores__>

00006008 <__divsf3>:
    6008:	a8 e1       	ldi	r26, 0x18	; 24
    600a:	b0 e0       	ldi	r27, 0x00	; 0
    600c:	ea e0       	ldi	r30, 0x0A	; 10
    600e:	f0 e3       	ldi	r31, 0x30	; 48
    6010:	0c 94 68 34 	jmp	0x68d0	; 0x68d0 <__prologue_saves__+0x10>
    6014:	69 83       	std	Y+1, r22	; 0x01
    6016:	7a 83       	std	Y+2, r23	; 0x02
    6018:	8b 83       	std	Y+3, r24	; 0x03
    601a:	9c 83       	std	Y+4, r25	; 0x04
    601c:	2d 83       	std	Y+5, r18	; 0x05
    601e:	3e 83       	std	Y+6, r19	; 0x06
    6020:	4f 83       	std	Y+7, r20	; 0x07
    6022:	58 87       	std	Y+8, r21	; 0x08
    6024:	b9 e0       	ldi	r27, 0x09	; 9
    6026:	eb 2e       	mov	r14, r27
    6028:	f1 2c       	mov	r15, r1
    602a:	ec 0e       	add	r14, r28
    602c:	fd 1e       	adc	r15, r29
    602e:	ce 01       	movw	r24, r28
    6030:	01 96       	adiw	r24, 0x01	; 1
    6032:	b7 01       	movw	r22, r14
    6034:	0e 94 8f 33 	call	0x671e	; 0x671e <__unpack_f>
    6038:	8e 01       	movw	r16, r28
    603a:	0f 5e       	subi	r16, 0xEF	; 239
    603c:	1f 4f       	sbci	r17, 0xFF	; 255
    603e:	ce 01       	movw	r24, r28
    6040:	05 96       	adiw	r24, 0x05	; 5
    6042:	b8 01       	movw	r22, r16
    6044:	0e 94 8f 33 	call	0x671e	; 0x671e <__unpack_f>
    6048:	29 85       	ldd	r18, Y+9	; 0x09
    604a:	22 30       	cpi	r18, 0x02	; 2
    604c:	08 f4       	brcc	.+2      	; 0x6050 <__divsf3+0x48>
    604e:	7e c0       	rjmp	.+252    	; 0x614c <__divsf3+0x144>
    6050:	39 89       	ldd	r19, Y+17	; 0x11
    6052:	32 30       	cpi	r19, 0x02	; 2
    6054:	10 f4       	brcc	.+4      	; 0x605a <__divsf3+0x52>
    6056:	b8 01       	movw	r22, r16
    6058:	7c c0       	rjmp	.+248    	; 0x6152 <__divsf3+0x14a>
    605a:	8a 85       	ldd	r24, Y+10	; 0x0a
    605c:	9a 89       	ldd	r25, Y+18	; 0x12
    605e:	89 27       	eor	r24, r25
    6060:	8a 87       	std	Y+10, r24	; 0x0a
    6062:	24 30       	cpi	r18, 0x04	; 4
    6064:	11 f0       	breq	.+4      	; 0x606a <__divsf3+0x62>
    6066:	22 30       	cpi	r18, 0x02	; 2
    6068:	31 f4       	brne	.+12     	; 0x6076 <__divsf3+0x6e>
    606a:	23 17       	cp	r18, r19
    606c:	09 f0       	breq	.+2      	; 0x6070 <__divsf3+0x68>
    606e:	6e c0       	rjmp	.+220    	; 0x614c <__divsf3+0x144>
    6070:	6f e5       	ldi	r22, 0x5F	; 95
    6072:	73 e0       	ldi	r23, 0x03	; 3
    6074:	6e c0       	rjmp	.+220    	; 0x6152 <__divsf3+0x14a>
    6076:	34 30       	cpi	r19, 0x04	; 4
    6078:	39 f4       	brne	.+14     	; 0x6088 <__divsf3+0x80>
    607a:	1d 86       	std	Y+13, r1	; 0x0d
    607c:	1e 86       	std	Y+14, r1	; 0x0e
    607e:	1f 86       	std	Y+15, r1	; 0x0f
    6080:	18 8a       	std	Y+16, r1	; 0x10
    6082:	1c 86       	std	Y+12, r1	; 0x0c
    6084:	1b 86       	std	Y+11, r1	; 0x0b
    6086:	04 c0       	rjmp	.+8      	; 0x6090 <__divsf3+0x88>
    6088:	32 30       	cpi	r19, 0x02	; 2
    608a:	21 f4       	brne	.+8      	; 0x6094 <__divsf3+0x8c>
    608c:	84 e0       	ldi	r24, 0x04	; 4
    608e:	89 87       	std	Y+9, r24	; 0x09
    6090:	b7 01       	movw	r22, r14
    6092:	5f c0       	rjmp	.+190    	; 0x6152 <__divsf3+0x14a>
    6094:	2b 85       	ldd	r18, Y+11	; 0x0b
    6096:	3c 85       	ldd	r19, Y+12	; 0x0c
    6098:	8b 89       	ldd	r24, Y+19	; 0x13
    609a:	9c 89       	ldd	r25, Y+20	; 0x14
    609c:	28 1b       	sub	r18, r24
    609e:	39 0b       	sbc	r19, r25
    60a0:	3c 87       	std	Y+12, r19	; 0x0c
    60a2:	2b 87       	std	Y+11, r18	; 0x0b
    60a4:	ed 84       	ldd	r14, Y+13	; 0x0d
    60a6:	fe 84       	ldd	r15, Y+14	; 0x0e
    60a8:	0f 85       	ldd	r16, Y+15	; 0x0f
    60aa:	18 89       	ldd	r17, Y+16	; 0x10
    60ac:	ad 88       	ldd	r10, Y+21	; 0x15
    60ae:	be 88       	ldd	r11, Y+22	; 0x16
    60b0:	cf 88       	ldd	r12, Y+23	; 0x17
    60b2:	d8 8c       	ldd	r13, Y+24	; 0x18
    60b4:	ea 14       	cp	r14, r10
    60b6:	fb 04       	cpc	r15, r11
    60b8:	0c 05       	cpc	r16, r12
    60ba:	1d 05       	cpc	r17, r13
    60bc:	40 f4       	brcc	.+16     	; 0x60ce <__divsf3+0xc6>
    60be:	ee 0c       	add	r14, r14
    60c0:	ff 1c       	adc	r15, r15
    60c2:	00 1f       	adc	r16, r16
    60c4:	11 1f       	adc	r17, r17
    60c6:	21 50       	subi	r18, 0x01	; 1
    60c8:	30 40       	sbci	r19, 0x00	; 0
    60ca:	3c 87       	std	Y+12, r19	; 0x0c
    60cc:	2b 87       	std	Y+11, r18	; 0x0b
    60ce:	20 e0       	ldi	r18, 0x00	; 0
    60d0:	30 e0       	ldi	r19, 0x00	; 0
    60d2:	40 e0       	ldi	r20, 0x00	; 0
    60d4:	50 e0       	ldi	r21, 0x00	; 0
    60d6:	80 e0       	ldi	r24, 0x00	; 0
    60d8:	90 e0       	ldi	r25, 0x00	; 0
    60da:	a0 e0       	ldi	r26, 0x00	; 0
    60dc:	b0 e4       	ldi	r27, 0x40	; 64
    60de:	60 e0       	ldi	r22, 0x00	; 0
    60e0:	70 e0       	ldi	r23, 0x00	; 0
    60e2:	ea 14       	cp	r14, r10
    60e4:	fb 04       	cpc	r15, r11
    60e6:	0c 05       	cpc	r16, r12
    60e8:	1d 05       	cpc	r17, r13
    60ea:	40 f0       	brcs	.+16     	; 0x60fc <__divsf3+0xf4>
    60ec:	28 2b       	or	r18, r24
    60ee:	39 2b       	or	r19, r25
    60f0:	4a 2b       	or	r20, r26
    60f2:	5b 2b       	or	r21, r27
    60f4:	ea 18       	sub	r14, r10
    60f6:	fb 08       	sbc	r15, r11
    60f8:	0c 09       	sbc	r16, r12
    60fa:	1d 09       	sbc	r17, r13
    60fc:	b6 95       	lsr	r27
    60fe:	a7 95       	ror	r26
    6100:	97 95       	ror	r25
    6102:	87 95       	ror	r24
    6104:	ee 0c       	add	r14, r14
    6106:	ff 1c       	adc	r15, r15
    6108:	00 1f       	adc	r16, r16
    610a:	11 1f       	adc	r17, r17
    610c:	6f 5f       	subi	r22, 0xFF	; 255
    610e:	7f 4f       	sbci	r23, 0xFF	; 255
    6110:	6f 31       	cpi	r22, 0x1F	; 31
    6112:	71 05       	cpc	r23, r1
    6114:	31 f7       	brne	.-52     	; 0x60e2 <__divsf3+0xda>
    6116:	da 01       	movw	r26, r20
    6118:	c9 01       	movw	r24, r18
    611a:	8f 77       	andi	r24, 0x7F	; 127
    611c:	90 70       	andi	r25, 0x00	; 0
    611e:	a0 70       	andi	r26, 0x00	; 0
    6120:	b0 70       	andi	r27, 0x00	; 0
    6122:	80 34       	cpi	r24, 0x40	; 64
    6124:	91 05       	cpc	r25, r1
    6126:	a1 05       	cpc	r26, r1
    6128:	b1 05       	cpc	r27, r1
    612a:	61 f4       	brne	.+24     	; 0x6144 <__divsf3+0x13c>
    612c:	27 fd       	sbrc	r18, 7
    612e:	0a c0       	rjmp	.+20     	; 0x6144 <__divsf3+0x13c>
    6130:	e1 14       	cp	r14, r1
    6132:	f1 04       	cpc	r15, r1
    6134:	01 05       	cpc	r16, r1
    6136:	11 05       	cpc	r17, r1
    6138:	29 f0       	breq	.+10     	; 0x6144 <__divsf3+0x13c>
    613a:	20 5c       	subi	r18, 0xC0	; 192
    613c:	3f 4f       	sbci	r19, 0xFF	; 255
    613e:	4f 4f       	sbci	r20, 0xFF	; 255
    6140:	5f 4f       	sbci	r21, 0xFF	; 255
    6142:	20 78       	andi	r18, 0x80	; 128
    6144:	2d 87       	std	Y+13, r18	; 0x0d
    6146:	3e 87       	std	Y+14, r19	; 0x0e
    6148:	4f 87       	std	Y+15, r20	; 0x0f
    614a:	58 8b       	std	Y+16, r21	; 0x10
    614c:	be 01       	movw	r22, r28
    614e:	67 5f       	subi	r22, 0xF7	; 247
    6150:	7f 4f       	sbci	r23, 0xFF	; 255
    6152:	cb 01       	movw	r24, r22
    6154:	0e 94 ba 32 	call	0x6574	; 0x6574 <__pack_f>
    6158:	68 96       	adiw	r28, 0x18	; 24
    615a:	ea e0       	ldi	r30, 0x0A	; 10
    615c:	0c 94 84 34 	jmp	0x6908	; 0x6908 <__epilogue_restores__+0x10>

00006160 <__gtsf2>:
    6160:	a8 e1       	ldi	r26, 0x18	; 24
    6162:	b0 e0       	ldi	r27, 0x00	; 0
    6164:	e6 eb       	ldi	r30, 0xB6	; 182
    6166:	f0 e3       	ldi	r31, 0x30	; 48
    6168:	0c 94 6c 34 	jmp	0x68d8	; 0x68d8 <__prologue_saves__+0x18>
    616c:	69 83       	std	Y+1, r22	; 0x01
    616e:	7a 83       	std	Y+2, r23	; 0x02
    6170:	8b 83       	std	Y+3, r24	; 0x03
    6172:	9c 83       	std	Y+4, r25	; 0x04
    6174:	2d 83       	std	Y+5, r18	; 0x05
    6176:	3e 83       	std	Y+6, r19	; 0x06
    6178:	4f 83       	std	Y+7, r20	; 0x07
    617a:	58 87       	std	Y+8, r21	; 0x08
    617c:	89 e0       	ldi	r24, 0x09	; 9
    617e:	e8 2e       	mov	r14, r24
    6180:	f1 2c       	mov	r15, r1
    6182:	ec 0e       	add	r14, r28
    6184:	fd 1e       	adc	r15, r29
    6186:	ce 01       	movw	r24, r28
    6188:	01 96       	adiw	r24, 0x01	; 1
    618a:	b7 01       	movw	r22, r14
    618c:	0e 94 8f 33 	call	0x671e	; 0x671e <__unpack_f>
    6190:	8e 01       	movw	r16, r28
    6192:	0f 5e       	subi	r16, 0xEF	; 239
    6194:	1f 4f       	sbci	r17, 0xFF	; 255
    6196:	ce 01       	movw	r24, r28
    6198:	05 96       	adiw	r24, 0x05	; 5
    619a:	b8 01       	movw	r22, r16
    619c:	0e 94 8f 33 	call	0x671e	; 0x671e <__unpack_f>
    61a0:	89 85       	ldd	r24, Y+9	; 0x09
    61a2:	82 30       	cpi	r24, 0x02	; 2
    61a4:	40 f0       	brcs	.+16     	; 0x61b6 <__gtsf2+0x56>
    61a6:	89 89       	ldd	r24, Y+17	; 0x11
    61a8:	82 30       	cpi	r24, 0x02	; 2
    61aa:	28 f0       	brcs	.+10     	; 0x61b6 <__gtsf2+0x56>
    61ac:	c7 01       	movw	r24, r14
    61ae:	b8 01       	movw	r22, r16
    61b0:	0e 94 07 34 	call	0x680e	; 0x680e <__fpcmp_parts_f>
    61b4:	01 c0       	rjmp	.+2      	; 0x61b8 <__gtsf2+0x58>
    61b6:	8f ef       	ldi	r24, 0xFF	; 255
    61b8:	68 96       	adiw	r28, 0x18	; 24
    61ba:	e6 e0       	ldi	r30, 0x06	; 6
    61bc:	0c 94 88 34 	jmp	0x6910	; 0x6910 <__epilogue_restores__+0x18>

000061c0 <__gesf2>:
    61c0:	a8 e1       	ldi	r26, 0x18	; 24
    61c2:	b0 e0       	ldi	r27, 0x00	; 0
    61c4:	e6 ee       	ldi	r30, 0xE6	; 230
    61c6:	f0 e3       	ldi	r31, 0x30	; 48
    61c8:	0c 94 6c 34 	jmp	0x68d8	; 0x68d8 <__prologue_saves__+0x18>
    61cc:	69 83       	std	Y+1, r22	; 0x01
    61ce:	7a 83       	std	Y+2, r23	; 0x02
    61d0:	8b 83       	std	Y+3, r24	; 0x03
    61d2:	9c 83       	std	Y+4, r25	; 0x04
    61d4:	2d 83       	std	Y+5, r18	; 0x05
    61d6:	3e 83       	std	Y+6, r19	; 0x06
    61d8:	4f 83       	std	Y+7, r20	; 0x07
    61da:	58 87       	std	Y+8, r21	; 0x08
    61dc:	89 e0       	ldi	r24, 0x09	; 9
    61de:	e8 2e       	mov	r14, r24
    61e0:	f1 2c       	mov	r15, r1
    61e2:	ec 0e       	add	r14, r28
    61e4:	fd 1e       	adc	r15, r29
    61e6:	ce 01       	movw	r24, r28
    61e8:	01 96       	adiw	r24, 0x01	; 1
    61ea:	b7 01       	movw	r22, r14
    61ec:	0e 94 8f 33 	call	0x671e	; 0x671e <__unpack_f>
    61f0:	8e 01       	movw	r16, r28
    61f2:	0f 5e       	subi	r16, 0xEF	; 239
    61f4:	1f 4f       	sbci	r17, 0xFF	; 255
    61f6:	ce 01       	movw	r24, r28
    61f8:	05 96       	adiw	r24, 0x05	; 5
    61fa:	b8 01       	movw	r22, r16
    61fc:	0e 94 8f 33 	call	0x671e	; 0x671e <__unpack_f>
    6200:	89 85       	ldd	r24, Y+9	; 0x09
    6202:	82 30       	cpi	r24, 0x02	; 2
    6204:	40 f0       	brcs	.+16     	; 0x6216 <__gesf2+0x56>
    6206:	89 89       	ldd	r24, Y+17	; 0x11
    6208:	82 30       	cpi	r24, 0x02	; 2
    620a:	28 f0       	brcs	.+10     	; 0x6216 <__gesf2+0x56>
    620c:	c7 01       	movw	r24, r14
    620e:	b8 01       	movw	r22, r16
    6210:	0e 94 07 34 	call	0x680e	; 0x680e <__fpcmp_parts_f>
    6214:	01 c0       	rjmp	.+2      	; 0x6218 <__gesf2+0x58>
    6216:	8f ef       	ldi	r24, 0xFF	; 255
    6218:	68 96       	adiw	r28, 0x18	; 24
    621a:	e6 e0       	ldi	r30, 0x06	; 6
    621c:	0c 94 88 34 	jmp	0x6910	; 0x6910 <__epilogue_restores__+0x18>

00006220 <__ltsf2>:
    6220:	a8 e1       	ldi	r26, 0x18	; 24
    6222:	b0 e0       	ldi	r27, 0x00	; 0
    6224:	e6 e1       	ldi	r30, 0x16	; 22
    6226:	f1 e3       	ldi	r31, 0x31	; 49
    6228:	0c 94 6c 34 	jmp	0x68d8	; 0x68d8 <__prologue_saves__+0x18>
    622c:	69 83       	std	Y+1, r22	; 0x01
    622e:	7a 83       	std	Y+2, r23	; 0x02
    6230:	8b 83       	std	Y+3, r24	; 0x03
    6232:	9c 83       	std	Y+4, r25	; 0x04
    6234:	2d 83       	std	Y+5, r18	; 0x05
    6236:	3e 83       	std	Y+6, r19	; 0x06
    6238:	4f 83       	std	Y+7, r20	; 0x07
    623a:	58 87       	std	Y+8, r21	; 0x08
    623c:	89 e0       	ldi	r24, 0x09	; 9
    623e:	e8 2e       	mov	r14, r24
    6240:	f1 2c       	mov	r15, r1
    6242:	ec 0e       	add	r14, r28
    6244:	fd 1e       	adc	r15, r29
    6246:	ce 01       	movw	r24, r28
    6248:	01 96       	adiw	r24, 0x01	; 1
    624a:	b7 01       	movw	r22, r14
    624c:	0e 94 8f 33 	call	0x671e	; 0x671e <__unpack_f>
    6250:	8e 01       	movw	r16, r28
    6252:	0f 5e       	subi	r16, 0xEF	; 239
    6254:	1f 4f       	sbci	r17, 0xFF	; 255
    6256:	ce 01       	movw	r24, r28
    6258:	05 96       	adiw	r24, 0x05	; 5
    625a:	b8 01       	movw	r22, r16
    625c:	0e 94 8f 33 	call	0x671e	; 0x671e <__unpack_f>
    6260:	89 85       	ldd	r24, Y+9	; 0x09
    6262:	82 30       	cpi	r24, 0x02	; 2
    6264:	40 f0       	brcs	.+16     	; 0x6276 <__ltsf2+0x56>
    6266:	89 89       	ldd	r24, Y+17	; 0x11
    6268:	82 30       	cpi	r24, 0x02	; 2
    626a:	28 f0       	brcs	.+10     	; 0x6276 <__ltsf2+0x56>
    626c:	c7 01       	movw	r24, r14
    626e:	b8 01       	movw	r22, r16
    6270:	0e 94 07 34 	call	0x680e	; 0x680e <__fpcmp_parts_f>
    6274:	01 c0       	rjmp	.+2      	; 0x6278 <__ltsf2+0x58>
    6276:	81 e0       	ldi	r24, 0x01	; 1
    6278:	68 96       	adiw	r28, 0x18	; 24
    627a:	e6 e0       	ldi	r30, 0x06	; 6
    627c:	0c 94 88 34 	jmp	0x6910	; 0x6910 <__epilogue_restores__+0x18>

00006280 <__floatsisf>:
    6280:	a8 e0       	ldi	r26, 0x08	; 8
    6282:	b0 e0       	ldi	r27, 0x00	; 0
    6284:	e6 e4       	ldi	r30, 0x46	; 70
    6286:	f1 e3       	ldi	r31, 0x31	; 49
    6288:	0c 94 69 34 	jmp	0x68d2	; 0x68d2 <__prologue_saves__+0x12>
    628c:	9b 01       	movw	r18, r22
    628e:	ac 01       	movw	r20, r24
    6290:	83 e0       	ldi	r24, 0x03	; 3
    6292:	89 83       	std	Y+1, r24	; 0x01
    6294:	da 01       	movw	r26, r20
    6296:	c9 01       	movw	r24, r18
    6298:	88 27       	eor	r24, r24
    629a:	b7 fd       	sbrc	r27, 7
    629c:	83 95       	inc	r24
    629e:	99 27       	eor	r25, r25
    62a0:	aa 27       	eor	r26, r26
    62a2:	bb 27       	eor	r27, r27
    62a4:	b8 2e       	mov	r11, r24
    62a6:	21 15       	cp	r18, r1
    62a8:	31 05       	cpc	r19, r1
    62aa:	41 05       	cpc	r20, r1
    62ac:	51 05       	cpc	r21, r1
    62ae:	19 f4       	brne	.+6      	; 0x62b6 <__floatsisf+0x36>
    62b0:	82 e0       	ldi	r24, 0x02	; 2
    62b2:	89 83       	std	Y+1, r24	; 0x01
    62b4:	3a c0       	rjmp	.+116    	; 0x632a <__floatsisf+0xaa>
    62b6:	88 23       	and	r24, r24
    62b8:	a9 f0       	breq	.+42     	; 0x62e4 <__floatsisf+0x64>
    62ba:	20 30       	cpi	r18, 0x00	; 0
    62bc:	80 e0       	ldi	r24, 0x00	; 0
    62be:	38 07       	cpc	r19, r24
    62c0:	80 e0       	ldi	r24, 0x00	; 0
    62c2:	48 07       	cpc	r20, r24
    62c4:	80 e8       	ldi	r24, 0x80	; 128
    62c6:	58 07       	cpc	r21, r24
    62c8:	29 f4       	brne	.+10     	; 0x62d4 <__floatsisf+0x54>
    62ca:	60 e0       	ldi	r22, 0x00	; 0
    62cc:	70 e0       	ldi	r23, 0x00	; 0
    62ce:	80 e0       	ldi	r24, 0x00	; 0
    62d0:	9f ec       	ldi	r25, 0xCF	; 207
    62d2:	30 c0       	rjmp	.+96     	; 0x6334 <__floatsisf+0xb4>
    62d4:	ee 24       	eor	r14, r14
    62d6:	ff 24       	eor	r15, r15
    62d8:	87 01       	movw	r16, r14
    62da:	e2 1a       	sub	r14, r18
    62dc:	f3 0a       	sbc	r15, r19
    62de:	04 0b       	sbc	r16, r20
    62e0:	15 0b       	sbc	r17, r21
    62e2:	02 c0       	rjmp	.+4      	; 0x62e8 <__floatsisf+0x68>
    62e4:	79 01       	movw	r14, r18
    62e6:	8a 01       	movw	r16, r20
    62e8:	8e e1       	ldi	r24, 0x1E	; 30
    62ea:	c8 2e       	mov	r12, r24
    62ec:	d1 2c       	mov	r13, r1
    62ee:	dc 82       	std	Y+4, r13	; 0x04
    62f0:	cb 82       	std	Y+3, r12	; 0x03
    62f2:	ed 82       	std	Y+5, r14	; 0x05
    62f4:	fe 82       	std	Y+6, r15	; 0x06
    62f6:	0f 83       	std	Y+7, r16	; 0x07
    62f8:	18 87       	std	Y+8, r17	; 0x08
    62fa:	c8 01       	movw	r24, r16
    62fc:	b7 01       	movw	r22, r14
    62fe:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <__clzsi2>
    6302:	01 97       	sbiw	r24, 0x01	; 1
    6304:	18 16       	cp	r1, r24
    6306:	19 06       	cpc	r1, r25
    6308:	84 f4       	brge	.+32     	; 0x632a <__floatsisf+0xaa>
    630a:	08 2e       	mov	r0, r24
    630c:	04 c0       	rjmp	.+8      	; 0x6316 <__floatsisf+0x96>
    630e:	ee 0c       	add	r14, r14
    6310:	ff 1c       	adc	r15, r15
    6312:	00 1f       	adc	r16, r16
    6314:	11 1f       	adc	r17, r17
    6316:	0a 94       	dec	r0
    6318:	d2 f7       	brpl	.-12     	; 0x630e <__floatsisf+0x8e>
    631a:	ed 82       	std	Y+5, r14	; 0x05
    631c:	fe 82       	std	Y+6, r15	; 0x06
    631e:	0f 83       	std	Y+7, r16	; 0x07
    6320:	18 87       	std	Y+8, r17	; 0x08
    6322:	c8 1a       	sub	r12, r24
    6324:	d9 0a       	sbc	r13, r25
    6326:	dc 82       	std	Y+4, r13	; 0x04
    6328:	cb 82       	std	Y+3, r12	; 0x03
    632a:	ba 82       	std	Y+2, r11	; 0x02
    632c:	ce 01       	movw	r24, r28
    632e:	01 96       	adiw	r24, 0x01	; 1
    6330:	0e 94 ba 32 	call	0x6574	; 0x6574 <__pack_f>
    6334:	28 96       	adiw	r28, 0x08	; 8
    6336:	e9 e0       	ldi	r30, 0x09	; 9
    6338:	0c 94 85 34 	jmp	0x690a	; 0x690a <__epilogue_restores__+0x12>

0000633c <__fixsfsi>:
    633c:	ac e0       	ldi	r26, 0x0C	; 12
    633e:	b0 e0       	ldi	r27, 0x00	; 0
    6340:	e4 ea       	ldi	r30, 0xA4	; 164
    6342:	f1 e3       	ldi	r31, 0x31	; 49
    6344:	0c 94 70 34 	jmp	0x68e0	; 0x68e0 <__prologue_saves__+0x20>
    6348:	69 83       	std	Y+1, r22	; 0x01
    634a:	7a 83       	std	Y+2, r23	; 0x02
    634c:	8b 83       	std	Y+3, r24	; 0x03
    634e:	9c 83       	std	Y+4, r25	; 0x04
    6350:	ce 01       	movw	r24, r28
    6352:	01 96       	adiw	r24, 0x01	; 1
    6354:	be 01       	movw	r22, r28
    6356:	6b 5f       	subi	r22, 0xFB	; 251
    6358:	7f 4f       	sbci	r23, 0xFF	; 255
    635a:	0e 94 8f 33 	call	0x671e	; 0x671e <__unpack_f>
    635e:	8d 81       	ldd	r24, Y+5	; 0x05
    6360:	82 30       	cpi	r24, 0x02	; 2
    6362:	61 f1       	breq	.+88     	; 0x63bc <__fixsfsi+0x80>
    6364:	82 30       	cpi	r24, 0x02	; 2
    6366:	50 f1       	brcs	.+84     	; 0x63bc <__fixsfsi+0x80>
    6368:	84 30       	cpi	r24, 0x04	; 4
    636a:	21 f4       	brne	.+8      	; 0x6374 <__fixsfsi+0x38>
    636c:	8e 81       	ldd	r24, Y+6	; 0x06
    636e:	88 23       	and	r24, r24
    6370:	51 f1       	breq	.+84     	; 0x63c6 <__fixsfsi+0x8a>
    6372:	2e c0       	rjmp	.+92     	; 0x63d0 <__fixsfsi+0x94>
    6374:	2f 81       	ldd	r18, Y+7	; 0x07
    6376:	38 85       	ldd	r19, Y+8	; 0x08
    6378:	37 fd       	sbrc	r19, 7
    637a:	20 c0       	rjmp	.+64     	; 0x63bc <__fixsfsi+0x80>
    637c:	6e 81       	ldd	r22, Y+6	; 0x06
    637e:	2f 31       	cpi	r18, 0x1F	; 31
    6380:	31 05       	cpc	r19, r1
    6382:	1c f0       	brlt	.+6      	; 0x638a <__fixsfsi+0x4e>
    6384:	66 23       	and	r22, r22
    6386:	f9 f0       	breq	.+62     	; 0x63c6 <__fixsfsi+0x8a>
    6388:	23 c0       	rjmp	.+70     	; 0x63d0 <__fixsfsi+0x94>
    638a:	8e e1       	ldi	r24, 0x1E	; 30
    638c:	90 e0       	ldi	r25, 0x00	; 0
    638e:	82 1b       	sub	r24, r18
    6390:	93 0b       	sbc	r25, r19
    6392:	29 85       	ldd	r18, Y+9	; 0x09
    6394:	3a 85       	ldd	r19, Y+10	; 0x0a
    6396:	4b 85       	ldd	r20, Y+11	; 0x0b
    6398:	5c 85       	ldd	r21, Y+12	; 0x0c
    639a:	04 c0       	rjmp	.+8      	; 0x63a4 <__fixsfsi+0x68>
    639c:	56 95       	lsr	r21
    639e:	47 95       	ror	r20
    63a0:	37 95       	ror	r19
    63a2:	27 95       	ror	r18
    63a4:	8a 95       	dec	r24
    63a6:	d2 f7       	brpl	.-12     	; 0x639c <__fixsfsi+0x60>
    63a8:	66 23       	and	r22, r22
    63aa:	b1 f0       	breq	.+44     	; 0x63d8 <__fixsfsi+0x9c>
    63ac:	50 95       	com	r21
    63ae:	40 95       	com	r20
    63b0:	30 95       	com	r19
    63b2:	21 95       	neg	r18
    63b4:	3f 4f       	sbci	r19, 0xFF	; 255
    63b6:	4f 4f       	sbci	r20, 0xFF	; 255
    63b8:	5f 4f       	sbci	r21, 0xFF	; 255
    63ba:	0e c0       	rjmp	.+28     	; 0x63d8 <__fixsfsi+0x9c>
    63bc:	20 e0       	ldi	r18, 0x00	; 0
    63be:	30 e0       	ldi	r19, 0x00	; 0
    63c0:	40 e0       	ldi	r20, 0x00	; 0
    63c2:	50 e0       	ldi	r21, 0x00	; 0
    63c4:	09 c0       	rjmp	.+18     	; 0x63d8 <__fixsfsi+0x9c>
    63c6:	2f ef       	ldi	r18, 0xFF	; 255
    63c8:	3f ef       	ldi	r19, 0xFF	; 255
    63ca:	4f ef       	ldi	r20, 0xFF	; 255
    63cc:	5f e7       	ldi	r21, 0x7F	; 127
    63ce:	04 c0       	rjmp	.+8      	; 0x63d8 <__fixsfsi+0x9c>
    63d0:	20 e0       	ldi	r18, 0x00	; 0
    63d2:	30 e0       	ldi	r19, 0x00	; 0
    63d4:	40 e0       	ldi	r20, 0x00	; 0
    63d6:	50 e8       	ldi	r21, 0x80	; 128
    63d8:	b9 01       	movw	r22, r18
    63da:	ca 01       	movw	r24, r20
    63dc:	2c 96       	adiw	r28, 0x0c	; 12
    63de:	e2 e0       	ldi	r30, 0x02	; 2
    63e0:	0c 94 8c 34 	jmp	0x6918	; 0x6918 <__epilogue_restores__+0x20>

000063e4 <__floatunsisf>:
    63e4:	a8 e0       	ldi	r26, 0x08	; 8
    63e6:	b0 e0       	ldi	r27, 0x00	; 0
    63e8:	e8 ef       	ldi	r30, 0xF8	; 248
    63ea:	f1 e3       	ldi	r31, 0x31	; 49
    63ec:	0c 94 68 34 	jmp	0x68d0	; 0x68d0 <__prologue_saves__+0x10>
    63f0:	7b 01       	movw	r14, r22
    63f2:	8c 01       	movw	r16, r24
    63f4:	61 15       	cp	r22, r1
    63f6:	71 05       	cpc	r23, r1
    63f8:	81 05       	cpc	r24, r1
    63fa:	91 05       	cpc	r25, r1
    63fc:	19 f4       	brne	.+6      	; 0x6404 <__floatunsisf+0x20>
    63fe:	82 e0       	ldi	r24, 0x02	; 2
    6400:	89 83       	std	Y+1, r24	; 0x01
    6402:	60 c0       	rjmp	.+192    	; 0x64c4 <__floatunsisf+0xe0>
    6404:	83 e0       	ldi	r24, 0x03	; 3
    6406:	89 83       	std	Y+1, r24	; 0x01
    6408:	8e e1       	ldi	r24, 0x1E	; 30
    640a:	c8 2e       	mov	r12, r24
    640c:	d1 2c       	mov	r13, r1
    640e:	dc 82       	std	Y+4, r13	; 0x04
    6410:	cb 82       	std	Y+3, r12	; 0x03
    6412:	ed 82       	std	Y+5, r14	; 0x05
    6414:	fe 82       	std	Y+6, r15	; 0x06
    6416:	0f 83       	std	Y+7, r16	; 0x07
    6418:	18 87       	std	Y+8, r17	; 0x08
    641a:	c8 01       	movw	r24, r16
    641c:	b7 01       	movw	r22, r14
    641e:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <__clzsi2>
    6422:	fc 01       	movw	r30, r24
    6424:	31 97       	sbiw	r30, 0x01	; 1
    6426:	f7 ff       	sbrs	r31, 7
    6428:	3b c0       	rjmp	.+118    	; 0x64a0 <__floatunsisf+0xbc>
    642a:	22 27       	eor	r18, r18
    642c:	33 27       	eor	r19, r19
    642e:	2e 1b       	sub	r18, r30
    6430:	3f 0b       	sbc	r19, r31
    6432:	57 01       	movw	r10, r14
    6434:	68 01       	movw	r12, r16
    6436:	02 2e       	mov	r0, r18
    6438:	04 c0       	rjmp	.+8      	; 0x6442 <__floatunsisf+0x5e>
    643a:	d6 94       	lsr	r13
    643c:	c7 94       	ror	r12
    643e:	b7 94       	ror	r11
    6440:	a7 94       	ror	r10
    6442:	0a 94       	dec	r0
    6444:	d2 f7       	brpl	.-12     	; 0x643a <__floatunsisf+0x56>
    6446:	40 e0       	ldi	r20, 0x00	; 0
    6448:	50 e0       	ldi	r21, 0x00	; 0
    644a:	60 e0       	ldi	r22, 0x00	; 0
    644c:	70 e0       	ldi	r23, 0x00	; 0
    644e:	81 e0       	ldi	r24, 0x01	; 1
    6450:	90 e0       	ldi	r25, 0x00	; 0
    6452:	a0 e0       	ldi	r26, 0x00	; 0
    6454:	b0 e0       	ldi	r27, 0x00	; 0
    6456:	04 c0       	rjmp	.+8      	; 0x6460 <__floatunsisf+0x7c>
    6458:	88 0f       	add	r24, r24
    645a:	99 1f       	adc	r25, r25
    645c:	aa 1f       	adc	r26, r26
    645e:	bb 1f       	adc	r27, r27
    6460:	2a 95       	dec	r18
    6462:	d2 f7       	brpl	.-12     	; 0x6458 <__floatunsisf+0x74>
    6464:	01 97       	sbiw	r24, 0x01	; 1
    6466:	a1 09       	sbc	r26, r1
    6468:	b1 09       	sbc	r27, r1
    646a:	8e 21       	and	r24, r14
    646c:	9f 21       	and	r25, r15
    646e:	a0 23       	and	r26, r16
    6470:	b1 23       	and	r27, r17
    6472:	00 97       	sbiw	r24, 0x00	; 0
    6474:	a1 05       	cpc	r26, r1
    6476:	b1 05       	cpc	r27, r1
    6478:	21 f0       	breq	.+8      	; 0x6482 <__floatunsisf+0x9e>
    647a:	41 e0       	ldi	r20, 0x01	; 1
    647c:	50 e0       	ldi	r21, 0x00	; 0
    647e:	60 e0       	ldi	r22, 0x00	; 0
    6480:	70 e0       	ldi	r23, 0x00	; 0
    6482:	4a 29       	or	r20, r10
    6484:	5b 29       	or	r21, r11
    6486:	6c 29       	or	r22, r12
    6488:	7d 29       	or	r23, r13
    648a:	4d 83       	std	Y+5, r20	; 0x05
    648c:	5e 83       	std	Y+6, r21	; 0x06
    648e:	6f 83       	std	Y+7, r22	; 0x07
    6490:	78 87       	std	Y+8, r23	; 0x08
    6492:	8e e1       	ldi	r24, 0x1E	; 30
    6494:	90 e0       	ldi	r25, 0x00	; 0
    6496:	8e 1b       	sub	r24, r30
    6498:	9f 0b       	sbc	r25, r31
    649a:	9c 83       	std	Y+4, r25	; 0x04
    649c:	8b 83       	std	Y+3, r24	; 0x03
    649e:	12 c0       	rjmp	.+36     	; 0x64c4 <__floatunsisf+0xe0>
    64a0:	30 97       	sbiw	r30, 0x00	; 0
    64a2:	81 f0       	breq	.+32     	; 0x64c4 <__floatunsisf+0xe0>
    64a4:	0e 2e       	mov	r0, r30
    64a6:	04 c0       	rjmp	.+8      	; 0x64b0 <__floatunsisf+0xcc>
    64a8:	ee 0c       	add	r14, r14
    64aa:	ff 1c       	adc	r15, r15
    64ac:	00 1f       	adc	r16, r16
    64ae:	11 1f       	adc	r17, r17
    64b0:	0a 94       	dec	r0
    64b2:	d2 f7       	brpl	.-12     	; 0x64a8 <__floatunsisf+0xc4>
    64b4:	ed 82       	std	Y+5, r14	; 0x05
    64b6:	fe 82       	std	Y+6, r15	; 0x06
    64b8:	0f 83       	std	Y+7, r16	; 0x07
    64ba:	18 87       	std	Y+8, r17	; 0x08
    64bc:	ce 1a       	sub	r12, r30
    64be:	df 0a       	sbc	r13, r31
    64c0:	dc 82       	std	Y+4, r13	; 0x04
    64c2:	cb 82       	std	Y+3, r12	; 0x03
    64c4:	1a 82       	std	Y+2, r1	; 0x02
    64c6:	ce 01       	movw	r24, r28
    64c8:	01 96       	adiw	r24, 0x01	; 1
    64ca:	0e 94 ba 32 	call	0x6574	; 0x6574 <__pack_f>
    64ce:	28 96       	adiw	r28, 0x08	; 8
    64d0:	ea e0       	ldi	r30, 0x0A	; 10
    64d2:	0c 94 84 34 	jmp	0x6908	; 0x6908 <__epilogue_restores__+0x10>

000064d6 <__clzsi2>:
    64d6:	ef 92       	push	r14
    64d8:	ff 92       	push	r15
    64da:	0f 93       	push	r16
    64dc:	1f 93       	push	r17
    64de:	7b 01       	movw	r14, r22
    64e0:	8c 01       	movw	r16, r24
    64e2:	80 e0       	ldi	r24, 0x00	; 0
    64e4:	e8 16       	cp	r14, r24
    64e6:	80 e0       	ldi	r24, 0x00	; 0
    64e8:	f8 06       	cpc	r15, r24
    64ea:	81 e0       	ldi	r24, 0x01	; 1
    64ec:	08 07       	cpc	r16, r24
    64ee:	80 e0       	ldi	r24, 0x00	; 0
    64f0:	18 07       	cpc	r17, r24
    64f2:	88 f4       	brcc	.+34     	; 0x6516 <__clzsi2+0x40>
    64f4:	8f ef       	ldi	r24, 0xFF	; 255
    64f6:	e8 16       	cp	r14, r24
    64f8:	f1 04       	cpc	r15, r1
    64fa:	01 05       	cpc	r16, r1
    64fc:	11 05       	cpc	r17, r1
    64fe:	31 f0       	breq	.+12     	; 0x650c <__clzsi2+0x36>
    6500:	28 f0       	brcs	.+10     	; 0x650c <__clzsi2+0x36>
    6502:	88 e0       	ldi	r24, 0x08	; 8
    6504:	90 e0       	ldi	r25, 0x00	; 0
    6506:	a0 e0       	ldi	r26, 0x00	; 0
    6508:	b0 e0       	ldi	r27, 0x00	; 0
    650a:	17 c0       	rjmp	.+46     	; 0x653a <__clzsi2+0x64>
    650c:	80 e0       	ldi	r24, 0x00	; 0
    650e:	90 e0       	ldi	r25, 0x00	; 0
    6510:	a0 e0       	ldi	r26, 0x00	; 0
    6512:	b0 e0       	ldi	r27, 0x00	; 0
    6514:	12 c0       	rjmp	.+36     	; 0x653a <__clzsi2+0x64>
    6516:	80 e0       	ldi	r24, 0x00	; 0
    6518:	e8 16       	cp	r14, r24
    651a:	80 e0       	ldi	r24, 0x00	; 0
    651c:	f8 06       	cpc	r15, r24
    651e:	80 e0       	ldi	r24, 0x00	; 0
    6520:	08 07       	cpc	r16, r24
    6522:	81 e0       	ldi	r24, 0x01	; 1
    6524:	18 07       	cpc	r17, r24
    6526:	28 f0       	brcs	.+10     	; 0x6532 <__clzsi2+0x5c>
    6528:	88 e1       	ldi	r24, 0x18	; 24
    652a:	90 e0       	ldi	r25, 0x00	; 0
    652c:	a0 e0       	ldi	r26, 0x00	; 0
    652e:	b0 e0       	ldi	r27, 0x00	; 0
    6530:	04 c0       	rjmp	.+8      	; 0x653a <__clzsi2+0x64>
    6532:	80 e1       	ldi	r24, 0x10	; 16
    6534:	90 e0       	ldi	r25, 0x00	; 0
    6536:	a0 e0       	ldi	r26, 0x00	; 0
    6538:	b0 e0       	ldi	r27, 0x00	; 0
    653a:	20 e2       	ldi	r18, 0x20	; 32
    653c:	30 e0       	ldi	r19, 0x00	; 0
    653e:	40 e0       	ldi	r20, 0x00	; 0
    6540:	50 e0       	ldi	r21, 0x00	; 0
    6542:	28 1b       	sub	r18, r24
    6544:	39 0b       	sbc	r19, r25
    6546:	4a 0b       	sbc	r20, r26
    6548:	5b 0b       	sbc	r21, r27
    654a:	04 c0       	rjmp	.+8      	; 0x6554 <__clzsi2+0x7e>
    654c:	16 95       	lsr	r17
    654e:	07 95       	ror	r16
    6550:	f7 94       	ror	r15
    6552:	e7 94       	ror	r14
    6554:	8a 95       	dec	r24
    6556:	d2 f7       	brpl	.-12     	; 0x654c <__clzsi2+0x76>
    6558:	f7 01       	movw	r30, r14
    655a:	e9 59       	subi	r30, 0x99	; 153
    655c:	fc 4f       	sbci	r31, 0xFC	; 252
    655e:	80 81       	ld	r24, Z
    6560:	28 1b       	sub	r18, r24
    6562:	31 09       	sbc	r19, r1
    6564:	41 09       	sbc	r20, r1
    6566:	51 09       	sbc	r21, r1
    6568:	c9 01       	movw	r24, r18
    656a:	1f 91       	pop	r17
    656c:	0f 91       	pop	r16
    656e:	ff 90       	pop	r15
    6570:	ef 90       	pop	r14
    6572:	08 95       	ret

00006574 <__pack_f>:
    6574:	df 92       	push	r13
    6576:	ef 92       	push	r14
    6578:	ff 92       	push	r15
    657a:	0f 93       	push	r16
    657c:	1f 93       	push	r17
    657e:	fc 01       	movw	r30, r24
    6580:	e4 80       	ldd	r14, Z+4	; 0x04
    6582:	f5 80       	ldd	r15, Z+5	; 0x05
    6584:	06 81       	ldd	r16, Z+6	; 0x06
    6586:	17 81       	ldd	r17, Z+7	; 0x07
    6588:	d1 80       	ldd	r13, Z+1	; 0x01
    658a:	80 81       	ld	r24, Z
    658c:	82 30       	cpi	r24, 0x02	; 2
    658e:	48 f4       	brcc	.+18     	; 0x65a2 <__pack_f+0x2e>
    6590:	80 e0       	ldi	r24, 0x00	; 0
    6592:	90 e0       	ldi	r25, 0x00	; 0
    6594:	a0 e1       	ldi	r26, 0x10	; 16
    6596:	b0 e0       	ldi	r27, 0x00	; 0
    6598:	e8 2a       	or	r14, r24
    659a:	f9 2a       	or	r15, r25
    659c:	0a 2b       	or	r16, r26
    659e:	1b 2b       	or	r17, r27
    65a0:	a5 c0       	rjmp	.+330    	; 0x66ec <__pack_f+0x178>
    65a2:	84 30       	cpi	r24, 0x04	; 4
    65a4:	09 f4       	brne	.+2      	; 0x65a8 <__pack_f+0x34>
    65a6:	9f c0       	rjmp	.+318    	; 0x66e6 <__pack_f+0x172>
    65a8:	82 30       	cpi	r24, 0x02	; 2
    65aa:	21 f4       	brne	.+8      	; 0x65b4 <__pack_f+0x40>
    65ac:	ee 24       	eor	r14, r14
    65ae:	ff 24       	eor	r15, r15
    65b0:	87 01       	movw	r16, r14
    65b2:	05 c0       	rjmp	.+10     	; 0x65be <__pack_f+0x4a>
    65b4:	e1 14       	cp	r14, r1
    65b6:	f1 04       	cpc	r15, r1
    65b8:	01 05       	cpc	r16, r1
    65ba:	11 05       	cpc	r17, r1
    65bc:	19 f4       	brne	.+6      	; 0x65c4 <__pack_f+0x50>
    65be:	e0 e0       	ldi	r30, 0x00	; 0
    65c0:	f0 e0       	ldi	r31, 0x00	; 0
    65c2:	96 c0       	rjmp	.+300    	; 0x66f0 <__pack_f+0x17c>
    65c4:	62 81       	ldd	r22, Z+2	; 0x02
    65c6:	73 81       	ldd	r23, Z+3	; 0x03
    65c8:	9f ef       	ldi	r25, 0xFF	; 255
    65ca:	62 38       	cpi	r22, 0x82	; 130
    65cc:	79 07       	cpc	r23, r25
    65ce:	0c f0       	brlt	.+2      	; 0x65d2 <__pack_f+0x5e>
    65d0:	5b c0       	rjmp	.+182    	; 0x6688 <__pack_f+0x114>
    65d2:	22 e8       	ldi	r18, 0x82	; 130
    65d4:	3f ef       	ldi	r19, 0xFF	; 255
    65d6:	26 1b       	sub	r18, r22
    65d8:	37 0b       	sbc	r19, r23
    65da:	2a 31       	cpi	r18, 0x1A	; 26
    65dc:	31 05       	cpc	r19, r1
    65de:	2c f0       	brlt	.+10     	; 0x65ea <__pack_f+0x76>
    65e0:	20 e0       	ldi	r18, 0x00	; 0
    65e2:	30 e0       	ldi	r19, 0x00	; 0
    65e4:	40 e0       	ldi	r20, 0x00	; 0
    65e6:	50 e0       	ldi	r21, 0x00	; 0
    65e8:	2a c0       	rjmp	.+84     	; 0x663e <__pack_f+0xca>
    65ea:	b8 01       	movw	r22, r16
    65ec:	a7 01       	movw	r20, r14
    65ee:	02 2e       	mov	r0, r18
    65f0:	04 c0       	rjmp	.+8      	; 0x65fa <__pack_f+0x86>
    65f2:	76 95       	lsr	r23
    65f4:	67 95       	ror	r22
    65f6:	57 95       	ror	r21
    65f8:	47 95       	ror	r20
    65fa:	0a 94       	dec	r0
    65fc:	d2 f7       	brpl	.-12     	; 0x65f2 <__pack_f+0x7e>
    65fe:	81 e0       	ldi	r24, 0x01	; 1
    6600:	90 e0       	ldi	r25, 0x00	; 0
    6602:	a0 e0       	ldi	r26, 0x00	; 0
    6604:	b0 e0       	ldi	r27, 0x00	; 0
    6606:	04 c0       	rjmp	.+8      	; 0x6610 <__pack_f+0x9c>
    6608:	88 0f       	add	r24, r24
    660a:	99 1f       	adc	r25, r25
    660c:	aa 1f       	adc	r26, r26
    660e:	bb 1f       	adc	r27, r27
    6610:	2a 95       	dec	r18
    6612:	d2 f7       	brpl	.-12     	; 0x6608 <__pack_f+0x94>
    6614:	01 97       	sbiw	r24, 0x01	; 1
    6616:	a1 09       	sbc	r26, r1
    6618:	b1 09       	sbc	r27, r1
    661a:	8e 21       	and	r24, r14
    661c:	9f 21       	and	r25, r15
    661e:	a0 23       	and	r26, r16
    6620:	b1 23       	and	r27, r17
    6622:	00 97       	sbiw	r24, 0x00	; 0
    6624:	a1 05       	cpc	r26, r1
    6626:	b1 05       	cpc	r27, r1
    6628:	21 f0       	breq	.+8      	; 0x6632 <__pack_f+0xbe>
    662a:	81 e0       	ldi	r24, 0x01	; 1
    662c:	90 e0       	ldi	r25, 0x00	; 0
    662e:	a0 e0       	ldi	r26, 0x00	; 0
    6630:	b0 e0       	ldi	r27, 0x00	; 0
    6632:	9a 01       	movw	r18, r20
    6634:	ab 01       	movw	r20, r22
    6636:	28 2b       	or	r18, r24
    6638:	39 2b       	or	r19, r25
    663a:	4a 2b       	or	r20, r26
    663c:	5b 2b       	or	r21, r27
    663e:	da 01       	movw	r26, r20
    6640:	c9 01       	movw	r24, r18
    6642:	8f 77       	andi	r24, 0x7F	; 127
    6644:	90 70       	andi	r25, 0x00	; 0
    6646:	a0 70       	andi	r26, 0x00	; 0
    6648:	b0 70       	andi	r27, 0x00	; 0
    664a:	80 34       	cpi	r24, 0x40	; 64
    664c:	91 05       	cpc	r25, r1
    664e:	a1 05       	cpc	r26, r1
    6650:	b1 05       	cpc	r27, r1
    6652:	39 f4       	brne	.+14     	; 0x6662 <__pack_f+0xee>
    6654:	27 ff       	sbrs	r18, 7
    6656:	09 c0       	rjmp	.+18     	; 0x666a <__pack_f+0xf6>
    6658:	20 5c       	subi	r18, 0xC0	; 192
    665a:	3f 4f       	sbci	r19, 0xFF	; 255
    665c:	4f 4f       	sbci	r20, 0xFF	; 255
    665e:	5f 4f       	sbci	r21, 0xFF	; 255
    6660:	04 c0       	rjmp	.+8      	; 0x666a <__pack_f+0xf6>
    6662:	21 5c       	subi	r18, 0xC1	; 193
    6664:	3f 4f       	sbci	r19, 0xFF	; 255
    6666:	4f 4f       	sbci	r20, 0xFF	; 255
    6668:	5f 4f       	sbci	r21, 0xFF	; 255
    666a:	e0 e0       	ldi	r30, 0x00	; 0
    666c:	f0 e0       	ldi	r31, 0x00	; 0
    666e:	20 30       	cpi	r18, 0x00	; 0
    6670:	a0 e0       	ldi	r26, 0x00	; 0
    6672:	3a 07       	cpc	r19, r26
    6674:	a0 e0       	ldi	r26, 0x00	; 0
    6676:	4a 07       	cpc	r20, r26
    6678:	a0 e4       	ldi	r26, 0x40	; 64
    667a:	5a 07       	cpc	r21, r26
    667c:	10 f0       	brcs	.+4      	; 0x6682 <__pack_f+0x10e>
    667e:	e1 e0       	ldi	r30, 0x01	; 1
    6680:	f0 e0       	ldi	r31, 0x00	; 0
    6682:	79 01       	movw	r14, r18
    6684:	8a 01       	movw	r16, r20
    6686:	27 c0       	rjmp	.+78     	; 0x66d6 <__pack_f+0x162>
    6688:	60 38       	cpi	r22, 0x80	; 128
    668a:	71 05       	cpc	r23, r1
    668c:	64 f5       	brge	.+88     	; 0x66e6 <__pack_f+0x172>
    668e:	fb 01       	movw	r30, r22
    6690:	e1 58       	subi	r30, 0x81	; 129
    6692:	ff 4f       	sbci	r31, 0xFF	; 255
    6694:	d8 01       	movw	r26, r16
    6696:	c7 01       	movw	r24, r14
    6698:	8f 77       	andi	r24, 0x7F	; 127
    669a:	90 70       	andi	r25, 0x00	; 0
    669c:	a0 70       	andi	r26, 0x00	; 0
    669e:	b0 70       	andi	r27, 0x00	; 0
    66a0:	80 34       	cpi	r24, 0x40	; 64
    66a2:	91 05       	cpc	r25, r1
    66a4:	a1 05       	cpc	r26, r1
    66a6:	b1 05       	cpc	r27, r1
    66a8:	39 f4       	brne	.+14     	; 0x66b8 <__pack_f+0x144>
    66aa:	e7 fe       	sbrs	r14, 7
    66ac:	0d c0       	rjmp	.+26     	; 0x66c8 <__pack_f+0x154>
    66ae:	80 e4       	ldi	r24, 0x40	; 64
    66b0:	90 e0       	ldi	r25, 0x00	; 0
    66b2:	a0 e0       	ldi	r26, 0x00	; 0
    66b4:	b0 e0       	ldi	r27, 0x00	; 0
    66b6:	04 c0       	rjmp	.+8      	; 0x66c0 <__pack_f+0x14c>
    66b8:	8f e3       	ldi	r24, 0x3F	; 63
    66ba:	90 e0       	ldi	r25, 0x00	; 0
    66bc:	a0 e0       	ldi	r26, 0x00	; 0
    66be:	b0 e0       	ldi	r27, 0x00	; 0
    66c0:	e8 0e       	add	r14, r24
    66c2:	f9 1e       	adc	r15, r25
    66c4:	0a 1f       	adc	r16, r26
    66c6:	1b 1f       	adc	r17, r27
    66c8:	17 ff       	sbrs	r17, 7
    66ca:	05 c0       	rjmp	.+10     	; 0x66d6 <__pack_f+0x162>
    66cc:	16 95       	lsr	r17
    66ce:	07 95       	ror	r16
    66d0:	f7 94       	ror	r15
    66d2:	e7 94       	ror	r14
    66d4:	31 96       	adiw	r30, 0x01	; 1
    66d6:	87 e0       	ldi	r24, 0x07	; 7
    66d8:	16 95       	lsr	r17
    66da:	07 95       	ror	r16
    66dc:	f7 94       	ror	r15
    66de:	e7 94       	ror	r14
    66e0:	8a 95       	dec	r24
    66e2:	d1 f7       	brne	.-12     	; 0x66d8 <__pack_f+0x164>
    66e4:	05 c0       	rjmp	.+10     	; 0x66f0 <__pack_f+0x17c>
    66e6:	ee 24       	eor	r14, r14
    66e8:	ff 24       	eor	r15, r15
    66ea:	87 01       	movw	r16, r14
    66ec:	ef ef       	ldi	r30, 0xFF	; 255
    66ee:	f0 e0       	ldi	r31, 0x00	; 0
    66f0:	6e 2f       	mov	r22, r30
    66f2:	67 95       	ror	r22
    66f4:	66 27       	eor	r22, r22
    66f6:	67 95       	ror	r22
    66f8:	90 2f       	mov	r25, r16
    66fa:	9f 77       	andi	r25, 0x7F	; 127
    66fc:	d7 94       	ror	r13
    66fe:	dd 24       	eor	r13, r13
    6700:	d7 94       	ror	r13
    6702:	8e 2f       	mov	r24, r30
    6704:	86 95       	lsr	r24
    6706:	49 2f       	mov	r20, r25
    6708:	46 2b       	or	r20, r22
    670a:	58 2f       	mov	r21, r24
    670c:	5d 29       	or	r21, r13
    670e:	b7 01       	movw	r22, r14
    6710:	ca 01       	movw	r24, r20
    6712:	1f 91       	pop	r17
    6714:	0f 91       	pop	r16
    6716:	ff 90       	pop	r15
    6718:	ef 90       	pop	r14
    671a:	df 90       	pop	r13
    671c:	08 95       	ret

0000671e <__unpack_f>:
    671e:	fc 01       	movw	r30, r24
    6720:	db 01       	movw	r26, r22
    6722:	40 81       	ld	r20, Z
    6724:	51 81       	ldd	r21, Z+1	; 0x01
    6726:	22 81       	ldd	r18, Z+2	; 0x02
    6728:	62 2f       	mov	r22, r18
    672a:	6f 77       	andi	r22, 0x7F	; 127
    672c:	70 e0       	ldi	r23, 0x00	; 0
    672e:	22 1f       	adc	r18, r18
    6730:	22 27       	eor	r18, r18
    6732:	22 1f       	adc	r18, r18
    6734:	93 81       	ldd	r25, Z+3	; 0x03
    6736:	89 2f       	mov	r24, r25
    6738:	88 0f       	add	r24, r24
    673a:	82 2b       	or	r24, r18
    673c:	28 2f       	mov	r18, r24
    673e:	30 e0       	ldi	r19, 0x00	; 0
    6740:	99 1f       	adc	r25, r25
    6742:	99 27       	eor	r25, r25
    6744:	99 1f       	adc	r25, r25
    6746:	11 96       	adiw	r26, 0x01	; 1
    6748:	9c 93       	st	X, r25
    674a:	11 97       	sbiw	r26, 0x01	; 1
    674c:	21 15       	cp	r18, r1
    674e:	31 05       	cpc	r19, r1
    6750:	a9 f5       	brne	.+106    	; 0x67bc <__unpack_f+0x9e>
    6752:	41 15       	cp	r20, r1
    6754:	51 05       	cpc	r21, r1
    6756:	61 05       	cpc	r22, r1
    6758:	71 05       	cpc	r23, r1
    675a:	11 f4       	brne	.+4      	; 0x6760 <__unpack_f+0x42>
    675c:	82 e0       	ldi	r24, 0x02	; 2
    675e:	37 c0       	rjmp	.+110    	; 0x67ce <__unpack_f+0xb0>
    6760:	82 e8       	ldi	r24, 0x82	; 130
    6762:	9f ef       	ldi	r25, 0xFF	; 255
    6764:	13 96       	adiw	r26, 0x03	; 3
    6766:	9c 93       	st	X, r25
    6768:	8e 93       	st	-X, r24
    676a:	12 97       	sbiw	r26, 0x02	; 2
    676c:	9a 01       	movw	r18, r20
    676e:	ab 01       	movw	r20, r22
    6770:	67 e0       	ldi	r22, 0x07	; 7
    6772:	22 0f       	add	r18, r18
    6774:	33 1f       	adc	r19, r19
    6776:	44 1f       	adc	r20, r20
    6778:	55 1f       	adc	r21, r21
    677a:	6a 95       	dec	r22
    677c:	d1 f7       	brne	.-12     	; 0x6772 <__unpack_f+0x54>
    677e:	83 e0       	ldi	r24, 0x03	; 3
    6780:	8c 93       	st	X, r24
    6782:	0d c0       	rjmp	.+26     	; 0x679e <__unpack_f+0x80>
    6784:	22 0f       	add	r18, r18
    6786:	33 1f       	adc	r19, r19
    6788:	44 1f       	adc	r20, r20
    678a:	55 1f       	adc	r21, r21
    678c:	12 96       	adiw	r26, 0x02	; 2
    678e:	8d 91       	ld	r24, X+
    6790:	9c 91       	ld	r25, X
    6792:	13 97       	sbiw	r26, 0x03	; 3
    6794:	01 97       	sbiw	r24, 0x01	; 1
    6796:	13 96       	adiw	r26, 0x03	; 3
    6798:	9c 93       	st	X, r25
    679a:	8e 93       	st	-X, r24
    679c:	12 97       	sbiw	r26, 0x02	; 2
    679e:	20 30       	cpi	r18, 0x00	; 0
    67a0:	80 e0       	ldi	r24, 0x00	; 0
    67a2:	38 07       	cpc	r19, r24
    67a4:	80 e0       	ldi	r24, 0x00	; 0
    67a6:	48 07       	cpc	r20, r24
    67a8:	80 e4       	ldi	r24, 0x40	; 64
    67aa:	58 07       	cpc	r21, r24
    67ac:	58 f3       	brcs	.-42     	; 0x6784 <__unpack_f+0x66>
    67ae:	14 96       	adiw	r26, 0x04	; 4
    67b0:	2d 93       	st	X+, r18
    67b2:	3d 93       	st	X+, r19
    67b4:	4d 93       	st	X+, r20
    67b6:	5c 93       	st	X, r21
    67b8:	17 97       	sbiw	r26, 0x07	; 7
    67ba:	08 95       	ret
    67bc:	2f 3f       	cpi	r18, 0xFF	; 255
    67be:	31 05       	cpc	r19, r1
    67c0:	79 f4       	brne	.+30     	; 0x67e0 <__unpack_f+0xc2>
    67c2:	41 15       	cp	r20, r1
    67c4:	51 05       	cpc	r21, r1
    67c6:	61 05       	cpc	r22, r1
    67c8:	71 05       	cpc	r23, r1
    67ca:	19 f4       	brne	.+6      	; 0x67d2 <__unpack_f+0xb4>
    67cc:	84 e0       	ldi	r24, 0x04	; 4
    67ce:	8c 93       	st	X, r24
    67d0:	08 95       	ret
    67d2:	64 ff       	sbrs	r22, 4
    67d4:	03 c0       	rjmp	.+6      	; 0x67dc <__unpack_f+0xbe>
    67d6:	81 e0       	ldi	r24, 0x01	; 1
    67d8:	8c 93       	st	X, r24
    67da:	12 c0       	rjmp	.+36     	; 0x6800 <__unpack_f+0xe2>
    67dc:	1c 92       	st	X, r1
    67de:	10 c0       	rjmp	.+32     	; 0x6800 <__unpack_f+0xe2>
    67e0:	2f 57       	subi	r18, 0x7F	; 127
    67e2:	30 40       	sbci	r19, 0x00	; 0
    67e4:	13 96       	adiw	r26, 0x03	; 3
    67e6:	3c 93       	st	X, r19
    67e8:	2e 93       	st	-X, r18
    67ea:	12 97       	sbiw	r26, 0x02	; 2
    67ec:	83 e0       	ldi	r24, 0x03	; 3
    67ee:	8c 93       	st	X, r24
    67f0:	87 e0       	ldi	r24, 0x07	; 7
    67f2:	44 0f       	add	r20, r20
    67f4:	55 1f       	adc	r21, r21
    67f6:	66 1f       	adc	r22, r22
    67f8:	77 1f       	adc	r23, r23
    67fa:	8a 95       	dec	r24
    67fc:	d1 f7       	brne	.-12     	; 0x67f2 <__unpack_f+0xd4>
    67fe:	70 64       	ori	r23, 0x40	; 64
    6800:	14 96       	adiw	r26, 0x04	; 4
    6802:	4d 93       	st	X+, r20
    6804:	5d 93       	st	X+, r21
    6806:	6d 93       	st	X+, r22
    6808:	7c 93       	st	X, r23
    680a:	17 97       	sbiw	r26, 0x07	; 7
    680c:	08 95       	ret

0000680e <__fpcmp_parts_f>:
    680e:	1f 93       	push	r17
    6810:	dc 01       	movw	r26, r24
    6812:	fb 01       	movw	r30, r22
    6814:	9c 91       	ld	r25, X
    6816:	92 30       	cpi	r25, 0x02	; 2
    6818:	08 f4       	brcc	.+2      	; 0x681c <__fpcmp_parts_f+0xe>
    681a:	47 c0       	rjmp	.+142    	; 0x68aa <__fpcmp_parts_f+0x9c>
    681c:	80 81       	ld	r24, Z
    681e:	82 30       	cpi	r24, 0x02	; 2
    6820:	08 f4       	brcc	.+2      	; 0x6824 <__fpcmp_parts_f+0x16>
    6822:	43 c0       	rjmp	.+134    	; 0x68aa <__fpcmp_parts_f+0x9c>
    6824:	94 30       	cpi	r25, 0x04	; 4
    6826:	51 f4       	brne	.+20     	; 0x683c <__fpcmp_parts_f+0x2e>
    6828:	11 96       	adiw	r26, 0x01	; 1
    682a:	1c 91       	ld	r17, X
    682c:	84 30       	cpi	r24, 0x04	; 4
    682e:	99 f5       	brne	.+102    	; 0x6896 <__fpcmp_parts_f+0x88>
    6830:	81 81       	ldd	r24, Z+1	; 0x01
    6832:	68 2f       	mov	r22, r24
    6834:	70 e0       	ldi	r23, 0x00	; 0
    6836:	61 1b       	sub	r22, r17
    6838:	71 09       	sbc	r23, r1
    683a:	3f c0       	rjmp	.+126    	; 0x68ba <__fpcmp_parts_f+0xac>
    683c:	84 30       	cpi	r24, 0x04	; 4
    683e:	21 f0       	breq	.+8      	; 0x6848 <__fpcmp_parts_f+0x3a>
    6840:	92 30       	cpi	r25, 0x02	; 2
    6842:	31 f4       	brne	.+12     	; 0x6850 <__fpcmp_parts_f+0x42>
    6844:	82 30       	cpi	r24, 0x02	; 2
    6846:	b9 f1       	breq	.+110    	; 0x68b6 <__fpcmp_parts_f+0xa8>
    6848:	81 81       	ldd	r24, Z+1	; 0x01
    684a:	88 23       	and	r24, r24
    684c:	89 f1       	breq	.+98     	; 0x68b0 <__fpcmp_parts_f+0xa2>
    684e:	2d c0       	rjmp	.+90     	; 0x68aa <__fpcmp_parts_f+0x9c>
    6850:	11 96       	adiw	r26, 0x01	; 1
    6852:	1c 91       	ld	r17, X
    6854:	11 97       	sbiw	r26, 0x01	; 1
    6856:	82 30       	cpi	r24, 0x02	; 2
    6858:	f1 f0       	breq	.+60     	; 0x6896 <__fpcmp_parts_f+0x88>
    685a:	81 81       	ldd	r24, Z+1	; 0x01
    685c:	18 17       	cp	r17, r24
    685e:	d9 f4       	brne	.+54     	; 0x6896 <__fpcmp_parts_f+0x88>
    6860:	12 96       	adiw	r26, 0x02	; 2
    6862:	2d 91       	ld	r18, X+
    6864:	3c 91       	ld	r19, X
    6866:	13 97       	sbiw	r26, 0x03	; 3
    6868:	82 81       	ldd	r24, Z+2	; 0x02
    686a:	93 81       	ldd	r25, Z+3	; 0x03
    686c:	82 17       	cp	r24, r18
    686e:	93 07       	cpc	r25, r19
    6870:	94 f0       	brlt	.+36     	; 0x6896 <__fpcmp_parts_f+0x88>
    6872:	28 17       	cp	r18, r24
    6874:	39 07       	cpc	r19, r25
    6876:	bc f0       	brlt	.+46     	; 0x68a6 <__fpcmp_parts_f+0x98>
    6878:	14 96       	adiw	r26, 0x04	; 4
    687a:	8d 91       	ld	r24, X+
    687c:	9d 91       	ld	r25, X+
    687e:	0d 90       	ld	r0, X+
    6880:	bc 91       	ld	r27, X
    6882:	a0 2d       	mov	r26, r0
    6884:	24 81       	ldd	r18, Z+4	; 0x04
    6886:	35 81       	ldd	r19, Z+5	; 0x05
    6888:	46 81       	ldd	r20, Z+6	; 0x06
    688a:	57 81       	ldd	r21, Z+7	; 0x07
    688c:	28 17       	cp	r18, r24
    688e:	39 07       	cpc	r19, r25
    6890:	4a 07       	cpc	r20, r26
    6892:	5b 07       	cpc	r21, r27
    6894:	18 f4       	brcc	.+6      	; 0x689c <__fpcmp_parts_f+0x8e>
    6896:	11 23       	and	r17, r17
    6898:	41 f0       	breq	.+16     	; 0x68aa <__fpcmp_parts_f+0x9c>
    689a:	0a c0       	rjmp	.+20     	; 0x68b0 <__fpcmp_parts_f+0xa2>
    689c:	82 17       	cp	r24, r18
    689e:	93 07       	cpc	r25, r19
    68a0:	a4 07       	cpc	r26, r20
    68a2:	b5 07       	cpc	r27, r21
    68a4:	40 f4       	brcc	.+16     	; 0x68b6 <__fpcmp_parts_f+0xa8>
    68a6:	11 23       	and	r17, r17
    68a8:	19 f0       	breq	.+6      	; 0x68b0 <__fpcmp_parts_f+0xa2>
    68aa:	61 e0       	ldi	r22, 0x01	; 1
    68ac:	70 e0       	ldi	r23, 0x00	; 0
    68ae:	05 c0       	rjmp	.+10     	; 0x68ba <__fpcmp_parts_f+0xac>
    68b0:	6f ef       	ldi	r22, 0xFF	; 255
    68b2:	7f ef       	ldi	r23, 0xFF	; 255
    68b4:	02 c0       	rjmp	.+4      	; 0x68ba <__fpcmp_parts_f+0xac>
    68b6:	60 e0       	ldi	r22, 0x00	; 0
    68b8:	70 e0       	ldi	r23, 0x00	; 0
    68ba:	cb 01       	movw	r24, r22
    68bc:	1f 91       	pop	r17
    68be:	08 95       	ret

000068c0 <__prologue_saves__>:
    68c0:	2f 92       	push	r2
    68c2:	3f 92       	push	r3
    68c4:	4f 92       	push	r4
    68c6:	5f 92       	push	r5
    68c8:	6f 92       	push	r6
    68ca:	7f 92       	push	r7
    68cc:	8f 92       	push	r8
    68ce:	9f 92       	push	r9
    68d0:	af 92       	push	r10
    68d2:	bf 92       	push	r11
    68d4:	cf 92       	push	r12
    68d6:	df 92       	push	r13
    68d8:	ef 92       	push	r14
    68da:	ff 92       	push	r15
    68dc:	0f 93       	push	r16
    68de:	1f 93       	push	r17
    68e0:	cf 93       	push	r28
    68e2:	df 93       	push	r29
    68e4:	cd b7       	in	r28, 0x3d	; 61
    68e6:	de b7       	in	r29, 0x3e	; 62
    68e8:	ca 1b       	sub	r28, r26
    68ea:	db 0b       	sbc	r29, r27
    68ec:	0f b6       	in	r0, 0x3f	; 63
    68ee:	f8 94       	cli
    68f0:	de bf       	out	0x3e, r29	; 62
    68f2:	0f be       	out	0x3f, r0	; 63
    68f4:	cd bf       	out	0x3d, r28	; 61
    68f6:	09 94       	ijmp

000068f8 <__epilogue_restores__>:
    68f8:	2a 88       	ldd	r2, Y+18	; 0x12
    68fa:	39 88       	ldd	r3, Y+17	; 0x11
    68fc:	48 88       	ldd	r4, Y+16	; 0x10
    68fe:	5f 84       	ldd	r5, Y+15	; 0x0f
    6900:	6e 84       	ldd	r6, Y+14	; 0x0e
    6902:	7d 84       	ldd	r7, Y+13	; 0x0d
    6904:	8c 84       	ldd	r8, Y+12	; 0x0c
    6906:	9b 84       	ldd	r9, Y+11	; 0x0b
    6908:	aa 84       	ldd	r10, Y+10	; 0x0a
    690a:	b9 84       	ldd	r11, Y+9	; 0x09
    690c:	c8 84       	ldd	r12, Y+8	; 0x08
    690e:	df 80       	ldd	r13, Y+7	; 0x07
    6910:	ee 80       	ldd	r14, Y+6	; 0x06
    6912:	fd 80       	ldd	r15, Y+5	; 0x05
    6914:	0c 81       	ldd	r16, Y+4	; 0x04
    6916:	1b 81       	ldd	r17, Y+3	; 0x03
    6918:	aa 81       	ldd	r26, Y+2	; 0x02
    691a:	b9 81       	ldd	r27, Y+1	; 0x01
    691c:	ce 0f       	add	r28, r30
    691e:	d1 1d       	adc	r29, r1
    6920:	0f b6       	in	r0, 0x3f	; 63
    6922:	f8 94       	cli
    6924:	de bf       	out	0x3e, r29	; 62
    6926:	0f be       	out	0x3f, r0	; 63
    6928:	cd bf       	out	0x3d, r28	; 61
    692a:	ed 01       	movw	r28, r26
    692c:	08 95       	ret

0000692e <fmax>:
    692e:	99 0f       	add	r25, r25
    6930:	bb 0b       	sbc	r27, r27
    6932:	55 0f       	add	r21, r21
    6934:	aa 0b       	sbc	r26, r26
    6936:	e0 e8       	ldi	r30, 0x80	; 128
    6938:	fe ef       	ldi	r31, 0xFE	; 254
    693a:	16 16       	cp	r1, r22
    693c:	17 06       	cpc	r1, r23
    693e:	e8 07       	cpc	r30, r24
    6940:	f9 07       	cpc	r31, r25
    6942:	70 f0       	brcs	.+28     	; 0x6960 <fmax+0x32>
    6944:	12 16       	cp	r1, r18
    6946:	13 06       	cpc	r1, r19
    6948:	e4 07       	cpc	r30, r20
    694a:	f5 07       	cpc	r31, r21
    694c:	60 f0       	brcs	.+24     	; 0x6966 <fmax+0x38>
    694e:	ba 17       	cp	r27, r26
    6950:	3c f0       	brlt	.+14     	; 0x6960 <fmax+0x32>
    6952:	49 f4       	brne	.+18     	; 0x6966 <fmax+0x38>
    6954:	62 17       	cp	r22, r18
    6956:	73 07       	cpc	r23, r19
    6958:	84 07       	cpc	r24, r20
    695a:	95 07       	cpc	r25, r21
    695c:	a7 95       	ror	r26
    695e:	1b f4       	brvc	.+6      	; 0x6966 <fmax+0x38>
    6960:	b9 01       	movw	r22, r18
    6962:	ca 01       	movw	r24, r20
    6964:	ba 2f       	mov	r27, r26
    6966:	b6 95       	lsr	r27
    6968:	97 95       	ror	r25
    696a:	08 95       	ret

0000696c <fmin>:
    696c:	99 0f       	add	r25, r25
    696e:	bb 0b       	sbc	r27, r27
    6970:	55 0f       	add	r21, r21
    6972:	aa 0b       	sbc	r26, r26
    6974:	e0 e8       	ldi	r30, 0x80	; 128
    6976:	fe ef       	ldi	r31, 0xFE	; 254
    6978:	16 16       	cp	r1, r22
    697a:	17 06       	cpc	r1, r23
    697c:	e8 07       	cpc	r30, r24
    697e:	f9 07       	cpc	r31, r25
    6980:	70 f0       	brcs	.+28     	; 0x699e <fmin+0x32>
    6982:	12 16       	cp	r1, r18
    6984:	13 06       	cpc	r1, r19
    6986:	e4 07       	cpc	r30, r20
    6988:	f5 07       	cpc	r31, r21
    698a:	60 f0       	brcs	.+24     	; 0x69a4 <fmin+0x38>
    698c:	ba 17       	cp	r27, r26
    698e:	54 f0       	brlt	.+20     	; 0x69a4 <fmin+0x38>
    6990:	31 f4       	brne	.+12     	; 0x699e <fmin+0x32>
    6992:	26 17       	cp	r18, r22
    6994:	37 07       	cpc	r19, r23
    6996:	48 07       	cpc	r20, r24
    6998:	59 07       	cpc	r21, r25
    699a:	a7 95       	ror	r26
    699c:	1b f4       	brvc	.+6      	; 0x69a4 <fmin+0x38>
    699e:	b9 01       	movw	r22, r18
    69a0:	ca 01       	movw	r24, r20
    69a2:	ba 2f       	mov	r27, r26
    69a4:	b6 95       	lsr	r27
    69a6:	97 95       	ror	r25
    69a8:	08 95       	ret
    69aa:	11 f4       	brne	.+4      	; 0x69b0 <fmin+0x44>
    69ac:	0e f4       	brtc	.+2      	; 0x69b0 <fmin+0x44>
    69ae:	5b c0       	rjmp	.+182    	; 0x6a66 <__fp_nan>
    69b0:	4a c0       	rjmp	.+148    	; 0x6a46 <__fp_mpack>

000069b2 <sqrt>:
    69b2:	6b d0       	rcall	.+214    	; 0x6a8a <__fp_splitA>
    69b4:	d0 f3       	brcs	.-12     	; 0x69aa <fmin+0x3e>
    69b6:	99 23       	and	r25, r25
    69b8:	d9 f3       	breq	.-10     	; 0x69b0 <fmin+0x44>
    69ba:	ce f3       	brts	.-14     	; 0x69ae <fmin+0x42>
    69bc:	9f 57       	subi	r25, 0x7F	; 127
    69be:	55 0b       	sbc	r21, r21
    69c0:	87 ff       	sbrs	r24, 7
    69c2:	54 d0       	rcall	.+168    	; 0x6a6c <__fp_norm2>
    69c4:	56 95       	lsr	r21
    69c6:	97 95       	ror	r25
    69c8:	b0 e0       	ldi	r27, 0x00	; 0
    69ca:	20 f4       	brcc	.+8      	; 0x69d4 <sqrt+0x22>
    69cc:	66 0f       	add	r22, r22
    69ce:	77 1f       	adc	r23, r23
    69d0:	88 1f       	adc	r24, r24
    69d2:	bb 1f       	adc	r27, r27
    69d4:	1f 93       	push	r17
    69d6:	0f 93       	push	r16
    69d8:	00 24       	eor	r0, r0
    69da:	90 01       	movw	r18, r0
    69dc:	a0 01       	movw	r20, r0
    69de:	80 01       	movw	r16, r0
    69e0:	f0 01       	movw	r30, r0
    69e2:	a0 e8       	ldi	r26, 0x80	; 128
    69e4:	0e 0f       	add	r16, r30
    69e6:	1f 1f       	adc	r17, r31
    69e8:	0a 1e       	adc	r0, r26
    69ea:	51 1d       	adc	r21, r1
    69ec:	60 1b       	sub	r22, r16
    69ee:	71 0b       	sbc	r23, r17
    69f0:	80 09       	sbc	r24, r0
    69f2:	b5 0b       	sbc	r27, r21
    69f4:	48 f4       	brcc	.+18     	; 0x6a08 <sqrt+0x56>
    69f6:	60 0f       	add	r22, r16
    69f8:	71 1f       	adc	r23, r17
    69fa:	80 1d       	adc	r24, r0
    69fc:	b5 1f       	adc	r27, r21
    69fe:	0e 1b       	sub	r16, r30
    6a00:	1f 0b       	sbc	r17, r31
    6a02:	0a 0a       	sbc	r0, r26
    6a04:	51 09       	sbc	r21, r1
    6a06:	07 c0       	rjmp	.+14     	; 0x6a16 <sqrt+0x64>
    6a08:	2e 0f       	add	r18, r30
    6a0a:	3f 1f       	adc	r19, r31
    6a0c:	4a 1f       	adc	r20, r26
    6a0e:	0e 0f       	add	r16, r30
    6a10:	1f 1f       	adc	r17, r31
    6a12:	0a 1e       	adc	r0, r26
    6a14:	51 1d       	adc	r21, r1
    6a16:	66 0f       	add	r22, r22
    6a18:	77 1f       	adc	r23, r23
    6a1a:	88 1f       	adc	r24, r24
    6a1c:	bb 1f       	adc	r27, r27
    6a1e:	a6 95       	lsr	r26
    6a20:	f7 95       	ror	r31
    6a22:	e7 95       	ror	r30
    6a24:	f8 f6       	brcc	.-66     	; 0x69e4 <sqrt+0x32>
    6a26:	06 17       	cp	r16, r22
    6a28:	17 07       	cpc	r17, r23
    6a2a:	08 06       	cpc	r0, r24
    6a2c:	5b 07       	cpc	r21, r27
    6a2e:	21 1d       	adc	r18, r1
    6a30:	31 1d       	adc	r19, r1
    6a32:	41 1d       	adc	r20, r1
    6a34:	0f 91       	pop	r16
    6a36:	1f 91       	pop	r17
    6a38:	b9 01       	movw	r22, r18
    6a3a:	84 2f       	mov	r24, r20
    6a3c:	91 58       	subi	r25, 0x81	; 129
    6a3e:	88 0f       	add	r24, r24
    6a40:	96 95       	lsr	r25
    6a42:	87 95       	ror	r24
    6a44:	08 95       	ret

00006a46 <__fp_mpack>:
    6a46:	9f 3f       	cpi	r25, 0xFF	; 255
    6a48:	49 f0       	breq	.+18     	; 0x6a5c <__fp_mpack+0x16>
    6a4a:	91 50       	subi	r25, 0x01	; 1
    6a4c:	28 f4       	brcc	.+10     	; 0x6a58 <__fp_mpack+0x12>
    6a4e:	86 95       	lsr	r24
    6a50:	77 95       	ror	r23
    6a52:	67 95       	ror	r22
    6a54:	b7 95       	ror	r27
    6a56:	9f 5f       	subi	r25, 0xFF	; 255
    6a58:	80 38       	cpi	r24, 0x80	; 128
    6a5a:	9f 4f       	sbci	r25, 0xFF	; 255
    6a5c:	88 0f       	add	r24, r24
    6a5e:	96 95       	lsr	r25
    6a60:	87 95       	ror	r24
    6a62:	97 f9       	bld	r25, 7
    6a64:	08 95       	ret

00006a66 <__fp_nan>:
    6a66:	9f ef       	ldi	r25, 0xFF	; 255
    6a68:	80 ec       	ldi	r24, 0xC0	; 192
    6a6a:	08 95       	ret

00006a6c <__fp_norm2>:
    6a6c:	91 50       	subi	r25, 0x01	; 1
    6a6e:	50 40       	sbci	r21, 0x00	; 0
    6a70:	66 0f       	add	r22, r22
    6a72:	77 1f       	adc	r23, r23
    6a74:	88 1f       	adc	r24, r24
    6a76:	d2 f7       	brpl	.-12     	; 0x6a6c <__fp_norm2>
    6a78:	08 95       	ret

00006a7a <__fp_split3>:
    6a7a:	57 fd       	sbrc	r21, 7
    6a7c:	90 58       	subi	r25, 0x80	; 128
    6a7e:	44 0f       	add	r20, r20
    6a80:	55 1f       	adc	r21, r21
    6a82:	59 f0       	breq	.+22     	; 0x6a9a <__fp_splitA+0x10>
    6a84:	5f 3f       	cpi	r21, 0xFF	; 255
    6a86:	71 f0       	breq	.+28     	; 0x6aa4 <__fp_splitA+0x1a>
    6a88:	47 95       	ror	r20

00006a8a <__fp_splitA>:
    6a8a:	88 0f       	add	r24, r24
    6a8c:	97 fb       	bst	r25, 7
    6a8e:	99 1f       	adc	r25, r25
    6a90:	61 f0       	breq	.+24     	; 0x6aaa <__fp_splitA+0x20>
    6a92:	9f 3f       	cpi	r25, 0xFF	; 255
    6a94:	79 f0       	breq	.+30     	; 0x6ab4 <__fp_splitA+0x2a>
    6a96:	87 95       	ror	r24
    6a98:	08 95       	ret
    6a9a:	12 16       	cp	r1, r18
    6a9c:	13 06       	cpc	r1, r19
    6a9e:	14 06       	cpc	r1, r20
    6aa0:	55 1f       	adc	r21, r21
    6aa2:	f2 cf       	rjmp	.-28     	; 0x6a88 <__fp_split3+0xe>
    6aa4:	46 95       	lsr	r20
    6aa6:	f1 df       	rcall	.-30     	; 0x6a8a <__fp_splitA>
    6aa8:	08 c0       	rjmp	.+16     	; 0x6aba <__fp_splitA+0x30>
    6aaa:	16 16       	cp	r1, r22
    6aac:	17 06       	cpc	r1, r23
    6aae:	18 06       	cpc	r1, r24
    6ab0:	99 1f       	adc	r25, r25
    6ab2:	f1 cf       	rjmp	.-30     	; 0x6a96 <__fp_splitA+0xc>
    6ab4:	86 95       	lsr	r24
    6ab6:	71 05       	cpc	r23, r1
    6ab8:	61 05       	cpc	r22, r1
    6aba:	08 94       	sec
    6abc:	08 95       	ret

00006abe <_exit>:
    6abe:	f8 94       	cli

00006ac0 <__stop_program>:
    6ac0:	ff cf       	rjmp	.-2      	; 0x6ac0 <__stop_program>
